---
title: "0516 - 0522"
tag: TIL
category: TIL
excerpt: ""
---

## 0516

# Singleton 패턴

## 의도

싱글턴 패턴은 클래스에 인스턴스가 하나만 있는지 확인하는 동시에 이 인스턴스에 대한 전역 접근점을 제공한다.  
![BEC07DFA-C336-4630-826A-576FABC7B4FC](https://user-images.githubusercontent.com/61184798/169433527-26389a24-798e-4a8e-ac4e-6d1c3e02de32.png)

## 문제점

싱글턴 패턴은 단일 책임 원칙을 위배하지만, 두 가지 문제를 동시에 해결한다

1. 클래스에 인스턴스가 하나만 있는지 확인한다.
2. 해당 인스턴스에 대한 전역 접근점을 제공한다.

클래스에 있는 인스턴스 수를 제어하려는 가장 일반적인 이유는 일부 공유 리소스(데이터베이스 또는 파일)에 대한 액세스를 제어하기 위한 것이다.

싱글턴 패턴의 동작 방식은 다음과 같다.  
객체를 생성했지만 잠시 후 새 객체를 생성하기로 결정했다면, 새 객체를 받는 대신 이미 만든 객체를 받게 된다.  
생성자 호출은 항상 새 객체를 의도적으로 반환해야 하므로, 이 동작은 일반 생성자로 구현할 수 없다.

![0C8223BD-3F65-4655-A1B3-472FB7246B7C](https://user-images.githubusercontent.com/61184798/169433543-331e058f-3597-4da4-8afb-2a96c0563484.png)

다만 전역 변수와 마찬가지로 Singleton 패턴을 사용하면 프로그램의 어느 곳에서나 일부 객체에 액세스할 수 있다. 하지만 다른 코드가 해당 인스턴스를 덮어쓰지 않도록 보호해야 한다.

## 해결책

싱글턴의 모든 구현에는 다음 두 단계의 공통점이 있다.

- new 연산자로 싱글턴 클래스를 사용하지 못하도록 기본 생성자를 비공개로 설정한다.
- 생성자 역할을 하는 정적 생성 메서드를 만든다. 이 메서드는 private 생성자를 호출하여 객체를 만들고 정적 필드에 저장한다. 이 메서드에 대한 다음 호출은 캐시된 객체를 반환한다.

코드가 싱글턴 클래스에 액세스할 수 있는 경우 싱글턴의 정적 메서드를 호출할 수 있다. 따라서 해당 메서드가 호출될 때마다 항상 동일한 객체가 반환된다.

## 실세계와 유사한 사례

정부는 싱글턴 패턴의 훌륭한 예이다. 국가는 하나의 공식 정부만 가질 수 있기에 정부를 구성하는 개인의 신원에 관계없이 X의 정부라는 제목은 담당자 그룹을 식별하는 전역 접근점이다.

## 구조

![91A74E03-5C3E-4D5D-B79E-CEBF3F3EA342](https://user-images.githubusercontent.com/61184798/169433548-e643b8c2-e8d3-4494-a37e-29327b868c94.png)

1. 싱글턴의 클래스는 자체 클래스의 동일한 동일한 인스턴스를 반환하는 getInstance 정적 메서드를 선언한다. 싱글턴의 생성자는 클라이언트의 코드에서 숨겨져야 한다. 메서드를 호출하는 것이 싱글턴 객체를 가져오는 유일한 방법이어야 한다.

## 적용 가능성

- 프로그램의 클래스에 모든 클라이언트가 사용할 수 있는 단일 인스턴스만 있어야 하는 경우 싱글턴 패턴을 사용한다. 예를 들어, 프로그램의 다른 부분에서 공유하는 단일 데이터베이스 객체이다.
- 전역 변수를 더 엄격하게 제어해야 하는 경우 싱글턴 패턴을 사용한다.

## 장점과 단점

### 장점

- 클래스에 단일 인스턴스만 있음을 확인할 수 있다.
- 해당 인스턴스에 대한 전역 점근점을 얻는다.
- 싱글턴 객체는 처음 요청될 때만 초기화된다.

### 단점

- 단일 책임 원칙을 위배한다.
- 여러 스레드가 여러 번 단일 객체를 만들지 않도록 다중 스레드 환경에서 패턴을 특수 처리해야 한다.
- 단위 테스트하기 어렵다.

## 타입스크립트로 패턴 구현

많은 개발자가 싱글턴 패턴을 안티 패턴으로 간주한다. 그렇기에 타입스크립트 코드에서 사용이 감소한다.

```typescript
class Singleton {
  private static instance: Singleton;

  private constructor() {}

  public static getInstance(): Singleton {
    if (!Singleton.instance) {
      Singleton.instance = new Singleton();
    }

    return Singleton.instance;
  }

  public someBudsinessLogic() {}
}

function clientCode() {
  const s1 = Singleton.getInstance();
  const s2 = Singleton.getInstance();

  if (s1 === s2) {
    console.log("Singleton works, both variables contain the same instance.");
  } else {
    console.log("Singleton failed, variables contain different instances.");
  }
}

clientCode();
```

### 실행 결과

![CE8D847D-2AC2-487E-8540-ED63668FC750](https://user-images.githubusercontent.com/61184798/169433554-458702f8-1e7e-4e7f-8cca-18b12b0c3324.png)
