---
title: "1108-1114"
tag: TIL
category: TIL
---

## 1108

이번 주 목요일에 모의 면접이 있을 예정이라 이와 관련해서 헷갈렸던 개념들을 하나씩 정리하고자 한다.

# 자바스크립트는 정적타입인가 동적타입인가?

## 동적 타입 언어와 정적 타입 언어

### 정적 타입 언어 특징

- 정적 타입 언어는 데이터 타입을 사전에 선언해야 한다.
- 변수의 타입을 변경할 수 없으며, 선언한 타입에 맞는 값만 할당할 수 있다.
- 컴파일 시점에 타입 체크를 수행하여 통과하지 못하면 에러를 발생시키고 프로그램 실행 자체를 막는다.

### 자바스크립트의 타입

- 자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정된다.
- 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다.
  -> 동적 타이핑

### 변수는 타입을 가질까?

기본적으로 변수는 타입을 갖지 않지만, 값이 타입을 가지기 때문에 현재 변수에 할당되어 있는 값에 의해 변수의 타입이 동적으로 결정된다.

### 동적 타입 언어와 변수

- 변수 값은 언제든지 변경될 수 있기 때문에 복잡한 프로그램에서는 변화하는 변수 값을 추적하기 어려울 수 있다.
- 값의 변경에 의해 변수의 타입도 언제든지 변경될 수 있기 때문에 동적 타입 언어의 변수는 값을 확인하기 전에 타입을 확신할 수 없다.
- 자바스크립트 엔진에 의해 암묵적으로 타입이 자동으로 변환되기도 한다.  
  -> 동적 타입 언어는 유연성은 높지만 신뢰성은 떨어진다.

**컴파일**이란 개발자가 작성한 소스코드를 바이너리 코드로 변환하는 과정  
**빌드**란 소스코드 파일을 실행가능한 소프트웨어 산출물로 만드는 일련의 과정

<br />

## 1109

# this 바인딩

**바인딩** 식별자와 값을 연결하는 과정

this는 자신이 속한 객체 또는 자신이 생성할 가리키는 자기 참조 변수
this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다.

자바스크립트의 this는 함수가 호출되는 방식에 따라 this에 바인딩될 값이 동적으로 결정된다.

1. 일반 함수로 호출된 모든 함수 내부의 this에는 전역 객체가 바인딩된다.

2. 메서드로 호출된 함수 내부의 this에는 메서드를 호출한 객체가 바인딩된다.

3. 생성자 함수 내부의 this에는 생성자 함수가 생성할 인스턴스가 바인딩된다.

4. Function.prototype.call/apply/bind 메서드는 첫 번째 인수로 전달한 특정 객체를 호출한 함수의 this에 바인딩한다.

- 메서드 내에서 정의한 중첩 함수 또는 콜백 함수가 일반 함수로 호출될 때는 this가 전역 객체를 바인딩하는 것은 문제가 있다.
- 중첩 함수나 콜백 함수는 외부 함수를 돕는 헬퍼 함수의 역할을 하는데, 외부 함수인 메서드와 중첩 함수 또는 콜백 함수의 this가 일치하지 않는다.
- 이를 일치시키기 위해 두 가지 방법이 있다. Function.prototype.bind 메서드를 사용하거나, 화살표 함수를 사용한다.
- call/apply 메서드의 대표적인 용도는 arguments 같은 유사 배열 객체에 배열 메서드를 사용하는 경우
- bind 메서드의 대표적인 용도는 메서드 내부의 중첩 함수나 콜백 함수의 this가 불일치하는 문제를 해결

<br />

## 1110

# 서버사이드 렌더링과 클라이언트사이드 렌더링 차이

클라이언트 사이트 렌더링은 의미가 다양할 수 있지만 보통 브라우저에서 자바스크립트를 사용해 콘텐츠를 렌더링하는 것을 의미한다.
처음에 서버에서 index.html을 클라이언트에 보내주면 <body>안에는 id="root"만 하나 들어있고 애플리케이션에서 필요한 자바스크립트의 링크만 들어가 있다. html은 비어져 있기 때문에 처음에 접속하면 빈 화면만 보이고 다시 링크된 자바스크립트 파일을 서버로부터 다운로드 받게 되는데, 여기에는 애플리케이션에서 필요한 로직들 뿐만 아니라 애플리케이션을 구동하는 프레임워크와 라이브러리 소스코드들도 다 포함이 되어 있다. 그래서 사이즈가 커서 다운로드 받는데도 시간이 걸린다. 추가로 필요한 데이터가 있다면 서버에 요청해서 데이터를 받아온 다음에 이것들을 기반으로 동적으로 html을 생성해서 사용자에게 최종적인 애플리케이션을 보여주게 된다.

서버 사이드 렌더링은 서버에서 보여줄 페이지를 모두 구성하여 사용자에게 페이지를 보여주는 방식이다. 웹사이트에 접속하면 서버에서 필요한 데이터를 모두 가져와서 html 파일을 만들게 되고, 만들어진 html 파일을 동적으로 제어할 수 있는 소스코드와 함께 클라이언트에 보내주게 된다. 그러면 클라이언트 상에서는 잘 만들어진 html 문서를 받아와서 사용자에게 보여줄 수 있게 된다.

CSR은 초기 화면 로딩이 느리고, SEO가 취약할 수 있지만 초기 로딩 이후 빠른 웹사이트 렌더링이 가능하다.
SSR은 초기 화면 로딩이 빠르고 모든 컨텐츠가 html 안에 담겨져 있기 때문에 SEO에 최적화되어 있지만 좋지 않은 사용자 경험을 제공할 수 있고 서버에 과부화가 걸리기 쉽다.
