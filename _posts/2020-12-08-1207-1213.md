---
title: "1207 - 1213"
tag: TIL
category: TIL
excerpt: ""
---

## 1207

### 첫 포스팅

상속 이전까지의 객체지향 내용과 규칙들을 정리해서 포스팅 하였다.  
첫 포스팅이라 그런지 마크다운 문법을 사용하는 것도 어색했고, 부족한 점이 많은 포스팅이었다.  
부족한 점을 발견하고 발전시켜 나가며 완성도를 높이려고 한다.  
늦게 시작한만큼 꾸준하게 학습하여 시간을 잘 활용해야 한다고 생각했다.  
매일쓰는 TIL과 주간, 월간 피드백을 통해 내가 가는 방향이 정말 맞는 방향인지 되돌아 보는 시간을 가지고자 한다.

## 1208

### 웹 프로그래밍 시험 공부

```javascript
<script>  //가장 기본적인 예시
    $(document).ready(function(){    //문서가 준비되면 콜백 함수 실행
        $('h1').css('color', 'red'); //h1의 색깔을 빨간색으로 변경
    });
</script>
```

- jQuery의 기본 문법을 익히고 동작 원리를 깨달았다.
- $기호 뒤에 선택자를 넣고, .기호로 연결하여 html이나 css를 조작하고 이벤트를 연결하는 구조였다.
- 자바에서 참조변수를 통해 메서드를 작동시키는 것과 비슷한 느낌을 받았다.
- 단순히 암기 하는 것이 아니라 이해를 하고 문법을 보니 응용 예제도 쉽게 다가왔다.

## 1209

### 자바 상속

- **조상 클래스** : 상속해주는 클래스
- **자손 클래스** : 상속 받는 클래스
  - 자손 클래스는 조상 클래스의 모든 멤버를 상속받는다.
  - **코드의 재사용성을 높이고 중복을 제거하여 프로그램 생산성과 유지보수에 크게 기여**

## 1210

### 포함관계

- 상속이외에도 클래스를 재사용하는 또 다른 방법이 있는데, 그것은 클래스간에 '포함관계'를 맺어 주는 것
- **포함관계** : 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것

### 클래스간의 관계 결정하기

_포함관계? VS 상속관계?_

- **상속관계** : ' ~은 ~이다.(is-a) '
- **포함관계** : ' ~은 ~을 가지고 있다.(has-a) '
- ex) Car클래스와 SportsCar클래스는 'SportsCar는 Car이다.'와 같이 문장을 만드는 것이 더 옳기 때문에 Car을 조상으로 하는 상속관계를 맺어 주어야 한다.
- ex) Card클래스와 Deck클래스는 'Deck은 Card를 가지고 있다.'와 같이 문장을 만드는 것이 더 옳기 때문에 Deck클래스에 Card클래스를 포함시켜야 한다.
- 프로그램의 모든 클래스를 분석하여 가능한 많은 관계를 맺도록 노력해서 코드의 재사용성을 높여야 한다.

```java
class Circle {				//원을 표현하기 위한 클래스
	int x;				//원점 x 좌표
	int y;				//원점 y 좌표
	int r;				//반지름
}

class Point {				//좌표상의 한 점을 다루기 위한 클래스
	int x;
	int y;
}
// Circle은 Point를 가지고 있다. -> 포함 관계

class Circle {
	Point c = new Point();
	int r;
}
```

## 1211

### 단일 상속

- C++에서는 여러 조상 클래스로부터 상속받는 '다중상속'을 허용하지만, 자바에서는 오직 단일 상속만을 허용한다.  
  -> 클래스간의 관계가 매우 복잡해지고, 다른 클래스로부터 상속받은 멤버간의 이름이 같은 경우 구별할 수 있는 방법이 없기 때문
- 관계가 더 깊은 것을 상속관계로 두고, 나머지 클래스는 포함관계로 하여 다중상속과 비슷한 효과를 낼 수 있다.
  - 포함관계에 둔 클래스의 메서드와 일치하는 선언부를 가진 메서드를 선언하고 내용은 포함관계에 둔 클래스의 것을 호출하여 사용  
    -> 외부적으로는 클래스의 인스턴스를 사용하는 것처럼 보이지만 내부적으로는 포함관계에 둔 클래스의 인스턴스를 생성하여 사용하는 것

### Object클래스 - 모든 클래스의 조상

_Object클래스는 모든 클래스 상속계층도의 최상위에 있는 조상 클래스_

- 다른 클래스로부터 상속 받지 않는 모든 클래스들은 자동적으로 Object클래스로부터 상속받게 함으로써 이것을 가능하게 함
- 컴파일러가 자동적으로 'extends Object'를 추가하여 상속받도록 한다.
- 그동안 toString()이나 equals(Object o)와 같은 메서드를 따로 정의하지 않고도 사용할 수 있었던 이유는 이 메서드들이 Object클래스에 정의된 것들이기 때문

## 1212

### 오버라이딩

**정의**: 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것

```java
class Point {
	int x;
	int y;

	String getLocation() {
		return "x :" + x + "y :" + y;
	}
}

class Point3D extends Point {
	int z;

	String getLocation() {				//오버라이딩
		return "x :" + x + "y :" + y + "z :" + z;
	}
}
```

- Point클래스를 사용하던 사람들은 새로 작성된 Point3D클래스가 getLocation()을 호출하면 Point클래스의 getLocation()이 그랬듯이 점의 좌표를 문자열로 얻을 수 있을 것이라고 기대할 것이다.
- 그렇기 때문에 새로운 메서드를 제공하는 것보다 오버라이딩을 하는 것이 바른 선택이다.

### 오버라이딩의 조건

- 자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와
  1.  이름이 같아야 한다.
  2.  매개 변수가 같아야 한다.
  3.  반환타입이 같아야 한다.
- 조상 클래스의 메서드를 자손 클래스에서 오버라이딩 할 때
  1.  접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
  2.  예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.
  3.  인스턴스메서드를 static메서드로 또는 그 반대로 변경할 수 없다

## 1213

### super

_자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수_  
`ex) super.x`

- 멤버변수와 지역변수의 이름이 같을 때 this를 붙여서 구별했듯이 상속받은 멤버와 자신의 멤버 이름이 같을 때는 super을 붙여서 구별
- 모든 인스턴스메서드에는 자신이 속한 인스턴스의 주소가 지역변수로 저장되는데, 이것이 참조변수인 this와 super값이 된다.  
  -> this와 마찬가지로 super 역시 static메서드에서는 사용할 수 없고, 인스턴스메서드에서만 사용 가능

### super() - 조상 클래스의 생성자

_조상 클래스의 생성자를 호출하는데 사용하는 생성자_

- 조상 클래스 멤버의 초기화 작업이 수행되어야 하기 때문에 자손 클래스의 생성자에서 조상 클래스의 생성자가 호출되어야 한다.
- 생성자의 첫 줄에서 조상클래스의 생성자를 호출해야하는 이유
  - 자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수도 있으므로 조상의 멤버들이 먼저 초기화 되어 있어야 하기 때문
- **Object클래스를 제외한 모든 클래스의 생성자 첫 줄에 생성자, this() 또는 super()를 호출해야 한다. 그렇지 않으면 컴파일러가 자동적으로 'super();'를 생성자의 첫 줄에 삽입한다**
