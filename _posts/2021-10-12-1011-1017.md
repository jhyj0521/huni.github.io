---
title: "1011-1017"
tag: TIL
category: TIL
---

## 1011

# 49장 Babel과 Webpack을 이용한 ES6+/ES.NEXT 개발 환경 구축

- ES6+와 ES.NEXT 사양을 사용하여 프로젝트를 진행하려면 최신 사양으로 작성된 코드를 경우에 따라 IE를 포함한 구형 브라우저에서 문제 없이 동작시키기 위한 개발 환경을 구축하는 것이 필요하다.
- 또한 대부분 대부분의 프로젝트가 모듈을 사용하므로 모듈 로더도 필요하다.
- ESM은 대부분의 모던 브라우저에서 사용할 수 있지만 다음과 같은 이유로 아직까지 ESM보다는 별도의 모듈 로더를 사용하는 것이 일반적이다.
  - IE를 포함한 구형 브라우저는 ESM을 지원하지 않는다.
  - ESM을 사용하더라도 트랜스파일링이나 번들링이 필요한 것은 변함이 없다.
  - ESM이 아직 지원하지 않는 기능(bare import 등)이 있고 아직 몇 가지 이슈가 존재한다.

## Babel

Babel은 ES6+/ES.NEXT로 구현된 최신 사양의 소스코드를 IE 같은 구형 브라우저에서도 동작하는 ES5 사양의 소스코드로 변환(트랜스파일링)할 수 있다.

### Babel 설치

```shell
# 프로젝트 폴더 생성
$ mkdir esnext-project && cd esnext-project

# package.json 생성
$ npm init -y

# babel-core, babel-cli 설치
$ npm install --save-dev @babel/core @babel/cli
```

### Babel 프리셋 설치와 babel.config.json 설정 파일 작성

- Babel을 사용하려면 @babel/preset-env를 설치해야 한다. 이는 함께 사용되어야 하는 Babel 플러그인을 모아 둔 것으로 Babel 프리셋이라고 부른다.
- @babel/preset-env는 필요한 플러그인들을 프로젝트 지원 환경에 맞춰 동적으로 결정해 준다.

```shell
# @babel/preset-env 설치
$ npm install --save-dev @babel/preset-env
```

- 프로젝트 루트 폴드에 babel.config.json 설정 파일을 생성하고 다음과 같이 작성한다. 설치한 프리셋을 사용하겠다는 의미다.

```json
{
  "presets": ["@babel/preset-env"]
}
```

### 트랜스파일링

npm scripts에 Babel CLI 명령어를 등록한다.

```json
{
  "scripts": {
    "build": "babel src/js -w -d dist/js"
  }
}
```

- src/js 폴더에 있는 모든 JS 파일들을 트랜스파일링한 후, 그 결과물을 dist/js 폴더에 저장한다.
- -w 옵션은 타깃 폴더에서 일어나는 변경을 감지하여 자동으로 트랜스파일한다.
- -d 옵션은 트랜스파일링 결과물이 저장될 폴더를 지정한다.
- @babel/preset-env는 현재 제안 단계에 있는 사양에 대한 플러그인을 지원하지 않기 때문에 이를 트랜스파일링하려면 별도의 플러그인을 설치해야 한다.

### Babel 플러그인 설치

- 설치가 필요한 Babel 플러그인은 Babel 홈페이지에서 검색할 수 있다.
- 검색하여 플러그인을 설치하고 babel.config.json 설정 파일에 추가하면 된다.

```shell
npm install --save-dev @babel/plugin-proposal-class-properties
```

```json
{
  "presets": ["@babel/preset-env"],
  "plugins": ["@babel/plugin-proposal-class-properties"]
}
```

### 브라우저에서 모듈 로딩 테스트

Babel만 사용하게 되면 Node.js가 기본 지원하는 Common.js 방식의 모듈 로딩 시스템에 따라 트랜스파일링된다.  
이를 브라우저에서 실행하면 에러가 발생한다.  
 이를 해결하기 위해서 Webpack을 사용해야 한다.

## Webpack

- Webpack은 의존 관계에 있는 JS, CSS, 이미지 등의 리소스들을 하나의 파일로 번들링하는 모듈 번들러다.
- 이를 사용하면 의존 모듈이 하나의 파일로 번들링되므로 별도의 모듈 로더가 필요없다.
- 여러 개의 JS 파일을 하나로 번들링하므로 HTML 파일에서 script 태그 여러 개의 JS 파일을 로드해야 하는 번거로움도 사라진다.
- Webpack과 Babel을 이용하여 개발 환경을 구축하려면, Webpack이 파일을 번들링하기 전에 Babel을 로드하여 트랜스파일링하는 작업을 실행하도록 설정해야 한다.

### Webpack 설치

```shell
npm install --save-dev webpack webpack-cli
```

### babel-loader 설치

Webpack이 모듈을 번들링할 때 Babel을 사용하여 트랜스파일링하도록 babel-loader를 설치한다.

```shell
npm install --save-dev babel-loader
```

- npm scripts를 변경하여 Babel 대신 Webpack을 실행하도록 수정하자.

```json
{
  "scripts": {
    "build": "webpack -w"
  }
}
```

### webpack.config.js 설정 파일 작성

- Webpack이 실행될 때 참조하는 설정 파일이다.

```javascript
const path = require("path");
module.exports = {
  // entry file
  entry: "./src/js/app.js",
  // 번들링된 js 파일의 이름(filename)과 저장될 경로(path)를 지정
  output: {
    path: path.resolve(__dirname, "dist/js"),
    filename: "bundle.js",
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        include: [path.resolve(__dirname, "src/js")],
        exclude: /node_modules/,
        use: {
          loader: "babel-loader",
          options: {
            presets: ["@babel/preset-env"],
            plugins: ["@babel/plugin-proposal-class-properties"],
          },
        },
      },
    ],
  },
  devtool: "source-map",
  mode: "development",
};
```

### babel-polyfill 설치

- Babel을 사용해서 트랜스파일링해도 브라우저가 지원하지 않는 코드가 남아 있을 수 있다.
  - ex) Promise, Object.assign, Array.from 등은 대체할 기능이 없기 때문에 트랜스파일링되지 못한다.
- 구형 브라우저에서 위와 같은 객체나 메서드를 사용하기 위해서는 @babel/polyfill을 설치해야 한다.

```shell
npm install @babel/polyfill
```

- 개발 환경에서만 사용하는 것이 아니라 실제 운영 환경에서도 사용해야 하기 때문에 --save-dev 옵션을 지정하지 않는다.
- ES6의 import를 사용하는 경우에는 진입점의 선두에서 먼저 폴리필을 로드한다.

```javascript
import "@babel/polyfill";
```

- Webpack을 사용하는 경우에는 위 방법 대신 webpack.config.js 파일의 entry 배열에 폴리필을 추가한다.

```javascript
const path = require('path');
module.exports = {
  // entry file
  entry: ['@babel/polyfill', './src/js/main.js'],
...
```

### 출처

모던 자바스크립트 Deep Dive

## 1012

## 프로그래머스 카카오 Level2 - 파일명 정렬

```javascript
function solution(files) {
  const arr = [];
  for (const x of files) {
    const [, head, num] = x.match(/([a-zA-z-. ]+)([0-9]{1,5})/);
    arr.push([x, head, num]);
  }

  arr.sort((a, b) =>
    a[1].toLowerCase() > b[1].toLowerCase()
      ? 1
      : b[1].toLowerCase() > a[1].toLowerCase()
      ? -1
      : +a[2] > +b[2]
      ? 1
      : +b[2] > +a[2]
      ? -1
      : 0
  );
  return arr.map((v) => v[0]);
}
```

- 이번에 공부한 정규 표현식을 사용하여 받은 데이터를 파싱하였다.
  - 영어 대소문자와 . - ' ' 를 계속 그룹화하고, 숫자를 만나면 최대 5개까지 그룹화하였다.
  - 여기서 띄워쓰기를 어떻게 표현하는지 제대로 몰라서 문제를 틀렸었다.
- 정렬은 항상 할때마다 헷갈린다.
  - 반환값이 1보다 크면 바꾸고, -1 이하이면 안바꾼다.
