---
title: "0208-0214"
tag: TIL
category: TIL
---
## 0208
# Vue.js


*Vue는 무엇인가?*  
* 웹 페이지 화면을 개발하기 위한 프런트엔드 프레임워크

### 뷰의 장점
1. 배우기 쉽다.
2. 리액트와 앵귤러에 비해 성능이 우수하고 빠르다.
3. 앵귤러의 데이터 바인딩 특성과 리액트의 가상 돔 기반 렌더링 특징을 모두 가지고 있다.

## 뷰의 특징
### UI 화면단 라이브러리
* 뷰는 UI 화면 개발 방법 중 하나인 MVVM 패턴의 뷰 모델에 해당하는 화면단 라이브러리
* 화면의 요소들을 제어하는 코드와 데이터 제어 로직을 분리하여 코드를 더 직관적으로 이해할 수 있고, 유지 보수가 편해짐
* **MVVM**: 모델 - 뷰 - 뷰 모델로 구조화한 개발 방식
* **view**: 사용자에게 보이는 화면
* **model**: 데이터를 담는 용기. 보통 서버에서 가져온 데이터를 js 객체 형태로 저장
* **데이터 바인딩**: 뷰에 표시되는 내용과 모델의 데이터를 동기화
* **돔 리스너**: 돔의 변경 내역에 대해 즉각적으로 반응하여 특정 로직을 수행하는 장치
* **뷰 모델**: 뷰와 모델의 중간 영역으로 돔 리스너와 데이터 바인딩을 제공하는 영역  
-> 이처럼 뷰는 화면의 요소가 변경되거나 조작이 일어날 때 즉각적으로 반응하여 화면 데이터를 갱신하여 보여주는 역할을 한다.

### 컴포넌트 기반 프레임워크
* 뷰의 컴포넌트를 조합하여 화면을 구성할 수 있다.
* 컴포넌트 방식으로 개발하는 이유는 코드를 재사용하기가 쉽기 때문

### 리액트와 앵귤러의 장점을 가진 프레임워크
* 뷰는 앵귤러의 양방향 데이터 바인딩과 리액트의 단방향 데이터 흐름의 장점을 모두 결합한 프레임워크이다.
* **양방향 데이터 바인딩**: 화면에 표시되는 값과 프레임워크의 모델 데이터 값이 동기화되어 한쪽이 변경되면 다른 한쪽도 자동으로 변경되는 것
* **단방향 데이터 흐름**: 컴포넌트의 단방향 통신. 컴포넌트 간에 데이터를 전달할 때 항상 상위 컴포넌트에서 하위 컴포넌트 한 방향으로만 전달하게끔 프레임워크가 구조화
* **가상 돔 렌더링 방식**: 특정 돔 요소를 추가하거나 삭제하는 변경이 일어날 때 화면 전체를 다시 그리지 않고 프레임워크에서 정의한 방식에 따라 화면을 갱신.

## 0209
## 0208
*프로젝트 진행 중에 게시물을 페이징 해야해서 그와 관련된 내용들을 컴포넌트로 구분하여 개발하였다.*
```vue
<template>
  <div class="pagination">
        <button type="button" class="btn_first" title="첫 페이지로 이동" v-if="first" @click="changeLink(1)"><span>처음</span></button>
        <button type="button" class="btn_prev" title="이전 5개 목록 페이지로 이동" v-if="prev" @click="changeLink(startPageIndex - 1)"><span>이전</span></button>

        <ul class="paging">
            <li v-for="index in endPageIndex-startPageIndex + 1" :key="index">
                <button type="button" :class="{on: (startPageIndex + index - 1) == currentPage}" title="현재페이지로 이동" @click="changePage(index)">{{ startPageIndex + index - 1 }}</button>
            </li>
        </ul>

        <button type="button" class="btn_next" title="다음 5개 목록 페이지로 이동" v-if="next" @click="changeLink(endPageIndex + 1)"><span>다음</span></button>
        <button type="button" class="btn_end" title="마지막 페이지로 이동" v-if="end" @click="changeLink(pageCount)"><span>끝</span></button>
    </div>            
</template>

<script>
export default {
    props: ['listRowCount', 'totalListItemCount', 'pageLinkCount', 'currentPage'],    //listRowCount: 한 페이지당 리스트 개수, totalListItemCount: 총 리스트 개수, pageLinkCount: 링크당 페이지 개수
    data() {
        return {
            pageCount: 0,       //페이지 개수
            startPageIndex: 0,  //링크에서 페이지 시작 인덱스
            endPageIndex: 0,    //링크에서 페이지 마지막 인덱스
            prev: false,
            next: false,
            first: false,
            end: false
        }
    },
    methods: {
        initUI() {
            this.pageCount= Math.ceil(this.totalListItemCount/this.listRowCount);

            if((this.currentPage % this.pageLinkCount) == 0) {
                this.startPageIndex = ((this.currentPage / this.pageLinkCount) -1) * this.pageLinkCount + 1;
            } else {
                this.startPageIndex = Math.floor(this.currentPage / this.pageLinkCount) * this.pageLinkCount + 1;
            }

            if((this.currentPage % this.pageLinkCount == 0)) {
                this.endPageIndex = ((this.currentPage / this.pageLinkCount)-1)* this.pageLinkCount + this.pageLinkCount;
            } else {
                this.endPageIndex = Math.floor(this.currentPage / this.pageLinkCount)* this.pageLinkCount + this.pageLinkCount;
            }

            if(this.currentPage <= this.pageLinkCount) {
                this.prev = false;
                this.first = false;
            } else {
                this.prev = true;
                this.first = true;
            }

            if(this.endPageIndex >= this.pageCount) {
                this.endPageIndex = this.pageCount;
                this.next = false;
                this.end = false;
            } else {
                this.next = true;
                this.end = true;
            }

            console.log(`startPageIndex: ${this.startPageIndex}`);
            console.log(`endPageIndex: ${this.endPageIndex}`);
            console.log(`pageCount: ${this.pageCount}`);
        },
        changePage(index) {
            let selectedPage = this.startPageIndex + index - 1;
            this.$emit('update', selectedPage);
        },
        changeLink(index) {
            this.$emit('update', index);
        }
    },
    watch: {
        currentPage: function() {
            this.initUI();
        },
        totalListItemCount: function () {
            this.initUI();
        },
        listRowCount: function () {
            this.initUI();
        },
        pageLinkCount: function () {
            this.initUI();
        }
    },
    created() {
        this.initUI();
    }
}
</script>
```
* props로 현재 페이지, 링크 당 페이지, 총 아이템 개수, 페이지당 아이템 개수를 받아서 여러 상황에서 재사용 할 수 있도록 작성하였다.
* props 데이터가 변경할 때마다 initUI()를 실행시켜서 페이지 관련 변수들을 초기화 시켰다.
* 상위 컴포넌트에 현재 페이지를 전달하여 메서드를 실행시켜 페이지에 해당하는 목록을 반환하였다.