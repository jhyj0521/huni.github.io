---
title: "0208-0214"
tag: TIL
category: TIL
---
## 0208
# Vue.js


*Vue는 무엇인가?*  
* 웹 페이지 화면을 개발하기 위한 프런트엔드 프레임워크

### 뷰의 장점
1. 배우기 쉽다.
2. 리액트와 앵귤러에 비해 성능이 우수하고 빠르다.
3. 앵귤러의 데이터 바인딩 특성과 리액트의 가상 돔 기반 렌더링 특징을 모두 가지고 있다.

## 뷰의 특징
### UI 화면단 라이브러리
* 뷰는 UI 화면 개발 방법 중 하나인 MVVM 패턴의 뷰 모델에 해당하는 화면단 라이브러리
* 화면의 요소들을 제어하는 코드와 데이터 제어 로직을 분리하여 코드를 더 직관적으로 이해할 수 있고, 유지 보수가 편해짐
* **MVVM**: 모델 - 뷰 - 뷰 모델로 구조화한 개발 방식
* **view**: 사용자에게 보이는 화면
* **model**: 데이터를 담는 용기. 보통 서버에서 가져온 데이터를 js 객체 형태로 저장
* **데이터 바인딩**: 뷰에 표시되는 내용과 모델의 데이터를 동기화
* **돔 리스너**: 돔의 변경 내역에 대해 즉각적으로 반응하여 특정 로직을 수행하는 장치
* **뷰 모델**: 뷰와 모델의 중간 영역으로 돔 리스너와 데이터 바인딩을 제공하는 영역  
-> 이처럼 뷰는 화면의 요소가 변경되거나 조작이 일어날 때 즉각적으로 반응하여 화면 데이터를 갱신하여 보여주는 역할을 한다.

### 컴포넌트 기반 프레임워크
* 뷰의 컴포넌트를 조합하여 화면을 구성할 수 있다.
* 컴포넌트 방식으로 개발하는 이유는 코드를 재사용하기가 쉽기 때문

### 리액트와 앵귤러의 장점을 가진 프레임워크
* 뷰는 앵귤러의 양방향 데이터 바인딩과 리액트의 단방향 데이터 흐름의 장점을 모두 결합한 프레임워크이다.
* **양방향 데이터 바인딩**: 화면에 표시되는 값과 프레임워크의 모델 데이터 값이 동기화되어 한쪽이 변경되면 다른 한쪽도 자동으로 변경되는 것
* **단방향 데이터 흐름**: 컴포넌트의 단방향 통신. 컴포넌트 간에 데이터를 전달할 때 항상 상위 컴포넌트에서 하위 컴포넌트 한 방향으로만 전달하게끔 프레임워크가 구조화
* **가상 돔 렌더링 방식**: 특정 돔 요소를 추가하거나 삭제하는 변경이 일어날 때 화면 전체를 다시 그리지 않고 프레임워크에서 정의한 방식에 따라 화면을 갱신.

## 0209
## 0208
*프로젝트 진행 중에 게시물을 페이징 해야해서 그와 관련된 내용들을 컴포넌트로 구분하여 개발하였다.*
```vue
<template>
  <div class="pagination">
        <button type="button" class="btn_first" title="첫 페이지로 이동" v-if="first" @click="changeLink(1)"><span>처음</span></button>
        <button type="button" class="btn_prev" title="이전 5개 목록 페이지로 이동" v-if="prev" @click="changeLink(startPageIndex - 1)"><span>이전</span></button>

        <ul class="paging">
            <li v-for="index in endPageIndex-startPageIndex + 1" :key="index">
                <button type="button" :class="{on: (startPageIndex + index - 1) == currentPage}" title="현재페이지로 이동" @click="changePage(index)">{{ startPageIndex + index - 1 }}</button>
            </li>
        </ul>

        <button type="button" class="btn_next" title="다음 5개 목록 페이지로 이동" v-if="next" @click="changeLink(endPageIndex + 1)"><span>다음</span></button>
        <button type="button" class="btn_end" title="마지막 페이지로 이동" v-if="end" @click="changeLink(pageCount)"><span>끝</span></button>
    </div>            
</template>

<script>
export default {
    props: ['listRowCount', 'totalListItemCount', 'pageLinkCount', 'currentPage'],    //listRowCount: 한 페이지당 리스트 개수, totalListItemCount: 총 리스트 개수, pageLinkCount: 링크당 페이지 개수
    data() {
        return {
            pageCount: 0,       //페이지 개수
            startPageIndex: 0,  //링크에서 페이지 시작 인덱스
            endPageIndex: 0,    //링크에서 페이지 마지막 인덱스
            prev: false,
            next: false,
            first: false,
            end: false
        }
    },
    methods: {
        initUI() {
            this.pageCount= Math.ceil(this.totalListItemCount/this.listRowCount);

            if((this.currentPage % this.pageLinkCount) == 0) {
                this.startPageIndex = ((this.currentPage / this.pageLinkCount) -1) * this.pageLinkCount + 1;
            } else {
                this.startPageIndex = Math.floor(this.currentPage / this.pageLinkCount) * this.pageLinkCount + 1;
            }

            if((this.currentPage % this.pageLinkCount == 0)) {
                this.endPageIndex = ((this.currentPage / this.pageLinkCount)-1)* this.pageLinkCount + this.pageLinkCount;
            } else {
                this.endPageIndex = Math.floor(this.currentPage / this.pageLinkCount)* this.pageLinkCount + this.pageLinkCount;
            }

            if(this.currentPage <= this.pageLinkCount) {
                this.prev = false;
                this.first = false;
            } else {
                this.prev = true;
                this.first = true;
            }

            if(this.endPageIndex >= this.pageCount) {
                this.endPageIndex = this.pageCount;
                this.next = false;
                this.end = false;
            } else {
                this.next = true;
                this.end = true;
            }

            console.log(`startPageIndex: ${this.startPageIndex}`);
            console.log(`endPageIndex: ${this.endPageIndex}`);
            console.log(`pageCount: ${this.pageCount}`);
        },
        changePage(index) {
            let selectedPage = this.startPageIndex + index - 1;
            this.$emit('update', selectedPage);
        },
        changeLink(index) {
            this.$emit('update', index);
        }
    },
    watch: {
        currentPage: function() {
            this.initUI();
        },
        totalListItemCount: function () {
            this.initUI();
        },
        listRowCount: function () {
            this.initUI();
        },
        pageLinkCount: function () {
            this.initUI();
        }
    },
    created() {
        this.initUI();
    }
}
</script>
```
* props로 현재 페이지, 링크 당 페이지, 총 아이템 개수, 페이지당 아이템 개수를 받아서 여러 상황에서 재사용 할 수 있도록 작성하였다.
* props 데이터가 변경할 때마다 initUI()를 실행시켜서 페이지 관련 변수들을 초기화 시켰다.
* 상위 컴포넌트에 현재 페이지를 전달하여 메서드를 실행시켜 페이지에 해당하는 목록을 반환하였다.

## 0210
## 관심사의 분리
* 구현체는 본인의 역할을 수행하는 것에만 집중해야 한다.
* 구현체는 역할을 수행하는 데 있어서 필요한 다른 역할에 있어서 어떤 구현체가 선택되더라도 똑같이 역할을 수행 할 수 있어야 한다.
* 역할에 맞는 구현체를 지정하는 책임을 담당하는 별도의 기획자가 나올시점이다.  
-> 기획자를 만들고, 구현체와 역할에 맞는 구현체를 지정해주는 책임을 확실히 분리하자.

### AppConfig 등장
* 애플리케이션의 전체 동작 방식을 구성하기 위해, 구현 객체를 생성하고 연결하는 책임을 가지는 별도의 설정 클래스
* 애플리케이션 실제 동작에 필요한 구현 객체를 생성하고, 생성한 객체 인스턴스의 참조를 생성자를 통해서 주입해준다.

```java
public class AppConfig {		//AppConfig
    public MemberService memberService() {
        return new MemberServiceImpl(new MemoryMemberRepository());
    }

    public OrderService orderService() {
        return new OrderServiceImpl(new MemoryMemberRepository(), new FixDiscountPolicy());
    }
}

public class MemberServiceImpl implements MemberService {
    private final MemberRepository memberRepository;	// 생성자로 의존성 주입

    public MemberServiceImpl(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }
}

// AppConfig를 실행할 때
AppConfig appConfig = new AppConfig();	
MemberService memberService = appConfig.memberService();

// Test코드에서 AppConfig를 실행할 때
MemberService memberService;

@BeforeEach	// 테스트 한 개를 돌릴 때마다 실행
public void beforeEach() {
    AppConfig appConfig = new AppConfig();
    memberService = appConfig.memberService();
}
``` 
* MemberServiceImpl은 이제 더이상 구현 객체에 의존하지 않고 MemberRepository 인터페이스에만 의존한다.
* 생성자를 통해서 어떤 구현 객체를 주입할지는 오직 외부(AppConfig)에서 결정된다.
* 의존관계에 대한 고민은 외부에 맡기고 실행에만 집중하면 된다.  
-> DIP 완성

### AppConfig 리팩터링
* AppConfig에서 중복되는 코드를 지우고, 역할에 따른 구현이 보이도록 해 준다.

```java
public class AppConfig {
    public MemberService memberService() {
        return new MemberServiceImpl(memberRepository());
    }


    public OrderService orderService() {
        return new OrderServiceImpl(memberRepository(), new FixDiscountPolicy());
    }

    private MemberRepository memberRepository() {
        return new MemoryMemberRepository();
    }

    private DiscountPolicy discountPolicy() {
        return new FixDiscountPolicy();
    }
}
```
* new MemoryMemberRepository() 부분이 중복 제거되었다. 이제 MemoryMemberRepository를 다른 구현체로 변경할 때 한 부분만 변경하면 된다.
* AppConfig를 보면 역할과 구현 클래스가 한눈에 들어온다. 애플리케이션 전체 구성이 어떻게 되어있는지 빠르게 파악할 수 있다.
* 새로운 할인 정책을 적용하더라도 AppConfig에서 discountPolicy()만 수정하면 된다.  
-> 애플리케이션이 크게 사용 영역과, 객체를 생성하고 구성하는 영역으로 분리되었다. 사용 영역의 코드를 변경할 필요가 없어짐

## IoC, DI, 컨테이너
### 제어의 역전 IoC(Inversion of Control)
* 기존 프로그램은 구현 객체가 스스로 필요한 서버 구현 객체를 생성하고, 연결하고, 실행했다. 
* AppConfig가 등장한 이후에 구현 객체는 자신의 로직을 실행하는 역할만 담당하고, 프로그램의 제어 흐름은 AppConfig가 가져간다.
* 이처럼 프로그램 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 제어의 역전이라 한다.

### 프레임워크 vs 라이브러리
**프레임워크**: 내가 작성한 코드를 제어하고, 대신 실행하면 그것은 프레임워크 (JUnit)  
**라이브러리**: 내가 작성한 코드가 직접 제어의 흐름을 담당한다면 그것은 프레임워크가 아니라 라이브러리

### 의존관계 주입 DI(Dependency Injection)
* 의존관계는 정적인 클래스 의존관계와, 실행 시점에 결정되는 동적인 객체 의존 관계 둘을 분리해서 생각해야 한다.

#### 정적인 클래스 의존관계
* 클래스가 사용하는 import 코드만 보고 의존관계를 쉽게 판단할 수 있다. 정적인 의존관계는 애플리케이션을 실행하지 않아도 분석할 수 있다.
* 클래스 다이어그램을 보고 확인 가능

#### 동적인 객체 인스턴스 의존관계
* 애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계
* 애플리케이션 런타임에 외부에서 실제 구현 객체를 생성하고 클라이언트에 참조값을 전달해서 클라이언트와 서버의 실제 의존관계가 연결 되는 것을 **의존관계 주입**이라고 한다.
* 의존관계 주입을 사용하면 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.

### IoC 컨테이너, DI 컨테이너
* AppConfig처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 IoC 컨테이너 또는 DI 컨테이너라고 한다.
* 의존관계 주입에 초점을 맞추어 최근에는 주로 DI 컨테이너라고 한다.

## 스프링으로 전환하기
*지금까지는 순수한 자바 코드만으로 DI를 적용했다. 이제는 스프링을 사용해서 바꾸어보자*
```java
@Configuration
public class AppConfig {

    @Bean
    public MemberService memberService() {
        return new MemberServiceImpl(memberRepository());
    }

    @Bean
    public OrderService orderService() {
        return new OrderServiceImpl(memberRepository(), new FixDiscountPolicy());
    }

    @Bean
    public MemberRepository memberRepository() {
        return new MemoryMemberRepository();
    }

    @Bean
    public DiscountPolicy discountPolicy() {
        return new FixDiscountPolicy();
    }
}
```
* AppConfig에 설정을 구성한다는 뜻의 @Configuration을 붙여준다.
* 각 메서드에 @Bean을 붙여주면 스프링 컨테이너에 스프링 빈으로 등록한다.

### 스프링 컨테이너 적용
```java
// AppConfig appConfig = new AppConfig(); 기존 코드
// MemberService memberService = appConfig.memberService();

ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
MemberService memberService = applicationContext.getBean("memberService", MemberService.class);
```
* ApplicationContext를 스프링 컨테이너라 한다.
* 기존에는 개발자가 AppConfig를 사용해서 직접 객체를 생성하고 DI를 했지만, 이제부터는 스프링 컨테이너를 통해서 사용한다.
* 스프링 컨테이너는 @Configuration이 붙은 AppConfig를 설정 정보로 사용한다. 여기서 @Bean이라 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다. 이렇게 등록된 객체를 스프링 빈이라고 한다.
* 스프링 빈은 @Bean이 붙은 메서드의 명을 스프링 빈의 이름으로 사용한다.
* 이전에는 개발자가 필요한 객체를 AppConfig를 직접 조회했지만, 이제부터는 스프링 컨테이너를 통해서 스프링 빈을 찾아야 한다. 스프링 빈은 applicationContext.getBean()메서드를 사용해서 찾을 수 있다.