---
title: "0131 - 0206"
tag: TIL
category: TIL
excerpt: ""
---

## 0131

# 타입 추론 & 타입 단언

## 타입 추론

- 타입스크립트가 코드를 해석해 나가는 동작
- 변수 선언, 초기화, 인자의 기본값, 함수의 반환값 등을 설정할 때 타입을 따로 지정하지 않더라도 타입 추론이 일어난다.

### 인터페이스와 제네릭을 이용한 타입 추론

```typescript
interface Dropdown<T> {
  value: T;
  title: string;
}

const shoppingItem: Dropdown<string> = {
  value: 'abc',
  ...
}
```

- 제네릭으로 값을 넘겼을 때, 그 값을 추론해서 속성들의 타입을 보장해준다.

### 복잡한 구조에서의 타입 추론

```typescript
interface Dropdown<T> {
  value: T;
  title: string;
}

interface DetailedDropdown<K> extends Dropdown<K> {
  description: string;
  tag: K;
}
```

- 위와 같이 인터페이스를 확장할 때도 제네릭을 넘길 수 있는데, 이 경우 상위 인터페이스의 value 타입까지 추론할 수 있다.

### Best Common Type

타입은 보통 몇 개의 표현식을 바탕으로 가장 근접한 타입을 추론하는데 이 가장 근접한 타입을 Best Common Type이라고 한다.

```typescript
const arr = [0, "a", true];
```

- arr의 타입을 추론하기 위해서는 배열의 각 아이템을 살펴야 한다.
- 타입은 `number, string, boolean`으로 구분된다.
- 이 때 Best Common Type 알고리즘으로 다른 타입들과 가장 잘 호환되는 타입을 선정한다.

### 문맥상의 타이핑

타입 스크립트에서 타입을 추론하는 또 하나의 방식은 문맥상으로 타입을 결정하는 것이다.  
이 문맥상의 타이핑은 코드의 위치를 기준으로 일어난다.

```typescript
window.onscroll = function (uiEvent) {
  console.log(uiEvent.button); // <- Error!
};

const handler = function (uiEvent) {
  console.log(uiEvent.button); //<- OK
};
```

- `window.onscroll`에 할당되었기 때문에 타입스크립트 검사기는 `window.onscroll` 타입을 검사하고, 함수의 타입이 UI 이벤트와 연관이 있다고 추론하기 때문에 함수의 인자는 UIEvent로 간주된다.
- 그러므로 uiEvent.button 속성이 없다고 추론하기에 에러가 발생한다.
- 하지만 handler라는 임의의 변수에 할당하는 경우 타입을 추정하기 어렵기 때문에 아무 에러가 발생하지 않는다.

### Typescript Language Server

자동 완성과 같은 인텔리센스가 일어나기 위해서는 타입스크립트 랭귀지 서버가 돌아야 한다.  
vscode에는 타입스크립트를 지원하는 랭귀지 서버가 내부적으로 탑재되어 있다.  
이를 통해 타입 추론이 발생한다.

> 타입 체킹에 있어서 타입스크립트의 지향점은 타입 체크는 **값의 형태**에 기반하여 이루어져야 한다는 점이다!!

## 타입 단언

타입스크립트가 타입을 원하는대로 추론하지 못하고, 개발자가 더 명확하게 타입을 지정해야 하는 경우 사용하는 것이 타입 단언이다.

```typescript
let a;
a = "a";
let b = a as string;
```

- 위와 같이 선언과 초기화를 분리하면 타입스크립트는 변수 a의 타입을 any로 추론하게 된다.
- 하지만 개발자는 a에 문자열을 할당한 것을 명확하게 알고 있기에 `as` 키워드와 함께 a의 타입을 지정할 수 있다.

### 활용

타입 단언은 주로 **DOM API를 조작**할 때 사용된다.

```typescript
const div = document.querySelector("div") as HTMLDivElement;
if (div) {
  div.innerText;
}
```

- 예를 들어 위와 같이 html 문서에서 요소를 찾고 사용하는 경우 결과로 null이 나올 수도 있기 때문에 if 문으로 null 체크를 해줘야 한다.
- 하지만 위와 같이 이 값이 HTMLDivElement 타입이라고 단언해주면 if 문 없이 작성이 가능하다.

# 타입 가드 & 타입 호환

## 타입 가드

```typescript
interface Developer {
  name: string;
  skill: string;
}

interface Person {
  name: string;
  age: number;
}

function introduce(): Developer | Person {
  return { name: "Tony", age: 33, skill: "Iron Making" };
}

const tony = introduce();
```

- 위와 같이 코드를 작성하면 유니온 타입 특성 상 skill과 age 속성에는 접근할 수 없다.
- 이 때 타입 단언만을 사용해서 문제를 해결하려고 하면 가독성이 많이 떨어진다.
- 타입 가드라는 기술을 사용해서 위의 문제를 해결할 수 있다.

### 사용자 정의 타입가드

```typescript
function isDeveloper(target: Developer | Person): target is Developer {
  return (target as Developer).skill !== undefined;
}

if (isDeveloper(tony)) {
  tony.skill;
} else {
  tony.age;
}
```

- 타입 가드는 주로 is로 시작하는 명으로 boolean 값을 반환하는 형식으로 작성한다.
- 반환값으로는 is 키워드를 사용하여 인자가 지정한 인터페이스와 같은 지 반환한다.
- isDeveloper의 결과를 만족하면 타입이 Developer로 지정되어 Developer가 포함한 속성을 사용 가능하다.
- 자주 사용하는 패턴이니 알아두자!

## 타입 호환

타입 호환이란 코드에서 특정 타입이 다른 타입에 잘 맞는지를 의미한다.

```typescript
interface Ironman {
  name: string;
}

class Avengers {
  name: string;
}

let i: Ironman;
i = new Avengers(); // OK, because of structural typing
```

위와 같이 코드를 작성할 경우 정상적으로 동작한다.  
그 이유는 자바스크립트는 명시적으로 타입을 지정하는 것보다 코드의 구조 관점에서 타입을 지정하는 것이 더 잘 어울리기 때문이다.

### 구조적 타이핑

코드 구조 관점에서 타입이 서로 호환되는지의 여부를 판단하는 것

```typescript
interface Developer {
  name: string;
  skill: string;
}
interface Person {
  name: string;
}

let developer: Developer;
let person: Person;

person = developer;
developer = person; // Error - 'skill' 속성이 'Person' 형식에 없지만 'Developer' 형식에서 필수입니다.
```

- person에 developer을 할당했을 때는 person의 경우 name만 선언하면 되기에 문제가 없지만, 반대의 경우에는 developer의 경우 skill 속성을 꼭 선언해야 하기 때문에 문제가 발생한다.

```typescript
let add = function (a: number) {
  // ...
};

let sum = function (a: number, b: number) {
  // ...
};

sum = add;
add = sum; // Error
```

- add에 sum을 할당하는 경우에는 할당하는 함수가 할당받는 함수보다 범위가 더 크기 때문에 에러가 발생한다.

```typescript
interface Empty<T> {}
let empty1: Empty<string>;
let empty2: Empty<number>;
empty1 = empty2;
empty2 = empty1;

interface NotEmpty<T> {
  data: T;
}
let notempty1: NotEmpty<string>;
let notempty2: NotEmpty<number>;
notempty1 = notempty2; // Error
notempty2 = notempty1; // Error
```

- Empty 인터페이스의 경우 제네릭을 선언만 하고 사용하지 않았기 때문에 에러가 발생하지 않지만, NotEmpty 인터페이스의 경우 제네릭을 사용하여 타입이 일치하지 않아 문제가 발생한다.
- 즉, 제네릭은 제네릭 타입 간 호환 여부를 판단할 때 타입 인자가 속성에 할당 되었는지를 기준으로 한다.

> **reference**  
> [타입스크립트 공식 문서](https://www.typescriptlang.org/ko/)  
> [타입스크립트 핸드북](https://joshua1988.github.io/ts/)  
> [타입스크립트 입문 - 기초부터 실전까지](https://www.inflearn.com/course/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%9E%85%EB%AC%B8/dashboard)
