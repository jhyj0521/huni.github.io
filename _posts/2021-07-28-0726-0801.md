---
title: "0726-0801"
tag: TIL
category: TIL
---
## 0726
# 11일 차 자료구조 / 알고리즘 정리




오늘부터 새로운 국면으로 들어섰다.  
이제는 실제로 학원을 통학하여 자료구조 알고리즘을 듣기 시작했고, 처음으로 사람들도 만났다.
통학을 하는 건 장단점이 있는데, 왔다갔다 하는 데 시간과 체력이 많이 소요되고, 점심 저녁을 밖에서 해결해야 한다는 점이 골치거리다.
하지만 그만큼 수업을 듣는 데에 있어서 집중이 되었고, 자체적으로 쉬는 시간을 갖는 시간이 많이 줄어들었다.
처음 수업을 듣고 느낀 점은 정말 진도가 빠르고, 한 번이라도 집중력을 잃거나 복습 예습을 꼼꼼히 하지 않으면 그대로 뒤쳐지겠다는 것이었다.   
하지만 또 다른 점으로는 생각보다 내가 공부한 거에 비해 (비록 쉬운 난이도기는 했지만) 코딩테스트를 수월하게 해결하고, 문제를 해결하는 사고력이 있다고 느꼈기 때문에 재미있었다.
이번주와 다음주를 정말 이악물고 예습, 복습을 철저히 해서 이번 수업을 기반으로 코딩테스트 능력을 쭉 길러가야겠다고 생각했다.

## 알고리즘
### 숫자통일
![04-01](../../assets/images/algorithm/04/01.png)

```javascript
function solution (s) {
    let answer;
    let zero = 0;
    let one = 0;
    
    s[0] === '0' ? zero++ : one++;

    for (let i = 1; i < s.length; i++) {
        if (s[i] !== s[i-1]) {
            if (s[i] === '1') {
                one++;
            } else {
                zero++;
            }
        }
    }
    answer = zero > one ? one : zero

    return answer;
}

console.log(solution('100001111'));
console.log(solution('10010111100'));
```
* zero와 one이라는 카운트 변수를 선언하고 문자열의 첫 번째가 0인지 1인지를 먼저 확인해서 카운트를 증가시켰다.
	* 여기서 실수한 게 있는데, 문자열에서 인덱스로 꺼내온 것은 당연히 문자열임을 주의하자!
* 내가 기존에 푼 방법과 개념은 비슷하다. 하지만 나는 객체를 선언해서 문제를 해결하였고, 배운 방법은 변수로 카운트를 세서 문제를 해결했다.

---
### 상태변화
![04-02](../../assets/images/algorithm/04/02.png)

```javascript
function solution(s1, s2) {
    let answer;
    let zero = 0
    let one = 0;

    for (let i = 0; i < s1.length; i++) {
        if (s1[i] !== s2[i]) {
            s1[i] === '0' ? zero++ : one++;
        }
    }

    answer = zero > one ? zero : one;

    return answer;
}

console.log(solution("11000111", "11100110"));
console.log(solution("11000111", "11111110"));
```
* 1번 문제와 마찬가지로 배운 방법에서는 카운트 변수를 선언해서 문제를 해결했고, 내가 푼 방법은 객체를 사용해서 문제를 해결했다.
* 다만 내가 풀 때는 문자의 인덱스로 접근을 `문자열.charAt(index)` 방식으로 했는데, 확실히 `문자열[index]` 방법이 보기도 좋고 쓰기에도 쉬워보인다. 이 방법으로 문자에 접근해야겠다.

---
### 접미사 정렬
![04-03](../../assets/images/algorithm/04/03.png)

```javascript
function solution(s) {
    let answer = [];

    for (let i = 0; i < s.length; i++) {
        answer.push(s.substring(i, s.length));
    }

    answer.sort();
    
    return answer;
}

console.log(solution('kseaedu'));
```
* 문자열의 접미사에 접근해서 빈 배열에 push하는 방법으로 모든 접미사를 구했다.
	* 여기서 substring()은 문자열에서 특정 인덱스에 위치한 문자열을 꺼내올 때 유용한 메서드이다.
	* 첫 번째 매개변수에는 시작하는 인덱스, 두 번째 매개변수에는 끝나는 인덱스(해당 인덱스는 포함 안함)를 설정한다.
	* 두 번째 매개변수를 설정하지 않으면 시작하는 인덱스부터 끝까지 자른다.
* 그리고 배열을 `sort()`하여 사전 순으로 정렬하였다.

---
### 공통문자가 없는 단어
![04-04](../../assets/images/algorithm/04/04.png)

```javascript
function isUnique(short, long) {
    for (let x of short) {
        if (long.indexOf(x) !== -1) {
            return false;
        }
    }
    return true;
}

function solution (words) {
    let answer = 0;

    for (let i = 0; i < words.length - 1; i++) {
        for (let j = i + 1; j <words.length; j++) {
            if (isUnique(words[i], words[j])) {
                let result =  words[i].length * words[j].length;
                answer = Math.max(answer, result)
            }
        }
    }

    return answer;
}

console.log(solution(["skudy", "kstue", "time", "back", "good"]));
console.log(solution(["kk", "k", "kkk", "kkkkk", "kkkk"]));
```
* 같은 개념으로 문제를 풀었지만, 나는 4중 반복문을 이용해서 문제를 해결했는데 따로 `isUnique()` 함수를 구현해서 코드를 짜니 훨씬 가독성이 좋았다.
* 두 값 중 큰 값이나 작은 값을 비교할 때, `Math.max(값1, 값2)`를 사용하면 더 깔끔하게 코드를 구현할 수 있을 것 같다.

---
### 회문문자열 2
![04-05](../../assets/images/algorithm/04/05.png)

```javascript
function solution(s) {
    let answer = "YES";
    let lt = 0;
    let rt = s.length - 1;

    while (lt < rt) {
        if (s[lt] !== s[rt]) {
            let s1 = s.substring(lt, rt);
            let s2 = s.substring(lt+1, rt+1);
            if(s1.split('').reverse().join('')!==s1 && s2.split('').reverse().join('')!==s2){
                answer = "NO";
            }
            break;
        } else {
            lt++;
            rt--;
        }
    }

    return answer;
}
console.log(solution('abcbdcba'));
console.log(solution('abcabbakcba'));
console.log(solution('abcacbakcba'));
```
* 투포인터 방법을 사용해서 문제를 해결했다.
* 각 양쪽 끝의 인덱스를 지정하는 lt, rt 변수를 초기화해서, rt가 lt보다 큰 동안 반복문을 실행시켰다.
* 회문 문자열은 뒤집었을 때 같은 문자가 되어야 하므로, lt와 rt에 있는 문자를 비교하여 같다면 lt를 1증가시키고 rt를 1감소시켜서 회문 문자열일 경우 그대로 반복문을 빠져나와 기본값인 YES가 반환된다.
* lt에 있는 문자와 rt에 있는 문자가 다를 때, lt에 있는 값을 제외하고 substring한 값과 rt에 있는 값을 제외하고 substring한 값을 구해서 둘다 회문 문자열이 아니라면 answer에 NO를 삽입하여 반환한다.

---
### 학급 회장
![04-06](../../assets/images/algorithm/04/06.png)

```javascript
function solution(s) {
    let answer;
    let sh = new Map();

    for (let i = 0; i < s.length; i++ ) {
        // 카운팅은 맵으로..
        sh.set(s[i], sh.get(s[i]) + 1 || 1);
    }

    let max = Number.MIN_SAFE_INTEGER;
    for(let [key, val] of sh) {
        if(val>max) {
            max = val;
            answer = key;
        }
    }

    return answer;
}

console.log(solution('BACBACCACCBDEDE'));
```
* 내가 풀었던 방식과 이론은 똑같지만, 방식이 많이 달랐고 많이 배웠다.
* 지금까지 카운팅 관련된 것들을 객체로 처리했는데, 맵을 사용하는 것이 좋다고 했다.
* sh라는 새로운 맵 객체를 생성하여, 문자열의 각 문자를 키로 한 카운트를 세는 반복문을 실행했다.
* `sh.get(s[i])`가 `undefined`인 경우에 연산을 하면 `NaN`이 결과가 되므로, 단축 평가 논리 계산법을 활용해 기본값을 설정해줬다.
* `Number.MIN_SAFE_INTEGER`는 안전한 최소값이라는 상수이다.
* `for ... of` 문법으로 맵을 반복하면, `[key, val]`로 키와 값을 쉽게 받을 수 있다.

#### Map 객체
* `let sh = new Map();`: 새로운 맵 객체 생성
* `sh.set(키, 값)`: sh 맵에 키와 값을 삽입
* `sh.get(키)`: 키로 값을 조회해서 반환
* `sh.delete(키)`: 키로 값을 조회해서 삭제
* `sh.has(키)`: 키로 값을 조회해서 값을 가졌다면 true, 없다면 false 반환
* `sh.size()`: 맵에 존재하는 키 개수 반환

---
### 아나그램
![04-07](../../assets/images/algorithm/04/07.png)

```javascript
function solution(s1, s2) {
    if (s1.length !== s2.length) {
        return "NO";
    }

    let answer = "YES";
    let sh = new Map();

    for (let x of s1) {
        sh.set(x, sh.get(x) + 1 || 1);
    }

    for (let x of s2){
        if(!sh.has(x) || sh.get(x)===0) answer="NO";
        sh.set(x, sh.get(x)-1);
    }

    return answer;
}

console.log(solution('AbaAeCe', 'baeeACA'));
console.log(solution('abaCC', 'Caaab'));
```
* 두 문자열을 구성하는 문자의 종류와 개수가 같은지를 비교해서 반환하면 되니, map을 활용해서 쉽게 해결할 수 있다.
* 맵을 생성하고 s1의 문자 종류와 개수를 맵에 저장한다.
* 그리고 s2를 반복해서 s2의 문자가 맵 sh에 없거나, 키에 해당하는 값이 0이면 answer를 NO로 저장하고, 조건문에 해당하지 않는다면 해당하는 키에 값을 1 빼서 저장한다.
* 그러면 구성이 정확하게 일치할 때 YES를 반환하고, 일치하지 않으면 NO를 반환한다.

---
### 문자열 구분하기
![04-08](../../assets/images/algorithm/04/08.png)

```javascript
function solution(words) {
    let answer;
    let i;
    let sh = new Map();
    
    for(i = 0; i < words[0].length; i++) {
        let flag = true;
        for(let j = 0; j < words.length; j++) {
            let x = words[j].substring(0, i + 1);
            if(sh.has(x)) {
                flag = false;
                break;
            }
            sh.set(x, 1);
        }
        if (flag) break;
    }
    answer = i + 1;

    return answer;
}

console.log(solution(["seeasue", "sesseysu", "semeas"]));
console.log(solution(["ackky", "kabck", "yokkcs"]));
console.log(solution(["longlong", "longtong", "longbig"]));
```
* 각 문자열들의 접두어를 비교해야 하므로, 임의로 첫번째 문자열의 길이만큼 반복문을 돌리고, 그 안에서 문자열의 개수만큼 반복문을 돌렸다.
* 플래그를 사용해서 반복문을 제어하기 위해 기본값이 true인 플래그를 첫번째 반복문 안에 선언했다.
* 접두어를 잘라내서 비교해야 하므로, substring으로 앞 글자부터 접두어를 잘라내고 그 값이 맵 sh에 있는지 확인하여 없다면 맵에 접두어를 키로하고 값을 1로한 것을 저장하였다.
* 값이 맵 sh에 있다면 각 단어가 모두 다르지 않기 때문에 플래그를 false로 만들고, break로 가장 안쪽 반복문을 빠져나갔다.
* 그리고 안쪽 반복문이 끝날 때마다 플래그 값을 확인했는데, 값이 true라면 맵 sh에서 키에 대한 값이 모두 다른 것이라는 뜻이기 때문에 전체 반복문을 빠져나갔다.
