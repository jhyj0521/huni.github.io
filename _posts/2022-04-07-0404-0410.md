---
title: "0404 - 0410"
tag: TIL
category: TIL
excerpt: ""
---

## 0404

# 타입스크립트 기능보다는 ECMAScript 기능 사용하기

기존 자바스크립트는 결함이 많고 개선해야 할 부분이 많아서, 타입스크립트는 초기 버전에 독립적으로 개발한 클래스, 열거형, 모듈 시스템을 포함시킬 수밖에 없었다.  
시간이 흐르며 대부분 JS 내장 기능으로 추가했으나, 새로 추가된 기능들은 기존 TS 기능과 호환성 문제를 발생시켰다.  
결국 TC39는 런타임 기능을 발전시키고, TS 팀은 타입 기능만 발전시킨다는 명확한 원칙을 세우고 현재까지 지켜오고 있다.

이 원칙이 세워지기 전에, 이미 사용되고 있던 몇 가지 기능이 있는데, 이는 타입 공간과 값 공간의 경계를 혼란스럽게 만들기 때문에 사용하지 않는 것이 좋다.

## 열거형(enum)

많은 언어에서 몇몇 값의 모음을 나타내기 위해 열거형을 사용한다.

```typescript
enum Flavor {
  VANILLA = 0,
  CHOCOLATE = 1,
  STRAWBERRY = 2,
}

let flavor = Flavor.CHOCOLATE; // 타입이 Flavor
```

- 단순히 값을 나열하는 것보다 실수가 적고 명확하기 때문에 일반적으로 열거형을 사용하는 것이 좋다.
- 그러나 TS의 열거형은 몇 가지 문제가 있다.
- 숫자 열거형에 0, 1, 2 외의 다른 숫자가 할당되면 매우 위험하다.
- 상수 열거형은 보통의 열거형과 달리 런타임에 완전히 제거된다. 위의 예제를 const enum Flavor로 바꾸면, 컴파일러는 Flavor.CHOCOLATE을 1으로 바꿔 버린다.
- 문자열 열거형은 런타임의 타입 안전성과 투명성을 제공한다. 그러나 타입스크립트의 다른 타입과 달리 구조적 타이핑이 아닌 명목적 타이핑을 사용한다.
  - 명목적 타이핑은 타입의 이름이 같아야 할당이 허용된다.

이처럼 JS와 TS에서 동작이 다르기 때문에 문자열 열거형은 사용하지 않는 것이 좋다. 열거형 대신 리터럴 타입의 유니온을 사용하면 된다.

```typescript
type Flavor = "vanilla" | "chocolate" | "strawberry";

const flavor: Flavor = "chocolate";
```

- 리터럴 타입의 유니온은 열거형만큼 안전하며 JS와 호환되는 장점이 있다.

### 매개변수 속성

일반적으로 클래스를 초기화할 때 속성을 할당하기 위해 생성자의 매개변수를 사용한다.

```typescript
class Person {
  name: string;
  constructor(name: string) {
    this.name = name;
  }
}
```

타입스크립트는 더 간결한 문법을 제공한다.

```typescript
class Person {
  constructor(public name: string) {}
}
```

- public name은 '매개변수 속성'이라고 불리며, 간단하지만 몇 가지 문제점이 존재한다.
- 일반적으로 타입스크립트 컴파일은 타입 제거가 이루어지므로 코드가 줄어들지만, 매개변수 속성은 코드가 늘어나는 문법이다.
- 매개변수 속성이 런타임에는 실제로 사용되지만, TS 관점에서는 사용되지 않는 것처럼 보인다.
- 매개변수 속성과 일반 속성을 섞어서 사용하면 클래스 설계가 혼란스러워진다.
- 클래스에 매개변수 속성만 존재한다면 클래스 대신 인터페이스로 만들고 객체 리터럴을 사용하는 것이 좋다.

### 네임스페이스와 트리플 슬래시 임포트

ES6 이전에는 JS에 공식적인 모듈 시스템이 없었다. 그래서 각 환경마다 모듈 시스템을 마련했다.  
TS 역시 자체적인 모듈 시스템을 구축했고, module 키워드와 '트리플 슬래시'임포트를 사용했다.  
이후 ES6가 모듈 시스템을 도입한 이후, TS는 충돌을 피하기 위해 module과 같은 기능을 하는 namespace 키워드를 추가했다.

```typescript
namespace foo {
  function bar() {}
}

/// <reference path="other.ts"/>
foo.bar();
```

- 트리플 슬래시 임포트와 module 키워드는 호환성을 위해 남아 있을 뿐이며, 이제는 ES6 스타일의 모듈을 사용해야 한다.

### 데코레이터

데코레이터는 클래스, 메서드, 속성에 애너테이션을 붙이거나 기능을 추가하는 데 사용할 수 있다.  
예를 들어, 클래스의 메서드가 호출될 때마다 로그를 남기려면 logged 애너테이션을 정의할 수 있다.  
데코레이터는 처음에 앵귤러 프레임워크를 지원하기 위해 추가되었으며, 앵귤러를 사용하거나 애너테이션이 필요한 프레임워크를 사용하고 있는 게 아니라면 데코레이터가 표준이 되기 전에는 TS에서 데코레이터를 사용하지 않는 게 좋다.

# 객체를 순회하는 노하우

```typescript
const obj = {
  one: "uno",
  two: "dos",
  three: "tres",
};

for (const k in obj) {
  const v = obj[k];
}
```

- 이 예시는 정상적으로 실행되지만, 편집기에서는 오류가 발생한다.
- k의 타입은 string인 반면, obj 객체에는 'one', 'two', 'three' 세 개의 키만 존재한다. k와 obj 객체의 키 타입이 서로 다르게 추론되어 오류가 발생한 것이다.
- k의 타입을 구체적으로 명시해 주면 오류는 사라진다.

```typescript
const obj = {
  one: "uno",
  two: "dos",
  three: "tres",
};

let k: keyof typeof obj;
for (k in obj) {
  const v = obj[k];
}
```

- obj에는 'one', 'two', 'three' 외의 추가키를 가진 객체가 할당될 수도 있으므로 이와 같은 오류가 발생한다.
- keyof 키워드를 사용한 방법은 v가 `string | number` 타입으로 한정되어 범위가 너무 좁아 문제가 될 수 있다.
- 추가적인 키를 가진 객체가 할당될 수 있기에 v의 타입을 이러게 추론한 것은 잘못이며 런타임 동작을 예상하기 어렵다.

단지 객체의 키와 값을 순회하고 싶다면 Object.entries를 사용하면 된다.

```typescript
interface ABC {
  a: string;
  b: string;
  c: number;
}

function foo(abc: ABC) {
  for (const [k, v] of Object.entries(abc)) {
    k; // string 타입
    v; // any 타입
  }
}
```

- 객체를 다룰 때는 항상 프로토타입 오염의 가능성을 염두에 두어야 한다.
- for-in 문을 사용하면, 객체의 정의에 없는 속성이 갑자기 등장할 수 있다.
- 실제 작업에서는 Object.prototype에 순회 가능한 속성을 절대로 추가하면 안 된다.
- kyeof 선언은 상수이거나 추가적인 키 없이 정확한 타입을 원하는 경우 적절하고, Object.entries는 더욱 일반적으로 쓰이지만 키와 값의 타입을 다루기 까다롭다.

<br />
<br />
<br />

## 0405

# useRef

`const refContainer = useRef(initialValue);`  
useRef는 current 프로퍼티가 전달된 인자(initialValue)로 초기화된 변경 가능한 ref 객체를 반환한다.  
반환된 객체는 컴포넌트의 전 생애주기를 통해 유지된다.

React에서 ref는 주로 DOM 노드 참조 목적으로 사용되지만, 컴포넌트 렌더링에 영향을 주지 않는 값 참조 목적으로 사용되기도 한다.  
`React.useRef()` 훅은 함수 컴포넌트 내부에서 가변 값을 유지하는 데에 편리하다.  
개념적으로, class의 인스턴스 변수와 ref를 비슷하게 생각할 수 있다.  
useRef는 순수 자바스크립트 객체를 생성하는데, 매번 렌더링을 할 때 동일한 ref 객체를 제공한다.

`React.useState()` 훅과 달리, `useRef()` 훅은 현재 값이 변경되어도 컴포넌트가 다시 렌더링되지 않아서 불필요한 렌더링을 방지하고, 애플리케이션 성능을 최적화 할 수 있다.

```javascript
function Timer() {
  const intervalRef = useRef();
  useEffect(() => {
    const id = setInterval(() => {
      // ...
    });
    intervalRef.current = id;
    return () => {
      clearInterval(intervalRef.current);
    };
  });

  // ...
}
```

인터벌을 설정하고 싶다면 ref가 필요하지 않지만, 이벤트 처리에서 인터벌을 지우고 싶을 때 유용하다.

```javascript
function handleCancelClick() {
  clearInterval(intervalRef.current);
}
```

지연 초기화를 수행하지 않는 한, 렌더링 중에 ref 설정을 피해야 한다.  
일반적으로 이벤트 처리와 effect에서 ref를 수정하는 것이 좋다.

# useLayoutEffect

useEffect 훅과 사용법이 동일하다. 거의 비슷하지만 실행되는 시기가 다르다.  
페이지 로드 차단을 방지하기 위해 DOM이 렌더링 된 이후 useEffect 훅에 설정된 콜백함수가 실행되면 위치 및 스타일 적용에 문제가 생길 수 있다.  
이러한 문제를 해결해야 할 경우 useLayoutEffect 훅을 사용한다.

useLayoutEffect 훅은 DOM이 렌더링 되고 페인팅 되기 직전에 동기적으로 실행된다. 반면, useEffect는 DOM 페인팅 이후 비동기적으로 실행된다.  
그렇기에 useEffect는 DOM에 영향을 미치는 코드가 있다면 다시 그리므로 화면 깜빡임이 발생한다.  
반면, useLayoutEffect는 화면에 그리기 전에 수행되므로 DOM에 영향을 미치는 코드를 넣어도 화면 깜빡임이 발생하지 않는다.  
하지만 동기적인 동작에서 발생하는 단점을 가지고 있다. 만약 useLayoutEffect에서 오랜 시간이 소요된다고 가정하면 유저는 그 시간 동안 빈 화면을 보게 되는 것이다.

그렇기에 useEffect를 사용하여 설계하다가 UX적으로 문제가 발생하면 useLayoutEffect를 적절히 섞어서 사용하는 것이 좋다.

## useLayoutEffect 문제점

SSR 환경에서 사용할 경우 에러가 발생한다.  
이를 수정하기 위해서는 로직을 useEffect로 이동하거나 클라이언트 렌더링이 완료될 때까지 컴포넌트 노출을 지연하는 방법이 있다.

서버에서 렌더링된 HTML에서 layoutEffect가 필요한 컴포넌트를 배제하고 싶다면, `showChild && <Child />`를 사용하여 조건적으로 렌더링 하고 `useEffect(() => { setShowChild(true); }, [])`를 사용하여 노출을 지연시킬 수 있다.  
이런 방법으로 JS 코드가 주입되기 전에 깨져 보일 수 있는 UI는 표현되지 않게 된다.

SSR에서도 사용하고 싶은 경우 렌더링이 되어 window 객체가 생기는지에 따라 useEffect를 사용할지 useLayoutEffect를 사용할지 결정할 수 있다.

```javascript
// 커스텀 훅
import { useEffect, useLayoutEffect } from "react";

export const useIsomorphicEffect = () => {
  return typeof window !== "undefined" ? useLayoutEffect : useEffect;
};

// 커스텀 훅 사용
import { useEffect, useLayoutEffect } from "react";
import { useIsomorphicEffect } from "./useIsomorphicEffect";

const App = () => {
  const isomorphicEffect = useIsomorphicEffect();

  isomorphicEffect(() => {
    // do something you want
  }, []);

  return <div>Hellow world</div>;
};
```

커스텀 훅으로 만들어 두어 사용할 부분에서 Effect로 사용하면 된다.
