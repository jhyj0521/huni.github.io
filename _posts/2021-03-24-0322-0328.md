---
title: "0322-0328"
tag: TIL
category: TIL
---
## 0322
# JWT (JSON Web Tokens)


*JSON 객체를 사용해서 토큰 자체에 정보들을 저장하고 있는 Web Token*

### Header
* Signature를 해싱하기 위한 알고리즘 정보

### Payload
* 서버와 클라이언트가 주고받는, 시스템에서 실제로 사용될 정보

### Signature
* 토큰의 유효성 검증을 위한 문자열
* 이 문자열을 통해 서버에서는 이 토큰이 유효한 토큰인지 검증할 수 있다.

### 장점
* 세션/쿠키 방식은 별도의 저장소의 관리가 필요하다. 그러나 JWT는 발급한 후 검증만 하면 되기 때문에 추가 저장소가 필요 없어서 stateless 한 서버를 만들수 있다.
* 서버를 확장하거나 유지, 보수하는데 유리하다.
* 토큰 기반으로 하는 다른 인증시스템에 접근이 가능하다. 예를들어 Google 로그인 등은 모두 토큰을 기반으로 인증한다.

### 단점
* Payload의 정보가 많아지면 네트워크 사용량 증가, 데이터 설계 고려 필요
* 토큰이 클라이언트에 저장되어 서버에서 클라이언트 토큰을 조작할 수 없음

## JWT 인증방식
1. 먼저 브라우저에서 Login요청을 한다.
2. 서버에서는 계정정보를 읽어 사용자를 확인한 후, 사용자의 고유한 ID값을 부여한 후, 기타 정보와 함께 Payload에 넣는다.
3. JWT 토큰의 유효기간을 설정한다.
4. 암호화할 secret key를 이용해 ACCESS TOKEN을 발급한다.
5. 사용자는 토큰을 받아 저장한 후, 인증이 필요한 요청마다 토큰을 헤더에 실어 보낸다.
6. 서버에서는 해당 토큰의 verify signature를 secret key로 복호화한 후, 조작 여부, 유효기간을 확인한다.
7. 검증이 완료된다면, Payload를 디코딩하여 사용자의 ID에 맞는 데이터를 가져온다.

## 간단 사용법
*대부분의 복잡한 것들은 빌더 기반의 유용한 인터페이스 뒤에 숨겨져 있으며, 빠르게 코드를 작성하는 데 적합*

```java
Key key = Keys.secretKeyFor(SignatureAlgorithm.HS256);

String jws = Jwts.builder().setSubject("Joe").signWith(key).compact();
```
1. 서브젝트가 세팅된 등록된 클레임을 가진 JWT를 빌딩한다.
2. SHA-256 알고리즘으로 JWT를 서명한다.
3. 문자형태로 컴팩팅한다. 서명된 JWT를 JWS라 부른다.

## Signed JWTs
*JWT 사양은 JWT에 암호화 방식으로 서명하는 기능을 제공한다.*

1. JWT가 우리가 아는 사람에 의해 생성되었음을 보장한다.
2. JWT가 생성 된 후 아무도 JWT를 조작하거나 변경하지 않았음을 보장한다.

### JWT 서명 과정
```json
{
	"alg": "HS256"
}
```

```java
String header = '{"alg":"HS256"}'
String claims = '{"sub":"Joe"}'

String encodedHeader = base64URLEncode( header.getBytes("UTF-8") )
String encodedClaims = base64URLEncode( claims.getBytes("UTF-8") )

String concatenated = encodedHeader + '.' + encodedClaims

Key key = getMySecretKey()
byte[] signature = hmacSha256( concatenated, key )

String jws = concatenated + '.' + base64URLEncode( signature )
```
1. JSON header와 body(Claims)가 있는 JWT가 있다고 가정하면,
2. JSON에서 불필요한 공백을 제거하고, UTF-8 바이트와 Base64URL 인코딩을 각각 가져온다.
3. 인코딩 된 헤더와 클레임을 그들 사이에 마침표 문자로 연결한다.
4. 선택한 서명 알고리즘과 함께 암호화 비밀 또는 개인 키를 사용하고 연결된 문자열에 서명한다.
5. 서명은 항상 바이트 배열이기 때문에 Base64는 서명을 URL 인코딩하고 마침표 문자 '.'를 추가한다.

* 이것을 JWS라고 하며, 서명된 JWT의 약자이다.
* 물론 코드에서 수동으로 이 작업을 수행하지 않는다.

### 비밀 키 생성 - SHA-256 사용
* 만약에, JWT HMAC-SHA 알고리즘을 사용하기 위해서 충분히 강력한 SecretKey를 생성하기 원한다면, Keys.secretKeyFor(SignatureAlgorithm) 메서드를 사용한다.
```java
SecretKey key = Keys.secretKeyFor(SignatureAlgorithm.HS256); //or HS384 or HS512
```
* 만약에 사용자가 이 새로운 SecretKey를 저장하길 원한다면, Base64 (혹은 BaSE64URL) 인코딩을 사용할 수 있다.
```java
String secretString = Encoders.BASE64.encode(key.getEncoded());
```
*  Base64 인코딩은 암호화가 아니므로 여전히 민감한 정보로 간주되어 안전한 곳에 저장해야 한다.

## 0323
## JWS 생성
```java
String jws = Jwts.builder() // (1)
    .setSubject("Bob")      // (2) 
    .signWith(key)          // (3)
    .compact();             // (4)
```
1. Jwts.builder() 메서드를 사용하여 JwtBuilder 인스턴스를 생성한다.
2. 원하는대로 헤더 매개 변수와 클레임을 추가하는 메서드를 호출한다.
3. JWT에 서명하는 데 사용할 SecretKey를 지정한다.
4. compact() 메서드를 호출하여 압축하고 서명하여 최종 JWS를 생성한다.

### 헤더 매개 변수
*JWT 헤더는 JWT의 클레임과 관련된 콘텐츠, 형식 및 암호화 작업에 대한 메타 데이터를 제공한다.*

```java
Map<String,Object> header = getMyHeaderMap(); //implement me
String jws = Jwts.builder()
    .setHeader(header)
    // ... etc ...
```
* 헤더를 설정하는 데는 헤더 인스턴스를 사용하는 방법과, 헤더 맵을 사용하는 방법이 있는데 나는 한 번에 처리할 수 있는 헤더 맵을 사용하여 설정하였다.

### Claims
*클레임은 JWT의 본문(페이로드)이며 JWT 작성자가 JWT 수신자에게 제공하기를 원하는 정보를 포함한다.*

**표준 클레임**
* `setIssuer`: 발행자 클레임을 설정한다.
* `setSubject`: 주제를 설정한다.
* `setAudience`: 받는 사람을 설정한다.
* `setExpiration`: 만료 시간을 설정한다.
* `setNotBefore`: 동작하지 않는 시간을 설정한다.
* `setIssuedAt`: 발급 시간을 설정한다.
* `setId`: 아이디를 설정한다.

```java
Map<String,Object> claims = getMyClaimsMap(); //implement me
String jws = Jwts.builder()
    .setClaims(claims)
    // ... etc ...
```

### Signing Key
* JwtBuilder의 `signWith`메서드 를 호출하여 서명 키를 지정하고 JJWT가 지정된 키에 허용되는 가장 안전한 알고리즘을 결정 하도록하는 것이 좋다.
```java
String jws = Jwts.builder()
   // ... etc ...
   .signWith(key) // <---
   .compact();
```
* signWith JJWT를 사용할 때 alg관련 알고리즘 식별자와 함께 필요한 헤더도 자동으로 설정됩니다 .

### SecretKey 형식
* 만약에 사용자가 HMAC-SHA 알고리즘으로 JWS를 서명하기 원하고, 사용자가 String 형식 혹은 인코딩 된 byte 배열 형태의 비밀 키를 가지고 있다면, 사용자는 그것을 signWith 메서드 매개변수로서 사용하기 위해 ScreteKey 객체로 변환해야 한다.

## Reading a JWS
1. JwtParserBuilder 객체를 생성하기 위해서 Jwts.parseBuilder() 메서드를 사용한다.
2. JWS 서명을 증명하기 위해 사용하고 싶은 SecretKey 혹은 비대칭 PubliKey를 명세한다.
3. 쓰레드에 안전한 JwtParser를 리턴하기 위해 JwtParserBuilder에 build() 메서드를 호출한다.
4. parseClaimsJws(String) 메서드를 원본 JWS를 만드는 jws String와 함께 호출한다.
5. 파싱이나 서명 유효성이 실패하는 경우에 try/catch 블록 안에서 모든 호출이 래핑된다. 

```java
Jws<Claims> jws;

try {
    jws = Jwts.parserBuilder()  // (1)
    .setSigningKey(key)         // (2)
    .build()                    // (3)
    .parseClaimsJws(jwsString); // (4)
    
    // we can safely trust the JWT
     
catch (JwtException ex) {       // (5)
    
    // we *cannot* use the JWT as intended by its creator
}
```
* 주의: 만약 JWS를 기대한다면, 항상 JwtParser의 parseClaimsJws 메서드를 호출하여라.

### 검증 키
* JWS를 읽을 때 가장 중요한 것은 JWS의 암호화된 signature을 증명하기 위해서 키를 명세하는 것.
* signature 증명이 실패하면, JWT는 안전하게 신뢰될 수 없으며 폐기 되어야만 한다.
* 만약 jws가 SecretKey로 서명되었다면, 같은 SecretKey는 JwtParserBuilder에 명세되어야 한다.