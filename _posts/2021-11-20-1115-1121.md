---
title: "1115-1121"
tag: TIL
category: TIL
---

## 1115

이전에 진행한 Shall we trip 프로젝트에서도 무한 스크롤 기능을 구현하였는데, 이번 프로젝트에서도 무한 스크롤 기능을 구현하게 되었다. 이전 프로젝트에서는 수직으로 얼마나 스크롤 됐는지를 반환하는 scrollY 프로퍼티와 뷰포트의 높이를 나타내는 innerHeight를 더한 값이 요소의 높이를 측정하는 offsetHeight를 사용해서 body 요소의 높이를 측정하고 이 값과 같은 경우 데이터를 불러오도록 구현하였다. 이 때는 스크롤 이벤트에 디바운스 처리를 해서 이벤트를 호출시켰다. 하지만 이번 프로젝트에서는 Intersection Observer API를 사용해서 이러한 기능을 구현하였다.
.

# Intersection Observer API

- 타겟 요소와 상위 요소 또는 최상위 document의 viewport 사이의 intersection 내의 변화를 비동기적으로 관찰하는 방법
- 화면에 보여지는지의 여부를 판단해서 특정 영역 내에 관찰하고자 하는 요소가 들어갔는지 나갔는지를 확인하여 교차 영역 관리를 최적화 할 수 있다.

## intersection 정보가 필요한 경우

1. 페이지가 스크롤 되는 도중 발생하는 이미지나 다른 컨텐츠의 지연 로딩
2. 스크롤 시에, 더 많은 컨텐츠가 로드 및 렌더링되어 사용자가 페이지를 이동하지 않아도 되게 하는 infinite-scroll을 구현
3. 광고 수익을 계산하기 위한 용도로 광고의 가시성 보고

## Intersection observer의 컨셉과 사용

Intersection Observer API는 다음과 같은 상황에 호출되는 콜백을 생성하는 기능을 제공한다.

1. target으로 칭하는 요소가 기기 뷰포트나 특정 요소와 교차함
2. observer가 최초로 타겟을 관측하도록 요청받을 때마다

뷰포트 혹은 다른 요소를 root로 사용하건 간에, 이 API는 같은 방식으로 동작한다. 대상 요소의 가시성이 변경될 때마다 등록한 콜백 함수를 실행하며, 원하는 만큼 root 요소와 교차한다.
root와 대상 요소가 교차하는 정도를 intersection ratio라고 한다. 이것은 대상 요소의 가시성 퍼센티지를 0.0 ~ 1.0의 숫자로 표현한다.

## Intersection observer 장단점

IE를 지원하지 않는다는 단점이 존재하지만 감시하고자 하는 요소가 다른 요소에 들어가거나 나갈 때 실행할 콜백 함수를 등록할 수 있게 한다. 이전 프로젝트에서 사용한 방식은 디바운스 처리를 한다고 하더라도 페이지를 스크롤할 때 반복적으로 교차 탐지를 실행하게 된다. 하지만 이번 프로젝트에 적용한 방식은 사이트는 요소의 교차를 지켜보기 위해 메인 스레드를 사용할 필요가 없어지고 브라우저의 원하는 대로 교차 영역 관리를 최적할 수 있어서 유효한 방법이라고 생각한다.
