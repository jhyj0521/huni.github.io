---
title: "0425 - 0431"
tag: TIL
category: TIL
excerpt: ""
---

## 0425

# 외부 API 연동

## 데이터 연동하기

컴포넌트가 화면에 보이는 시점에 API를 요청할 경우, useEffect를 사용하여 컴포넌트가 처음 렌더링되는 시점에 API를 요청하면 된다.  
주의할 점은 useEffect에 등록하는 함수에 async를 붙이면 안 된다는 것이다. useEffect에서 반환해야 하는 값은 뒷정리 함수이기 때문이다.

useEffect에서 async/await를 사용하고 싶다면, 함수 내부에 async 키워드가 붙은 또 다른 함수를 만들어서 사용해 주어야 한다.

```javascript
const NewsList = () => {
  const [articles, setArticles] = useState(null);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      try {
        const response = await axios.get(
          "https://newsapi.org/v2/top-headlines?country=kr&apiKey=f45fa97679204f119d4d91f9f341c2fb"
        );
        setArticles(response.data.articles);
      } catch (e) {
        console.log(e);
      }
      setLoading(false);
    };
    fetchData();
  }, []);

  if (loading) {
    return <NewsListBlock>대기 중...</NewsListBlock>;
  }

  if (!articles) {
    return null;
  }
  return (
    <NewsListBlock>
      {articles.map((article) => (
        <NewsItem key={article.url} article={article} />
      ))}
    </NewsListBlock>
  );
};
```

- 데이터를 불러와서 컴포넌트 배열로 변환할 때 신경 써야 할 부분은 map 함수를 사용하기 전에 꼭 !articles를 조회하여 해당 값이 현재 null이 아닌지 검사해야 한다.
- 그렇지 않으면, 데이터가 없을 때 null에는 map 함수가 없기 때문에 렌더링 과정에서 오류가 발생한다.

## 리액트 라우터 적용

src 디렉터리에 pages를 생성하고, 파일을 만들어 작성한다.

```jsx
const NewsPage = () => {
  const { category = "all" } = useParams();

  return (
    <>
      <Categories />
      <NewsList category={category} />
    </>
  );
};
```

여기서 useParams 훅을 사용해 category params를 가져온다.

이후 App에서 Route를 정의한다.

```jsx
const App = () => {
  return (
    <Routes>
      <Route path=":category" element={<NewsPage />} />
      <Route path="" element={<NewsPage />} />
    </Routes>
  );
};
```

v5 버전까지는 ?를 사용해서 선택적 params를 구현할 수 있었지만, v6 버전부터는 지원하지 않아 이와 같이 구현하도록 한다고 한다.

마지막으로 기존 Categories 컴포넌트를 NavLink 컴포넌트로 바꾼다.

```jsx
const Categories = () => {
  return (
    <CategoriesBlock>
      {categories.map((c) => (
        <Category
          key={c.name}
          className={({ isActive }) => (isActive ? "active" : "")}
          to={c.name === "all" ? "/" : `/${c.name}`}
        >
          {c.text}
        </Category>
      ))}
    </CategoriesBlock>
  );
};
```

v5 버전과 달리 activeClass를 v6에서는 이와 같이 구현한다.

## usePromise 커스텀 Hook

```jsx
import { useEffect, useState } from "react";

export default function usePromise(promiseCreateor, deps) {
  const [loading, setLoading] = useState(false);
  const [resolved, setResolved] = useState(null);
  const [error, setError] = useState(null);

  useEffect(() => {
    const process = async () => {
      setLoading(true);
      try {
        const resolved = await promiseCreateor();
        setResolved(resolved);
      } catch (e) {
        setError(e);
      }
      setLoading(false);
    };
    process();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, deps);

  return [loading, resolved, error];
}
```

- 프로젝트의 다양한 곳에서 사용될 수 있는 유틸 함수들은 lib 디렉터리에 만든 후 작성한다.
- usePromise Hook은 Promise의 대기 중, 완료 결과, 실패 결과에 대한 상태를 관리하며, 의존 배열을 파라미터로 받아 온다.
- 받아온 deps 배열은 usePromise에서 의존 배열로 설정한다.

```jsx
const NewsList = ({ category }) => {
  const [loading, response, error] = usePromise(() => {
    const query = category === "all" ? "" : `&category=${category}`;
    return axios.get(
      `https://newsapi.org/v2/top-headlines?country=kr${query}&apiKey=f45fa97679204f119d4d91f9f341c2fb`
    );
  }, [category]);

  if (loading) {
    return <NewsListBlock>대기 중...</NewsListBlock>;
  }

  if (!response) {
    return null;
  }

  if (error) {
    return <NewsListBlock>에러 발생!</NewsListBlock>;
  }

  const { articles } = response.data;
  return (
    <NewsListBlock>
      {articles.map((article) => (
        <NewsItem key={article.url} article={article} />
      ))}
    </NewsListBlock>
  );
};
```

- 코드가 이전보다 훨씬 간결해진 것을 확인할 수 있다.
- 이와 같이 커스텀 훅을 만들어 사용하면 좋은 코드를 만들어 갈 수 있다.

<br />
<br />
<br />

## 0426

# Context API

Context API는 리액트 프로젝트에서 전역적으로 사용할 데이터가 있을 때 유용한 기능이다.  
Context를 사용하면 컴포넌트 트리로 묶인 컴포넌트 간 데이터 공유가 비교적 수월해진다.  
단, Context는 컴포넌트를 재사용하기 어렵게 만드므로 꼭 필요한 경우만 사용하는 것이 좋다.  
ex) 사용자 로그인 정보, 애플리케이션 환경 설정, 테마 등

전역 상태를 관리할 때 리액트 프로젝트에서 많은 컴포넌트를 거쳐야 할 때도 있고 다루어야 하는 데이터가 훨씬 많아질 수 있으므로 props를 전달하는 방식으로 사용하면 유지 보수성이 낮아질 가능성이 있다.  
Context API를 사용하면 Context를 만들어 단 한 번에 원하는 값을 받아와 사용할 수 있다.

## 새 Context 만들기

새 Context를 만들 때는 createContext 함수를 사용한다.  
파라미터에는 해당 Context의 기본 상태를 지정한다.

```jsx
import { createContext } from "react";

const ColorContext = createContext({ color: "black" });

export default ColorContext;
```

## Consumer 사용

새로운 컴포넌트를 만들어서 Context 안에 있는 값을 사용할 때는 props로 받아 오는 것이 아니라 Context 안에 들어 있는 Consumer라는 컴포넌트를 통해 값을 사용한다.

```jsx
const ColorBox = () => {
  return (
    <ColorContext.Consumer>
      {(value) => (
        <div
          style={{ width: "64px", height: "64px", background: value.color }}
        />
      )}
    </ColorContext.Consumer>
  );
};
```

- Consumer 사이에 중괄호를 열어서 그 안에 함수를 넣어 주었다.
- 이러한 패턴을 Function as a Child, 혹은 Render Props라고 한다. 컴포넌트의 children이 있어야 할 자리에 일반 JSX 혹은 문자열이 아닌 함수를 전달하는 것이다.

**Render Props 예시**

```jsx
const RenderPropsSample = ({ children }) => {
  return <div>결과: {children(5)}</div>;
};

// 사용
<RenderPropsSample>{(value) => 2 * value}</RenderPropsSample>;
```

## Provider

Provider를 사용하면 Context의 value를 변경할 수 있다.

```jsx
function App() {
  return (
    <ColorContext.Provider value={{ color: "red" }}>
      <div>
        <ColorBox />
      </div>
    </ColorContext.Provider>
  );
}
```

- Provider를 사용할 때는 value 값을 명시해 주어야 제대로 작동한다.

## 동적 Context 사용하기

Context의 value에는 무조건 상태 값만 있어야 하는 것은 아니다. 함수를 전달해 줄 수도 있다.

```jsx
const ColorContext = createContext({
  state: { color: "black", subcolor: "red" },
  actions: {
    setColor: () => {},
    setSubcolor: () => {},
  },
});

const ColorProvider = ({ children }) => {
  const [color, setColor] = useState("black");
  const [subcolor, setSubcolor] = useState("red");

  const value = {
    state: { color, subcolor },
    actions: { setColor, setSubcolor },
  };

  return (
    <ColorContext.Provider value={value}>{children}</ColorContext.Provider>
  );
};

const { Consumer: ColorConsumer } = ColorContext;

export { ColorProvider, ColorConsumer };
```

- ColorProvider라는 컴포넌트를 새로 작성해 주었다. 그리고 이 컴포넌트에서는 ColorContext.Provider를 렌더링하고 있다.
- Provider의 value에는 상태를 state로, 업데이트 함수는 actions로 묶어서 전달하고 있다.
- Context에서 값을 동적으로 사용할 때 반드시 묶어서 줄 필요는 없지만, state와 actions 객체를 따로 분리해 주면 나중에 다른 컴포넌트에서 Context의 값을 사용할 때 편리하다.
- createContext를 사용할 때 기본값은 실제 Provider의 value에 넣는 객체의 형태와 일치시켜 주는 것이 좋다. 이렇게 하면 Context 코드를 볼 때 내부 값이 어떻게 구성되어 있는지 파악하기도 쉽고, 실수로 Provider를 사용하지 않았을 때 리액트 앱에서 에러가 발생하지 않는다.

## useContext Hook 사용

리액트 내장 Hooks 중, useContext를 사용하면 함수 컴포넌트에서 Context를 아주 편하게 사용할 수 있다.

```jsx
const ColorBox = () => {
  const { state } = useContext(ColorContext);

  return (
    <>
      <div style={{ width: "64px", height: "64px", background: state.color }} />
      <div
        style={{
          width: "32px",
          height: "32px",
          background: state.subcolor,
        }}
      />
    </>
  );
};
```

- Render Props의 패턴보다, 훨씬 편하게 Context 값을 조회할 수 있다.
- useContext의 인자로 사용하고자 하는 Context를 넘겨 사용하면 된다.

## static contextType 사용

클래스형 컴포넌트에서 Context를 좀 더 쉽게 사용하고 싶다면 static contextType을 정의하는 방법이 있다.

```jsx
const colors = ["red", "orange", "yellow", "green", "blue", "indigo", "violet"];

class SelectColors extends Component {
  static contextType = ColorContext;

  handleSetColor = (color) => {
    this.context.actions.setColor(color);
  };

  handleSetSubcolor = (subcolor) => {
    this.context.actions.setSubcolor(subcolor);
  };

  render() {
    return (
      <div>
        <h2>색상을 선택하세요.</h2>
        <div style={{ display: "flex" }}>
          {colors.map((color) => (
            <div
              key={color}
              style={{
                background: color,
                width: "24px",
                height: "24px",
                cursor: "pointer",
              }}
              onClick={() => this.handleSetColor(color)}
              onContextMenu={(e) => {
                e.preventDefault();
                this.handleSetSubcolor(color);
              }}
            />
          ))}
        </div>
        <hr />
      </div>
    );
  }
}
```

- static contextType을 정의하면 클래스 메서드에서도 Context에 넣어 둔 함수를 호출할 수 있다.
- 하지만, 한 클래스에서 하나의 Context밖에 사용하지 못한다는 단점이 있다.
- 그러나 앞으로 클래스 컴포넌트를 작성하는 일은 많지 않기 때문에 useContext를 사용하는 쪽이 좋다.

## 결론

기존에는 컴포넌트 간 상태 교류를 무조건 부모에서 자식 흐름으로 전달했지만, 이제는 Context API를 통해 쉽게 상태를 교류할 수 있게 되었다.  
하지만 프로젝트 컴포넌트 구조가 간단하고 상태의 종류가 많지 않다면, 굳이 Context를 사용할 필요는 없다. 전역적으로 여기저기서 사용되는 상태가 있고 컴포넌트의 개수가 많은 상황이라면, Context API를 사용하는 것이 권장된다.

<br />
<br />
<br />

## 0427

## 캐시 제어

HTTP는 문서가 만료되기 전까지 얼마나 오랫동안 캐시될 수 있게 할 것인지 서버가 설정할 수 있는 여러 가지 방법을 정의한다.

### no-cache와 no-store 응답 헤더

no-store와 no-cache 헤더는 캐시가 검증되지 않은 캐시된 객체로 응답하는 것을 막는다.

Cache-Control: no-store  
Cache-Control: no-chche

no-store가 표시된 응답은 캐시가 그 응답의 사본을 만드는 것을 금지한다.  
no-cache로 표시된 응답은 로컬 캐시 저장소에 저장될 수 있지만, 먼저 서버와 재검사를 하지 않고서는 캐시에서 클라이언트로 제공될 수 없을 뿐이다.

### Max-Age 응답 헤더

Cache-Control: max-age 헤더는 신선하다고 간주되었던 유효 시간을 의미하고, 초로 나타낸다.  
서버는 최대 age를 0으로 설정함으로써, 캐시가 매 접근마다 문서를 캐시하거나 리프레시하지 않도록 요청할 수 있다.

### Expires 응답 헤더

초 단위의 시간 대신 실제 만료 날짜를 명시한다. deprecated

### Must-Revalidate 응답 헤더

Cache-Control: must-revalidate 응답 헤더는 캐시가 이 객체의 신선하지 않은 사본을 원 서버와의 재검사 없이는 제공해서는 안 됨을 의미한다.  
만약 캐시가 신선도 검사를 시도했을 때 원 서버가 사용할 수 없는 상태라면, 캐시는 반드시 504를 반환해야 한다.  
반면 Cache-Control: no-cache와의 차이점은 no-cache는 원 서버에 접근할 수 없는 경우 캐시 서버 설정에 따라 캐시 데이터를 반환할 수 있다.
