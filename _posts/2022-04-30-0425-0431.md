---
title: "0425 - 0431"
tag: TIL
category: TIL
excerpt: ""
---

## 0425

# 외부 API 연동

## 데이터 연동하기

컴포넌트가 화면에 보이는 시점에 API를 요청할 경우, useEffect를 사용하여 컴포넌트가 처음 렌더링되는 시점에 API를 요청하면 된다.  
주의할 점은 useEffect에 등록하는 함수에 async를 붙이면 안 된다는 것이다. useEffect에서 반환해야 하는 값은 뒷정리 함수이기 때문이다.

useEffect에서 async/await를 사용하고 싶다면, 함수 내부에 async 키워드가 붙은 또 다른 함수를 만들어서 사용해 주어야 한다.

```javascript
const NewsList = () => {
  const [articles, setArticles] = useState(null);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      try {
        const response = await axios.get(
          "https://newsapi.org/v2/top-headlines?country=kr&apiKey=f45fa97679204f119d4d91f9f341c2fb"
        );
        setArticles(response.data.articles);
      } catch (e) {
        console.log(e);
      }
      setLoading(false);
    };
    fetchData();
  }, []);

  if (loading) {
    return <NewsListBlock>대기 중...</NewsListBlock>;
  }

  if (!articles) {
    return null;
  }
  return (
    <NewsListBlock>
      {articles.map((article) => (
        <NewsItem key={article.url} article={article} />
      ))}
    </NewsListBlock>
  );
};
```

- 데이터를 불러와서 컴포넌트 배열로 변환할 때 신경 써야 할 부분은 map 함수를 사용하기 전에 꼭 !articles를 조회하여 해당 값이 현재 null이 아닌지 검사해야 한다.
- 그렇지 않으면, 데이터가 없을 때 null에는 map 함수가 없기 때문에 렌더링 과정에서 오류가 발생한다.

## 리액트 라우터 적용

src 디렉터리에 pages를 생성하고, 파일을 만들어 작성한다.

```jsx
const NewsPage = () => {
  const { category = "all" } = useParams();

  return (
    <>
      <Categories />
      <NewsList category={category} />
    </>
  );
};
```

여기서 useParams 훅을 사용해 category params를 가져온다.

이후 App에서 Route를 정의한다.

```jsx
const App = () => {
  return (
    <Routes>
      <Route path=":category" element={<NewsPage />} />
      <Route path="" element={<NewsPage />} />
    </Routes>
  );
};
```

v5 버전까지는 ?를 사용해서 선택적 params를 구현할 수 있었지만, v6 버전부터는 지원하지 않아 이와 같이 구현하도록 한다고 한다.

마지막으로 기존 Categories 컴포넌트를 NavLink 컴포넌트로 바꾼다.

```jsx
const Categories = () => {
  return (
    <CategoriesBlock>
      {categories.map((c) => (
        <Category
          key={c.name}
          className={({ isActive }) => (isActive ? "active" : "")}
          to={c.name === "all" ? "/" : `/${c.name}`}
        >
          {c.text}
        </Category>
      ))}
    </CategoriesBlock>
  );
};
```

v5 버전과 달리 activeClass를 v6에서는 이와 같이 구현한다.

## usePromise 커스텀 Hook

```jsx
import { useEffect, useState } from "react";

export default function usePromise(promiseCreateor, deps) {
  const [loading, setLoading] = useState(false);
  const [resolved, setResolved] = useState(null);
  const [error, setError] = useState(null);

  useEffect(() => {
    const process = async () => {
      setLoading(true);
      try {
        const resolved = await promiseCreateor();
        setResolved(resolved);
      } catch (e) {
        setError(e);
      }
      setLoading(false);
    };
    process();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, deps);

  return [loading, resolved, error];
}
```

- 프로젝트의 다양한 곳에서 사용될 수 있는 유틸 함수들은 lib 디렉터리에 만든 후 작성한다.
- usePromise Hook은 Promise의 대기 중, 완료 결과, 실패 결과에 대한 상태를 관리하며, 의존 배열을 파라미터로 받아 온다.
- 받아온 deps 배열은 usePromise에서 의존 배열로 설정한다.

```jsx
const NewsList = ({ category }) => {
  const [loading, response, error] = usePromise(() => {
    const query = category === "all" ? "" : `&category=${category}`;
    return axios.get(
      `https://newsapi.org/v2/top-headlines?country=kr${query}&apiKey=f45fa97679204f119d4d91f9f341c2fb`
    );
  }, [category]);

  if (loading) {
    return <NewsListBlock>대기 중...</NewsListBlock>;
  }

  if (!response) {
    return null;
  }

  if (error) {
    return <NewsListBlock>에러 발생!</NewsListBlock>;
  }

  const { articles } = response.data;
  return (
    <NewsListBlock>
      {articles.map((article) => (
        <NewsItem key={article.url} article={article} />
      ))}
    </NewsListBlock>
  );
};
```

- 코드가 이전보다 훨씬 간결해진 것을 확인할 수 있다.
- 이와 같이 커스텀 훅을 만들어 사용하면 좋은 코드를 만들어 갈 수 있다.
