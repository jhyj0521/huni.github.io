---
title: "0228 - 0306"
tag: TIL
category: TIL
excerpt: ""
---

## 0228

# 잉여 속성 체크의 한계 인지하기

타입이 명시된 변수에 객체 리터럴을 할당하거나 함수에 매개변수로 전달할 때, 타입스크립트는 해당 타입의 속성이 있는지, 그리고 그 외의 속성은 없는지를 확인한다.

```typescript
interface Room {
  numDoors: number;
  ceilingHeightFt: number;
}

const r: Room = {
  numDoors: 1,
  ceilingHeightFt: 10,
  elephant: "present",
  // 오류 - 'Room' 형식에 'elephant'가 없습니다.
};
```

- 구조적 타이핑 관점으로 생각해보면 오류가 발생하지 않아야 한다.
- 임시 변수 obj를 선언하고 Room 타입에 할당하는 것은 가능하다.

```typescript
const obj = {
  numDoors: 1,
  ceilingHeightFt: 10,
  elephant: "present",
};

const r: Room = obj;
// 정상
```

- obj 타입은 Room 타입의 부분 집합을 포함하므로, Room에 할당 가능하며 타입 체커도 통과한다.
- 첫 번째 예제에서는, 구조적 타입 시스템에서 발생할 수 있는 중요한 종류의 오류를 잡을 수 있도록 '잉여 속성 체크'라는 과정이 수행되었다.
- 그러나 잉여 속성 체크 역시 조건에 따라 동작하지 않는다는 한계가 있고, 통상적인 할당 가능 검사와 함께 쓰이면 구조적 타이핑이 무엇인지 혼란스러워질 수 있다.
- 잉여 속성 체크가 할당 가능 검사와는 별도의 과정이라는 것을 알아야 타입스크립트 타입 시스템에 대한 개념을 정확히 잡을 수 있다.

## 의도와 다르게 작성된 코드

```typescript
interface Options {
  title: string;
  darkMode?: boolean;
}

function createWindow(options: Options) {
  if (options.darkMode) {
    setDarkMode();
  }
}

createWindow({
  title: "Spider Solitaire",
  darkmode: true,
  // 'Options' 형식에 'darkmode'가 없습니다.
});
```

위와 같은 코드를 실행하면 런타임에 어떠한 종류의 오류도 발생하지 않는다.  
그러나 타입스크립트가 알려주는 오류 메시지처럼 의도한 대로 동작하지 않을 수 있다.  
Options 타입은 범위가 매우 넓기 때문에, 순수한 구조적 타입 체커는 이런 종류의 오류를 찾아내지 못한다.  
왜냐하면 타입스크립트 타입 시스템은 구조적 타이핑을 따르기에 string 타입인 title 속성과 '또 다른 어떤 속성'을 가지는 모든 객체는 Options 타입의 범위에 속하기 때문이다.

### 잉여 속성 체크

잉여 속성 체크를 이용하면 기본적으로 타입 시스템의 구조적 본질을 해치지 않으면서도 객체 리터럴에 알 수 없는 속성을 허용하지 않음으로써, 문제점을 방지할 수 있다.

```typescript
const intermediate = { darkmode: true, title: "Ski Free" };
const o: Options = intermediate; // 정상
```

다만 위의 예시에서 두 번째 줄은 객체 리터럴이 아니기에 잉여 속성 체크가 적용되지 않고 오류는 사라진다.

잉여 속성 체크는 타입 단언문을 사용할 때도 적용되지 않는다.  
단언문보다 선언문을 사용해야 하는 이유 중 하나이다.

잉여 속성 체크를 원치 않는다면, 인덱스 시그니처를 사용해서 타입스크립트가 추가적인 속성을 예상하도록 할 수 있다.

```typescript
interface Options {
  darkMode?: boolean;
  [otherOptions: string]: unknown;
}
const o: Options = { darkmode: true }; // 정상
```

선택적 속성만 가지는 약한 타입에도 비슷한 체크가 동작한다.

```typescript
interface LineChartOptions {
  logscale?: boolean;
  invertedYAxis?: boolean;
  areaChart?: boolean;
}

const opts = { logScale: true };
const o: LineChartOptions = opts;
// '{ logScale: boolean; }' 유형에 'LineChartOptions' 유형과 공통적인 속성이 없습니다.
```

- 구조적 관점에서 LineChartOptions 타입은 모든 속성이 선택적이므로 모든 객체를 포함할 수 있다.
- 이런 약한 타입에 대해서 타입스크립트는 값 타입과 선언 타입에 공통된 속성이 있는지 확인하는 별도의 체크를 수행한다.
- 그러나 잉여 속성 체크와 다르게 약한 타입과 관련된 할당문마다 수행되어, 임시 변수를 제거하더라도 공통 속성 체크는 여전히 동작한다.
- 잉여 속성 체크는 선택적 필드를 포함하는 Options 같은 타입에 특히 유용한 반면, 적용 범위도 매우 제한적이며 오직 객체 리터럴에만 적용된다.

# 함수 표현식에 타입 적용

타입스크립트에서는 함수 표현식을 사용하는 것이 좋다. 함수 매개변수부터 반환값까지 전체를 함수 타입으로 선언하여 함수 표현식에 재사용할 수 있다는 장점이 있기 때문이다.

## 함수 타입의 장점

함수 타입의 선언은 불필요한 코드의 반복을 줄인다.

예를 들어, 사칙연산을 하는 함수를 작성할 때 반복되는 함수 시그니처를 하나의 함수 타입으로 통합할 수도 있다.

```typescript
type BinaryFn = (a: number, b: number) => number;
const add: BinaryFn = (a, b) => a + b;
...
```

- 만약 라이브러리를 직접 만드는 경우가 있다면, 공통 콜백 함수를 위한 타입 선언을 제공하는 것이 좋다.

시그니처가 일치하는 다른 함수가 있을 때도 함수 표현식에 타입을 적용해 볼 만하다.  
예를 들어, fetch 함수는 특정 리소스에 HTTP 요청을 보내고, response.json()를 사용해 응답의 데이터를 추출한다.  
fetch 함수의 경우 '404 Not Found'가 발생했을 때 reject 하지 않기 때문에 상태 체크를 수행해 줄 checkedFetch 함수를 선언문과 표현식 두 가지 방식으로 작성해보자

```typescript
async function checkedFetch(input: RequestInfo, init?: RequestInit) {
  const response = await fetch(input, init);

  if (!response.ok) {
    throw new Error("Request failed: " + response.status);
  }
  return response;
}

const checkedFetch: typeof fetch = async (input, init) => {
  const response = await fetch(input, init);

  if (!response.ok) {
    throw new Error("Request failed: " + response.status);
  }
  return response;
};
```

- 함수 표현식과 기존의 타입을 typeof로 적용한 경우 타입스크립트가 매개변수 타입을 추론할 수 있게 해 준다.
- 표현식 타입 구문은 checkedFetch의 반환 타입을 보장하기에 throw 대신 return을 사용했다면, 타입스크립트는 그 실수를 잡아낸다.
- 선언문으로 작성한 경우에도 return을 사용하면 오류가 발생하지만, 구현체가 아닌 함수를 호출한 위치에서 오류가 발생한다.
- 함수의 매개변수에 타입 선언을 하는 것보다 함수 표현식 전체 타입을 정의하는 것이 코드도 간결하고 안전하다.
- 다른 함수의 시그니처를 참조하려면 typeof fn을 사용하면 된다.

# 타입과 인터페이스의 차이점 알기

타입스크립트에서 타입을 정의하는 방법은 타입과 인터페이스 두 가지 방법이 존재한다.  
대부분의 경우에는 타입을 사용해도 되고, 인터페이스를 사용해도 된다.  
그러나 타입과 인터페이스 사이에 존재하는 차이를 분명하게 알고, 같은 상황에서는 동일한 방법으로 명명된 타입을 정의해 일관성을 유지해야 한다.

## 비슷한 점

- 명명된 타입은 인터페이스로 정의하든 타입으로 정의하는 상태에는 차이가 없다.
  - 예를 들어, 객체 리터럴로 추가 속성과 함께 할당한다면 동일한 오류가 발생한다.
- 인덱스 시그니처는 인터페이스와 타입에서 모두 사용 가능하다.
- 함수 타입도 인터페이스와 타입에서 모두 사용 가능하다.
- 타입 별칭과 인터페이스는 모두 제너릭이 가능하다.
- 인터페이스는 타입을 확장할 수 있고, 타입은 인터페이스를 확장할 수 있다.

```typescript
interface IStateWithPop extends TState {
  population: number;
}
type TStateWithPop = IState & { population: number };
```

    * IStateWithPop과 TStateWithPop는 동일하다.
    * 여기서 주의할 점은 인터페이스는 유니온 타입 같은 복잡한 타입을 확장하지는 못한다는 것이다.
    * 복잡한 타입을 확장하고 싶다면 타입과 &를 사용해야 한다.

- 클래스를 구현(implements)할 때는, 타입과 인터페이스를 둘 다 사용할 수 있다.

## 다른 점

- 인터페이스는 타입을 확장할 수 있지만, 유니온은 할 수 없다.
- 튜플과 배열 타입도 type 키워드를 이용해 더 간결하게 표현할 수 있다.

```typescript
type Pair = [number, number];
type StringList = string[];

// 인터페이스로 구현 시
interface Tuple {
  0: number;
  1: number;
  length: 2;
}
```

- 그러나 인터페이스로 튜플과 비슷하게 구현하면 튜플에서 사용할 수 있는 concat 같은 메서드들을 사용할 수 없기에 type 키워드로 구현하는 것이 낫다.
- 인터페이스는 타입에 없는 기능이 있는데, 그 중 하나는 보강(augment)이 가능하다는 것이다.

```typescript
interface IState {
  name: string;
  capital: string;
}

interface IState {
  population: number;
}

const wyoming: IState = {
  name: "Wyoming",
  capital: "Cheyenne",
  population: 500,
};
```

- 이처럼 속성을 확장하는 것을 선언 병합이라고 한다. 선언 병합은 주로 타입 선언 파일에서 사용된다.
- 타입스크립트는 여러 버전의 자바스크립트 표준 라이브러리에서 여러 타입을 모아 병합한다.
  - 예를 들어, Array 인터페이스는 `lib.es5.d.ts`에 정의되어 있고 기본적으로 이에 선언된 인터페이스가 사용된다.
  - 그러나 `tsconfig.json`의 lib 목록에 ES2015를 추가하면 타입스크립트는 이에 선언된 인터페이스를 병합한다.
  - 결과적으로 각 선언이 병합되어 전체 메서드를 가지는 하나의 Array 타입을 얻게 된다.

## 결론

- 복잡한 타입이라면 타입 별칭을 사용
- 간단한 객체 타입이라면 일관성과 보강의 관점에서 고려해 볼 것
  - 일관되게 코드베이스에서 작업 중인 문법을 사용
  - 아직 스타일이 확립되지 않은 프로젝트라면 향후 보강 가능성을 고려해 볼 것
  - 어떤 API에 대한 타입 선언을 작성해야 한다면 인터페이스를 사용하는 것이 좋음
  - API가 변경될 때 사용자가 인터페이스를 통해 새로운 필드를 병합 할 수 있어 유용하기 때문
- 프로젝트 내부적으로 사용되는 타입에 선언 병합이 발생하는 것은 잘못된 설계
