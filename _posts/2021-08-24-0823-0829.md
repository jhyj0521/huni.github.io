---
title: "0823-0829"
tag: TIL
category: TIL
---
## 0823
# 31일 차 Sass 



## Sass의 특징
* Sass로 작성된 코드는 브라우저가 해석할 수 없다.
* Sass는 개발에 최적화된 단계, css는 배포에 최적화된 단계
* postcss는 후처리기로 기능을 덧붙이는 역할을 한다.
* css가 점점 강력해지고 있기 때문에 플러그인에 의존하는 형태로 변화할 가능성이 있다.
* Sass와 Scss는 같은 것이다. 문법만 다르다.
	* 대부분 Ruby Sass말고 Node Sass를 사용한다.
-> 점점 Node Sass는 지원하지 않을 것. Dart Sass로 넘어오는 추세

### Dart Sass와 Node Sass의 차이점
* Dart Sass에는 @use와 @forward가 생김
* 나누기 연산에서 더하기나 빼기와 함께 이용하거나, 괄호로 묶어서 사용했었다.
	* Dart Sass에서는 나누기 연산을 허용하지 않는다.
	* sass의 math라는 빌트인 함수를 사용한다.
	* math.div(12px, 2) 이렇게 나누기를 사용한다.


## 설치 및 사용
```json
"scripts": {
    "start": "npm run watch",
    "sass": "sass sass:css",
    "watch": "npm run sass -- --watch"
}
```
* `sass sass:css`는 dart 사스를 이용해서 Sass 폴더 아래 있는 파일을 css로 컴파일하라는 뜻
* watch는 sass 명령어를 재활용한다.
	* sass를 관찰 모드로 실행시킨다는 뜻
* `npm start`를 입력하면 npm run watch가 실행된다.

### 컴파일 시 생기는 map 파일
* 개발할 때는 sourceMapping이 없으면 오류를 난 곳을 찾기가 힘들다.
* 빌드할 때 설정으로 생기지 않게 할 수 있다.

### @use, @forward
dart sass에 새롭게 추가된 기능

* @use는 모듈 형식으로 가져다 쓰겠다는 뜻
	* 모듈을 간단하게 쓰려면 `@use './base a' as b` 로 선언하면 b.변수로 사용 가능
	* `@use './base a' as *`로 쓰면 네임스페이스 없이 접근 가능
* @forward는 파일을 한 곳으로 모아서 내보내주는 역할을 한다.
	* 한 파일 내에서 여러곳에 있는 sass 파일에 접근하려면 @use 명령어를 많이 사용해야 한다. 
	* @forward 명령어로 한 곳의 파일에 sass 파일을 모아두면, 해당 파일만 @use로 받아와서 하나의 네임 스페이스로 변수들이나 mixin, 함수를 사용할 수 있다.

## input 요소 실습
### 인풋 태그 기본 모양 제거
```scss
.form-input__input {
    // 폼 태그는 보통 기본 모양을 없애서 사용한다.
    appearance: none;

    &:focus {
        outline: none;
    }
}
```
* 입력 서식의 기본 스타일 및 아웃라인 제거
* 아웃라인은 추후 border 색상으로 재정의

### function을 활용하여 px을 rem 단위로 변경
```scss
@use 'sass:math';
// 루트 요소 기본 단위 --------------------------------------------------------------- /
$root-value: 16px !default;

// 단위 제거 함수 ------------------------------------------------------------------ /
@function removeUnit($value) {
    @return math.div($value, $value * 0 + 1);
}

// px을 rem 단위로 변경하는 함수 ------------------------------------------------------- /
@function rem($value, $base: $root-value) {
    @return (removeUnit(math.div($value, $base))) * 1rem;
}
```
* dart sass는 나누기 연산시 math.div 내장함수를 사용하는데, 이를 사용하기 위해서는 위에 @use로 가져와야한다.
* 단위가 있는 값이나 없는 값이나 모두 rem 단위로 변경하기 위해서 위와 같이 작성하였다.

### input 태그 크로스 브라우징
```scss
input {
    // 인풋의 x 표시가 나오지 않게 함
    &::-ms-clear,
    &::-webkit-search-cancel-button,
    &::-webkit-search-results-button {
        display: none;
    }

    // 비밀번호에 한해서 눈모양 아이콘이 나오지 않게 함
    &::-ms-reveal {
        display: none;
    }
																					
    // placeholder 스타일
    &::placeholder,
    &::-ms-input-placeholder {
        color: $form-placeholder-color;
    }
}       
```

### checkbox 스타일링 기본
1. checkbox의 기본 스타일을 없앤다.
2. 체크박스 영역에 새로 영역을 지정하고 absolute로 띄운다.
3. 크로스 브라우징 문제때문에 checkbox에 바로 스타일을 입히는 것이 아니라 똑같은 크기의 label에 빈 span 요소를 만들어서 background 이미지를 보여주는 트릭을 사용한다.

### 그 외
* `:not()` 선택자의 경우 IE11 이하를 지원하지 않는다.
* readonly가 있는 속성을 선택하기 위해서는 크로스브라우징을 위해 `[readonly]`처럼 속성 선택자로 선택해야한다.
* sass 구조상 중첩을 사용하지만, 빌드되면 밖으로 내보내서 구체성 점수를 낮추기 위해 @at-root를 활용할 수 있다.
* box-sizing의 기본 값은 버튼은  border-box, a는 content-box이다.



## 0824
# 32일 차 Sass 이용해서 웹카페 프로젝트 진행하기
## 의존성 패키지 모듈
* live-server : 라이브 서버 실행
* htmlhint : HTML 파일에 대한 문법검사를 수행
* chokidar-cli : htmlhint가 watch 옵션을 제공하지 않는 문제를 해결
* sass : Dart Sass 설치
* postcss-normalize : normalize.css
* postcss : postcss를 사용하기 위한 패키지
* autoprefixer : 자동으로 웹브라우저 별 접두사를 생성
* postcss-csso : css 파일 최적화(압축)
* postcss-combine-media-query : 미디어쿼리 병합
* npm-run-all  : 2개 이상의 npm 스크립트 명령을 직렬 또는 병렬로 수행


### span 요소로 햄버거 버튼 디자인해서 활용하기
* absolute top값을 %으로 줘서 위치를 설정한다.
* 여기서 %는 부모의 세로너비의 영향을 받으므로, 원하는 위치에 배치하기 위해서는 자기 기준으로 내린 %만큼 다시 위로 올려줘야 한다.
* reflow를 발생시키지 않기 위해서 올릴 때 transform 속성을 사용해서 -%만큼 Y축으로 올려준다.
* is-active가 붙으면 애니메이션을 동작시키면서 햄버거 버튼을 X자로 바꾸는데 여기서 span을 감싸는 컨테이너에 overflow: hidden과 각 span의 translate 값을 지정해서 문제를 해결했다.
	* 중앙에 있는 span은 화면에서 사라지게 하고, 위 아래 span은 중앙으로 모아서 회전시켜 애니메이션을 만들었다.

### grid 기본 문법
```css
display: grid;
grid-template-columns: repeat(2, 1fr);
grid-template-rows: 50px 50px;
grid-template-areas: 
"logo member"
"logo search";
```
* 그리드를 사용하기 위해서는 우선 열의 크기를 정해줘야 한다.
	* repeat 함수를 지정하여 첫 번째 매개변수에 열의 개수를 넣고, 두 번째 매개변수에 열의 크기를 정한다. 1fr은 균등하게 크기를 나눈다는 것을 뜻한다.
* 행은 50px의 크기로 두 개를 지정하였다.
* grid-template-areas 에는 영역의 행, 열에 맞춰서 이름을 지정할 수 있다.
	* 그리드 아이템에 grid-area: "이름" 을 지정하면 해당 영역에 맞게 매칭되어 배치된다.

    ## 0825
    # 33일 차 Sass 이용해서 웹카페 프로젝트 진행하기
## 알고리즘 문제풀이 
카카오 블라인드 테스트에서 출제된 신규 아이디 추천 문제를 풀었다.   
조건이 많은 문자열 문제였지만 테스트케이스를 돌려보면서 걸리는 항목이 있었다.   
이번 기회에 항상 해야지 하고만 생각했던 정규표현식에 대해 정리하고, 앞으로 문자열 관련 문제를 풀 때 정규표현식을 활용하면 도움이 되겠다는 생각이 들었다.

## 정규 표현식(Regular Expression)
정규 표현식(Regular Expression)은 문자열에서 특정 내용을 찾거나 대체 또는 발췌하는데 사용한다.   
정규 표현식을 생성하는 방법에는 두 가지가 있다.  

1. 정규 표현식 리터럴을 사용하는 방법
2. RegExp 객체의 생성자 함수를 호출하는 방법

정규식 리터럴은 스크립트가 불러와질 때 컴파일된다. 만약 정규식이 상수라면, 이렇게 사용하는 것이 성능을 향상시킨다.   
반면, 생성자 함수를 사용하면 정규식이 실행 시점에 컴파일된다. 정규식 패턴이 변경될 수 있는 경우, 혹은 사용자 입력과 같이 다른 출처로부터 패턴을 가져와야 하는 경우에는 생성자 함수를 사용한다.

### 단순 패턴
단순 패턴은 문자열을 있는 그대로 대응시키고자 할 때 사용된다.  
예를 들어, `/abc/`라는 패턴은 문자열에서 정확히 'abc'라는 문자들이 순서대로 나타나야 대응된다.   
부분 문자열을 포함하고 있더라도, 'abc'를 정확하기 포함하지 않는다면 대응되지 않는다.

### 특수 문자를 사용한 패턴
* 정규식 패턴 안의 `.`은 임의의 문자 한 개를 의미한다.
* 앞선 패턴을 최소 1번 반복하려면 패턴 뒤에 `+` 기호를 붙인다.
* `|` 기호를 사용하면 or의 의미를 가진다.
* `[]`내의 문자는 or로 동작한다.
* 범위를 지정하려면 `[]`내에 `-`를 사용한다.
* `\d`는 숫자를 의미한다. `\D`는 `\d`와 반대로 동작한다.
* `\w`는 알파벳과 숫자를 의미한다. `\W`는 `\w`와 반대로 동작한다.
* `^`는 특정 단어로 시작하는지 검사한다.
* `$`는 특정 단어로 끝나는지 검사한다.
* 이를 활용하여 `/^\d+$/`는 모두 숫자인지 검사하는 패턴이다.
* `\s`는 여러 가지 공백문자를 의미한다. (스페이스, 탭 등)

### 플래그를 사용한 검색
정규식은 플래그를 설정해줄 수 있으며, 이를 통해 쩐역 검색 또는 대소문자 구분 없는 검색을 수행할 수 있다.   
이 플래그들은 각기 사용될 수도 있고 함께 사용될 수도 있고 순서에 구분이 없다.

* g : 전역 검색
* i : 대소문자 구분 없는 검색
* m : 다중행 검색
* s : .에 개행 문자도 매칭 (ES2018)

정규식에 플래그를 포함시킨 문법은 아래와 같다.

```javascript
const regExp = /정규식패턴/플래그들;
```
* 정규식 패턴은 두개의 슬래쉬 안에 작성해야 한다.
* 플래그는 정규식에 합쳐지는 정보다. 이것들은 나중에 추가되거나 제거될 수 없다.

### 정규식에서 쓰이는 메소드
* exec : 대응되는 문자열을 찾는 RegExp 메소드이다. 정보를 가지고 배열을 반환한다. 대응되는 문자열을 찾이 못했다면 null을 반환한다.
* test : 대응되는 문자열을 찾는 RegExp 메소드이다. true나 false를 반환한다.
* match : 대응되는 문자열을 찾는 String 메소드이다. 정보를 가지고 있는 배열을 반환한다. 대응되는 문자열을 찾지 못했다면 -1을 반환한다.
* search : 대응되는 문자열을 찾는 String 메소드이다. 대응된 부분의 인덱스를 반환한다. 대응되는 문자열을 찾지 못했다면 -1을 반환한다.
* replace : 대응되는 문자열을 찾아 다른 문자열로 치환하는 String 메소드이다.
* split : 정규식 혹은 문자열로 대상 문자열을 나누어 배열로 반환하는 String 메소드이다.

### 괄호를 둘러싼 패턴
정규식 패턴에 괄호를 사용하면, 그 부분을 별도로 대응시키면서 대응된 부분을 기억한다.   
예를 들어 `/(a)bc(d)/`는 'abcd'에 대응하면서 'a'와 'd'를 기억한다. 괄호로 감싸진 문자열을 불러오려면, 배열 요소를 사용한다.   

괄호로 감쌀 수 있는 문자의 개수에는 제한이 없다. 반환된 배열은 찾아낸 모든 것들을 갖고 있다.

```javascript
const re = /(a)bc(d)/;
let str = "abcd";
let newstr = str.replace(re, "$2 and $1");
console.log(newstr);

// 결과
d and a
```

정규 표현식을 잘 활용한다면 많은 문제를 해결할 수 있다.  
예를 들어 이번 문제를 풀면서 빈 문자열인 경우 다른 텍스트로 대체하는 방법을 찾지 못했었는데, `문자열.replace(/^$/, '대체문자')` 방식을 이용하면 간단하게 해결할 수 있었다.   
다만 그렇게 풀었을 때의 문제점은 정규 표현식의 다양한 활용법에 대해 익숙하지 않은 사람들이 봤을 때에 가독성이 떨어질 수 있다는 점인대 이 부분에 대해서는 조금 더 고민해봐야겠다.


## core Web Vital
훌륭한 UX를 제공하기 위한 지표에 대한 지침을 제시하는 Google 이니셔티브이다.    
사용 경험에 영향을 미치는 다양한 측정 가능한 값들 중에서 구글이 중요하다 강조하는 아래의 3가지 매트릭스를 말한다.    
이 3가지 매트릭스에 굳이 코어라는 단어를 붙여 부르는 이유는 웹사이트에 방문하는 유저들의 경험을 좌우하는 여러 요소 중 가장 기본이자 핵심 지표이기 때문이다.

### LCP (Largest Contentful Paint)
* 인식되는 로딩 속도를 측정하는 항목으로, 뷰포트에 포함된 모든 HTML 요소들이 브라우저 화면에서 렌더링 완료되는데까지 걸리는 시간의 길이를 말한다.
* 2.5초 이하인 경우 좋음, 2.5초 이상 4초 이하인 경우 개선이 필요, 4초 이상인 경우 나쁨으로 평가
* 이미지나 비디오같은 요소에 대한 최적화를 동해 지표 개선을 할 수 있다.

### FID (First Input Display)
* 웹 페이지와 사용자간의 상호작용에 대한 항목 
	* ex) 웹 사이트에서 스크롤, 클릭 등 여러 상호작용에 대한 응답
* 이 지표가 중요하게 보는 것은 요청 받은 액션을 처리하는데 걸리는 시간이 아니라 브라우저에서 다음 액션이 가능하게 되는 시간까지의 길이(입력 지연을 시키는 시간)이다.
* 사용자 환경에서 사용자가 체감하는 지표이기 때문에 테스트 환경에서 확인할 수 있는 지표가 아니다.
	* 구글은 다양한 테스트 환경에서 측정 가능한 총 차단시간 (Total Blocking Time)을 FID 지표를 대신해서 측정하라고 말한다.
	* TBT는 페이지로드 중 발생하는 입력 작업 불가능 시간의 합계이므로 항상 낮을수록 좋다.
* 100ms 이하인 경우 좋음, 100ms 이상 300ms 이하인 경우 개선 필요, 300ms 이상인 경우 나쁨으로 평가

### CLS (Cumulative Layout Shift)
* 시각적 안정성을 측정하는 항목  
* 어떤 페이지에 들어갔을 때 갑작스럽게 발생하는 레이아웃 이동의 정도를 합산 이동 거리라는 개념을 도입해서 만들어낸 지표
* 0.1 이하인 경우 좋음, 0.1 이상 0.25 이하인 경우 개선 필요, 0.25 이상인 경우 나쁨으로 평가

### 기타 요소
* 모바일 친화성 : 웹 페이지가 모바일 브라우징에 최적화 되어있는가에 대한 평가
* 세이프 브라우징 : 페이지에 방문자의 의도를 속이려는 콘텐츠가 있는가? 혹은 악성 코드나 애드 웨어등이 심겨져 있지 않은 가에 대한 평가
* HTTPS : 웹 사이트가 HTTPS를 제공하고 있는 가에 대한 평가
* 방해요소 : 콘텐츠 소비를 방해하는 전면 광고와 같은 방해 요소가 있는가에 대한 평가

### 왜 SEO에 중요한가?
구글 연구 결과에 따르면 코어 웹 바이탈의 기준을 충족한 웹 페이지의 경우 방문자가 사이트에서 이탈할 가능성이 24%나 낮다고 한다.    
소비자 피드백을 중시하는 랭킹 알고리즘이라 할 수 있는 랭크 브레인을 고려하면 UX를 개선하기 위해 이용되는 코어 웹 바이탈 매트릭스는 SEO에서 중요한 의미를 갖는다고 말할 수 있다.


## SVG 스프라이트
SVG 이미지를 스프라이트 이미지로 사용하기 위해서는 기존의 jpg, png 스프라이트 이미지들과 사용법이 다르다.   
우선 Spritebot 서비스를 이용해서 SVG 스프라이트 이미지를 만든다.   
생성된 svg 파일을 열어보면 구별 가능한 ID를 가진 심볼 그래픽을 볼 수 있다.   
Spritebot이 생성한 스프라이트 이미지를 사용하는 방법은 2가지이다.

1. 스프라이트 이미지를 로드 한 후 사용법
생성된 파일을 이미지 폴더에 넣은 후, `<svg><use /></svg>` 요소를 사용해 이미지를 로드한다.    
이 방법은 SVG 심볼을 재사용 하는 방법으로 필요할 경우 SVG 코드를 변경하거나, 애니메이션을 적용하는 등 활용도가 높다.

```html
<svg><use xlink:href="./이미지-폴더/sprite-sheet.svg#icon-pricetag" /></svg>
```

2. 스프라이트 이미지를 HTML 문서에 포함할 경우 사용법
HTML 문서에 SVG 스프라이트 코드를 삽입해서 사용할 경우, 먼저 불필요한 속성 `xmlns`를 제거하고 적절한 ID를 설정한다.    
그리고 화면에 렌더링 되지 않도록 `hidden`속성을 `<svg>` 요소에 추가한다.

```html
<svg hidden id="svg-sprites">
    <symbol id="icon-network" viewBox="0 0 64 64">...</symbol>
    <symbol id="icon-onlinecart" viewBox="0 0 64 64">...</symbol>
    <symbol id="icon-presentation3" viewBox="0 0 64 64">...</symbol>
    <symbol id="icon-pricetag" viewBox="0 0 64 64">...</symbol>
    <symbol id="icon-safe" viewBox="0 0 64 64">...</symbol>
</svg>
```
* 동일한 문서에 심볼이 있으니 심볼 ID를 사용해 바로 문서에서 재사용 가능하다.
	* 앞서 이미지를 첨부한 경우보다 코드가 간결해지는 장점이 있다.
* 하지만, 여러 문서에서 동일한 SVG 스프라이트 이미지를 사용하려면 이 방법은 좋은 방법이라고 볼 수 없다.

```html
<svg><use xlink:href="#icon-pricetag" /></svg>
```


## 메인 영역 실습
### focus-visible & focus-within
* focus-within은 포커스를 받는 요소의 부모 요소에서 지정하는 가상 클래스 선택자로 자식에 있는 요소가 포커스 받았을 때 부모에게 스타일을 지정해줄 수 있다.
* focus-visible은 포커스를 받는 요소에게 지정하는 가상 클래스 선택자로 키보드로 접근한 포커스만 스타일이 적용된다.

### 속성 선택자
* `선택자[속성 *= '값']` : 값을 포함하는 요소
* `선택자[속성 ^= '값']` : 값으로 시작하는 요소
* `선택자[속성 $= '값']` : 값으로 끝나는 요소

### 반응형 이미지
* 부모 컨테이너 width를 %로 주고 margin을 좌우로 auto로 준다.
* 이미지에 max-width를 100%로 주고  height는 auto로 준다.

### 반응형 iframe
* 반응형 iframe을 사용하기 위해서는 iframe을 감싸는 컨테이너가 필요하다.
* iframe의 위치는 absolute로 지정하여 부모 컨테이너로부터 `top: 0; left: 0;` 위치에 있게 한다.
* 부모 컨테이너의 width는 100% height는 0으로 지정하고 원하는 해상도비율만큼 padding-top을 준다.
* 그리고 iframe의 높이와 너비를 100%로 지정하면 원하는 비율이 나오게 된다.

### 사용자 정의 데이터 속성
* html 속성으로 `data-`로 시작하는 값을 작성하고 이를 css 가상 요소 선택자를 활용하여 사용할 수 있다.
* 가상 요소 선택자의 content 값으로 attr(사용자정의데이터속성명)을 입력하면 해당하는 값을 사용 가능하다.

### 커스텀 셀렉터
```scss
@custom-selector :--변수 클래스1, 클래스2, 클래스3

:--변수 {
    // 스타일
}
```
* 위와 같이 지정하면 클래스 1,2,3을 `:--변수` 키워드 한 번으로 사용 가능하다.
* 아직 안정적인 버전이 아니라서 웹팩의 postcss-preset-env 값을 변경해줘야 한다.
* post-preset-env : 플러그인을 모아두는 곳

### 그 외
* 본문 중간에 영어로 된 단어가 있는 경우 `lang="en"` 속성 설정을 고려한다.
* 아웃라인 스타일 작성하기에 border은 레이아웃이 무너질 수 있으므로 shadow로 작성하는 것이 더 좋다.
* font-size 속성에 `clamp(최소값, 기본값, 최대값)`을 이용해서 폰트 사이즈를 반응형으로 사용할 수 있다.


