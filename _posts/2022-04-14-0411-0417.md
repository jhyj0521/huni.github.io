---
title: "0411 - 0417"
tag: TIL
category: TIL
excerpt: ""
---

## 0411

# 이펙티브 타입스크립트 스터디 회고

약 9주간의 함께한 스터디가 모두 마무리되었다.  
생각보다 책의 내용이 쉽지 않았고, 예제를 모두 이해해가며 하려다보니 도중에 어려움이 많았지만 함께 스터디했기에 짧은 시간 내에 책을 마무리할 수 있었던 것 같다.  
이번 스터디를 통해 얻은 것은 다음과 같다.

- 타입스크립트의 컨셉과 기본 개념에 대한 이해
- 시간을 정해놓고 일정 분량을 학습함으로써 얻은 학업 성취도
- 타입스크립트를 더 효과적으로 사용하기 위한 여러 기법들

하지만 1회독 만으로 책을 완전히 내재화시키지는 못한 것 같고, 앞으로 꾸준히 복습하며 내재화시켜야한다고 느끼고 있다.

이번 스터디를 잘 마무리하기까지 스터디장님의 역할이 컸다고 생각한다.  
이번 스터디와 저번에 진행했던 프로젝트를 통해 '함께'의 즐거움과 매력을 알게 되었고, 나 역시 다른 사람들에게 좋은 영향을 미치는 사람으로 나아가고 싶다는 목표를 가지게 되었다.  
경험을 충분히 했으니, 이제는 '어떻게' 더 큰 시너지를 낼 것인지에 대한 고민을 할 필요가 있을 것 같다.

## 팀원들과의 회고

![회고1](https://user-images.githubusercontent.com/61184798/163386962-13717da8-e383-479e-948a-baabd11105f1.png)
![회고2](https://user-images.githubusercontent.com/61184798/163386967-55bec75a-283a-4baa-b2e3-4c6d428ecdbe.png)
![회고3](https://user-images.githubusercontent.com/61184798/163386972-86341cf7-b601-4df5-9681-a31172c88611.png)
![회고4](https://user-images.githubusercontent.com/61184798/163386978-e81ac845-5fc8-47b8-b116-7daf50b91afc.png)

<br />
<br />
<br />

## 0412

# useCallback, useMemo, React.memo

```jsx
const Counter = ({ initialCount = 0, step = 1 }) => {
  const [count, setCount] = useState(initialCount);
  useEffect(() => {
    count < 0 && setCount(0);
  }, [count]);

  const [renderingTester, setRenderingTester] = useState(0);
  useEffect(() => {
    setTimeout(() => setRenderingTester(renderingTester + 1), 3000);
  }, [renderingTester]);

  const increment = () => {
    setCount(count + step);
  };

  const decrement = () => {
    setCount(count - step);
  };

  return (
    <CountContainer
      count={count}
      onIncrement={increment}
      onDecrement={decrement}
    />
  );
};
```

코드를 위와 같이 작성하면 불필요한 리렌더링이 발생한다.  
함수 컴포넌트는 렌더링 될 때마다 몸체가 다시 실행되므로 컨텍스트를 기억하기 위해서는 훅을 사용한다.  
그리고 상위 컴포넌트는 기억된 상태 또는 업데이트 함수를 하위 컴포넌트에 전달한다.

상태는 훅에 의해 기억되어 관리되니 문제되지 않지만, 함수 내부에 선언된 함수는 매번 렌더링 될 때 마다 다시 정의되므로 문제가 된다.  
정확히 말하면 props로 전달되는 함수인 경우, 자식 컴포넌트에서 props가 변경되었기에 자식 컴포넌트까지 불필요하게 리렌더링이 발생한다.

## 문제 해결 방법

하위 컴포넌트에 전달되는 함수를 기억해두면, 컴포넌트 업데이트 시 다시 렌더링 될 때마다 기억된 함수를 사용해 문제를 해결할 수 있다.  
전달될 함수를 기억하려면 다음의 훅 중 하나를 사용한다.

### useCallback()

기억해야 할 데이터 타입이 함수인 경우, `useCallback()` 훅을 사용한다. 이는 메모이제이션된 콜백을 반환한다.
이 훅은 `useEffect()` 훅과 마찬가지로 종속성 배열을 통해 조건에 따라 기억 여부를 재설정할 수 있다.  
이는 불필요한 렌더링을 방지하기 위해 자식 컴포넌트에 콜백을 전달할 때 유용한다.  
콜백 안에서 참조되는 모든 값은 의존성 값의 배열에 나타나야 한다.

```javascript
const increment = useCallback(() => {
  setCount(count + step);
}, [count, step]);

const decrement = useCallback(() => {
  setCount(count - step);
}, [count
```

### useMemo()

자바스크립트의 데이터 타입을 기억해야 할 때 사용한다. 기억해야 할 타입이 함수인 경우 `useCallback()`에 비해 코드 가독성이 현저히 떨어지므로, 함수를 기억해야 할 경우는 `useCallback()`을 사용하자.  
배열이나 객체를 하위 컴포넌트로 전달하는 경우 불필요한 렌더링을 방지하기 위해 사용하면 유용하다.  
또한, 이 최적화는 모든 렌더링 시의 고비용 계산을 방지하게 해 준다. 같은 값을 얻는 데 동기적으로 오래 걸리는 함수를 반복해서 실행하지 않고, 메모된 이전 값을 그대로 사용하여 좀 더 성능을 개선할 수 있다.  
useMemo로 전달된 함수는 렌더링 중 실행되므로, 렌더링 중에서 하지 않는 것은 이 함수 내에서 하면 안 된다.

```javascript
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

### React.memo

하지만 위와 같이 같은 함수를 전달해도 불필요한 리렌더링 문제는 해결되지 않는다.  
그 이유는 상위 컴포넌트가 다시 렌더링 될 때, 하위 컴포넌트 또한 다시 렌더링 되기 때문이다.

해당 문제를 해결하려면 컴포넌트도 기억하고 있어야 한다. 상위 컴포넌트가 다시 렌더링 되어도, 하위 컴포넌트에 전달한 props는 동일하고, 이전 컴포넌트가 기억되고 있으니 불필요한 렌더링 문제를 막을 수 있다.  
컴포넌트를 기억하려면 memo와 useMemo 훅을 사용할 수 있다.

React.useMemo() 훅을 사용할 경우 함수 컴포넌트 내부에서 기억해야 할 값을 훅으로 감싼 후 반환합니다. 컴포넌트는 다시 렌더링 되겠지만, 기억된 값이 반환되므로 성능 저하 문제를 해결할 수 있습니다.

```jsx
const CountContainer = ({ count, onIncrement, onDecrement, ...restProps }) => {
  return useMemo(
    () => (
      <Container {...restProps}>
        <CountButton
          label="카운트 감소"
          size={40}
          flex="0 0 40"
          disabled={count <= 0}
          onUpdate={onDecrement}
        >
          -
        </CountButton>

        <CountDisplay count={count} />

        <CountButton
          label="카운트 증가"
          size={40}
          flex="0 0 40"
          onUpdate={onIncrement}
        >
          +
        </CountButton>
      </Container>
    ),
    [count, onIncrement, onDecrement, restProps]
  );
};
```

React.memo는 고차 컴포넌트이다.  
React.memo를 사용하면 컴포넌트의 props가 변경되지 않는 이상 기억된 컴포넌트를 사용하게 된다.  
호출하고 결과를 메모이징하도록 래핑하여 경우에 따라 성능 향상을 누릴 수 있다.  
즉, 컴포넌트가 필요한 경우에만 렌더링하게 되고, 그 외에는 렌더링 자체를 발생시키지 않는다.

이 메서드는 오직 성능 최적화를 위해서 사용해야 한다. 렌더링을 방지하기 위해서 사용하면 안 된다.

그러나 대부분의 경우 불필요한 렌더링 최적화에 너무 많은 시간을 쏟아서는 안 된다. 리액트는 매우 빠르며 최적화보다 더 나은 시간을 할애할 수 있도록 생각할 수 있는 일이 너무 많다.  
결론적으로 최적화에는 비용이 따르며 해당 비용 관련 이점을 알아야 하고, 최적화를 하기 이전에 측정을 해 봐야 한다.
