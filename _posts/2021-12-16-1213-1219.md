---
title: "1213 - 1219"
tag: TIL
category: TIL
excerpt: ""
---

## 1213

# 리액트 수업 8일 차

## Asset Modules

**참고**  
[webpack.kr/guides/asset-modules/](https://webpack.kr/guides/asset-modules/)

webpack 5 이전에는 아래의 로더를 사용하는 것이 일반적

- file-loader : 파일을 출력 디렉터리로 내보낼 때
- url-loader : 파일을 data URI 형식으로 번들에 인라인 추가할 때

### data URI

- 이미지 등의 외부 바이너리 파일을 웹페이지에 인라인으로 넣기 위해 사용
- 외부 데이터를 별도의 파일로 두지 않고 HTML 파일로 관리할 수 있음
- 요청 수를 줄여 빠른 전송 효과를 볼 수 있음
- base64 인코딩의 추가적인 작업으로 인해 용량이 아닌 메모리 및 처리시간 등으로 인한 성능 저하가 단점이다.

그러나 webpack 5에서는 새로운 모듈 유형이 추가됨.

```javascript
module: {
  rules: [
    // assets
    {
      test: /\.(jpe?g|gif|png|webp|bmp|svg)$/,
      type: "asset",
      parser: {
        dataUrlCondition: {
          maxSize: 4 * 1024, // 4kb
        },
      },
    },
  ];
}
```

- asset/resource는 별도의 파일을 내보내고 URL을 추출함. 과거 file-loader처럼 동작
- asset/inline은 에셋의 data URI를 내보냄. 이전에는 url-loader를 사용하여 처리함
- asset만 지정해주면 파일 크기가 8kb 이하일 때는 data URI를, 이상일 때는 별도의 파일 내보내기 중에서 자동으로 선택함.
- 빌드했을 때는 8kb 이상의 파일만 내보내진다.
- dataUrlCondition을 사용해서 8kb 기준 값을 변경할 수 있다.

### 이미지를 특정 디렉토리 안에 특정 이름으로 내보내는 설정

```javascript
// config.dev.js
output: {
  ...
  assetModuleFilename: 'assets/[name].[contenthash][ext]',
},
```

- assets 폴더 내에 파일이름.hash값.확장자명 순으로 파일을 내보낸다.
- 여기까지 설정하면 리액트 컴포넌트 단위로 에셋을 설정할 수 있다. 어차피 빌드하면 내보내지기 때문에!

## A11yHidden 컴포넌트

UI 화면에는 표시하지 않지만, 스크린 리더 사용자에게 정보를 제공할 수 있는 컴포넌트

### 스타일 코드

```css
.a11yHidden {
  overflow: hidden;
  position: absolute;
  clip: rect(1px, 1px, 1px, 1px);
  clip-path: circle(0);
  width: 1px;
  height: 1px;
  margin: -1px;
  white-space: nowrap;
}

caption.a11yHidden {
  position: static;
}

.a11yHidden.focusable:focus {
  overflow: initial;
  position: static;
  clip: auto;
  clip-path: unset;
  width: initial;
  height: initial;
  margin: initial;
  white-space: initial;
}
```

### 재사용 가능한 컴포넌트 만들기

```javascript
import "./A11yHidden.css";
import React from "react";
import { classNames } from "../../utils";

export function A11yHidden({ as, className, focusable, ...restProps }) {
  return React.createElement(as, {
    className: classNames(
      "a11yHidden",
      {
        focusable: focusable,
      },
      className
    ),
    ...restProps,
  });
}

A11yHidden.defaultProps = {
  as: "span",
  className: "",
  focusable: false,
};
```

- a11yHidden 컴포넌트는 다양한 태그에 사용될 수 있으므로 독립적으로 동작하기 위해서는 태그 이름을 넘겨줘야 한다.
- 태그를 JSX로 as로 받아서 렌더링하면 그냥 태그 이름이 as인 컴포넌트가 생성된다.
- 위와 같이 react api인 createElement를 사용하면 원하는대로 동작하게 할 수 있다.
- 클래스는 기존에 작성된 것이 덮어써지지 않도록 주의해야 한다.

### JSX로 재사용 가능한 컴포넌트 만들기

```javascript
export function A11yHidden({
  as: ComponentName,
  className,
  focusable,
  ...restProps
}) {
  return (
    <ComponentName
      className={classNames("a11yHidden", { focusable }, className)}
      {...restProps}
    />
  );
}
```

- JSX 방식으로 리턴하고 싶다면 위와 같이 as에 uppercase로 시작하는 별칭을 주어서 사용하면 원하는대로 작동한다.
- 컴포넌트 타입이름을 바꿀때 JSX는 소문자가 아니어야 한다.  
  -> 구조분해 할당해서 별칭 이름 할당하는 방식으로 하면 해결이 된다.

## postcss 설정

- postcss는 sass와 다르게 표준이다!  
  `npm i -D postcss postcss-loader postcss-preset-env`

```javascript
// postcss.config.js
module.exports = {
  plugins: [
    [
      "postcss-preset-env",
      {
        stage: false, // 0 ~ 4
        browsers: "default, > 5% in KR, ie 10-11",
        autoprefixer: {
          grid: true,
        },
        features: {
          "nesting-rules": true,
          "custom-properties": true,
          "custom-selectors": true,
          "color-functional-notation": true,
        },
      },
    ],
  ],
};
```

- stage는 0~4까지 존재하는데, false로 지정하면 기존에 잘 안되던 문제를 해결할 수 있다는 답변이 있길래 false로 지정했다.

```javascript
// .browserslistrc
defaults
> 5% in KR
not dead
ie 11
```

- 브라우저 지원 범위 설정

```javascript
// config.dev.js
{
  test: /\.css$/i,
  use: [
    'style-loader',
    {
      loader: 'css-loader',
      options: {
        importLoaders: 1,
        sourceMap: true,
      },
    },
    {
      loader: 'postcss-loader',
      options: {
        sourceMap: true,
      },
    },
  ],
},
```

## Sass 설정

`npm i -D sass sass-loader`

```javascript
// config.dev.js
{
  test: /\.(css|s[ac]ss)$/i,
  use: [
    'style-loader',
    {
      loader: 'css-loader',
      options: {
        importLoaders: 2,
        sourceMap: true,
      },
    },
    {
      loader: 'postcss-loader',
      options: {
        sourceMap: true,
      },
    },
    {
      loader: 'sass-loader',
      options: {
        sourceMap: true,
      },
    },
  ],
},
```

- importLoaders는 CSS로더 이전에 적용할 로더의 허용수를 설정

### jest 설정 변경

```javascript
module.exports = {
  ...
	moduleNameMapper: {
      '\\.s?[ac]ss$': 'identity-obj-proxy',
  },
}
```

## svgr 설정

`npm i -D @svgr/webpack`

- svg 파일을 모듈로 불러와서 내보내주는 형태
- html에 svg를 삽입할 때, 컴포넌트를 계속해서 만들지 않기 위해 사용하는 플러그인

```javascript
// config.dev.js
// create-react-app 툴체인과 동일한 방식
{
  test: /\.svg$/i,
  issuer: /\.jsx?$/,
  use: [
    {
      loader: '@svgr/webpack',
      options: {
        prettier: false,
        titleProp: true,
        svgo: true,
      },
    },
    'url-loader',
  ],
},
```

- url 로더를 활용한 방법. cra 툴체인과 동일한 방식

```javascript
// config.dev.js
//      Webpack v5부터 사용 가능한 방식
{
  test: /\.svg$/i,
  oneOf: [
    {
      issuer: /\.jsx?$/,
      resourceQuery: /react/, // *.svg?react
      use: [
        {
          loader: '@svgr/webpack',
          options: {
            prettier: false,
            titleProp: true,
            svgo: true,
          },
        },
      ],
    },
    {
      type: 'asset',
      parser: {
        dataUrlCondition: {
          maxSize: 40 * 1024, // 40kb
        },
      },
    },
  ],
},
```

```javascript
// App.js
import ReactLogo from "../../assets/react.svg?react";
import reactLogoPath from "../../assets/react.svg";

export default function App({ greetingMessage }) {
  return (
    <div className="app">
      <img src={reactLogoPath} alt="리엑트" />
      <ReactLogo title="React UI Library" />
      <h1>{greetingMessage}</h1>
    </div>
  );
}
```

- 위와 같이 설정하면 ?파일이름을 뒤에 붙였을 때는 컴포넌트, 그냥 가져왔을 때는 data URI방식으로 동작한다.

<br />
<br />

## 1214

# 모의 코딩테스트 10회 회고

실전 코딩 테스트 이전 마지막 모의 테스트!  
약 1분을 남기고 모든 문제를 해결했다. 이로서 4연속 모의 코딩테스트는 만점이다.  
그런데 완벽하게 풀지는 못한 것 같다는 생각이 들어 그리 후련하지는 않다.  
이게 곧 다가올 실전 테스트에 약간은 떨리기도 하지만, 긴장하지만 않고 하던대로 한다면 좋은 결과가 있을 것이라고 생각한다.

## Partition Array into Disjoint Intervals

```javascript
var partitionDisjoint = function (nums) {
  const n = nums.length;
  const minR = Array(n).fill(0);
  minR[n - 1] = nums[n - 1];

  for (let i = n - 2; i >= 0; i--) {
    minR[i] = Math.min(minR[i + 1], nums[i]);
  }

  let currentMax = nums[0];
  for (let i = 1; i < n; i++) {
    currentMax = Math.max(currentMax, nums[i - 1]);
    if (currentMax <= minR[i]) return i;
  }
};
```

- O(n)으로 풀기 위해서는 추가로 특정 배열을 작업해줘야만 했다.
- minR은 우측부터 현재 인덱스까지의 최솟값을 저장하는 배열이다.
- 인덱스 1부터 n전까지 최댓값을 구하고, 해당 최댓값이 minR의 i번째값보다 작거나 같다면, i-1까지의 모든 수가 minR의 i번째부터의 최솟값보다 작다는 의미이므로 i를 반환해 값을 구했다.

## Prison Cells After N Days

```javascript
var prisonAfterNDays = function (cells, n) {
  let tmp = [...cells];
  let answer = Array(8).fill(0);
  const cnt = n % 14 ? n % 14 : 14;

  for (let i = 0; i < cnt; i++) {
    for (let j = 1; j <= 6; j++) {
      answer[j] = tmp[j - 1] === tmp[j + 1] ? 1 : 0;
    }
    tmp = [...answer];
  }
  return answer;
};
```

- 총 8개의 셀 중, 맨 끝 두 개는 0이기 때문에 총 경우의 수는 64가지였다.
- 입력값이 일억이었기에 이분탐색으로 해결하거나, 일정한 규칙이 있을 것이라고 판단하였다.
- 이분탐색을 사용하기는 어렵다고 생각해서 일정한 규칙을 찾은 결과 14번마다 반복된다는 사실을 깨닫게 되었다.
- 반복 횟수를 14로 나눈 나머지만큼 반복하여 문제를 해결했다.

## 가장 밸런스 좋은 팀 구성

```javascript
function solution(nums) {
  let answer = Number.MAX_SAFE_INTEGER;
  const n = nums.length;
  const total = nums.reduce((acc, cur) => acc + cur, 0);
  const ch = Array(n).fill(0);

  function DFS(L, s, t, sum1, sum2) {
    if (L === 6) {
      const arr = [sum1, sum2, total - sum1 - sum2];
      answer = Math.min(answer, Math.max(...arr) - Math.min(...arr));
    } else if (L >= 3 && L < 6) {
      for (let i = t; i < n; i++) {
        if (ch[i] === 0) {
          ch[i] = 1;
          DFS(L + 1, s, i + 1, sum1, sum2 + nums[i]);
          ch[i] = 0;
        }
      }
    } else {
      for (let i = s; i < n; i++) {
        ch[i] = 1;
        DFS(L + 1, i + 1, t, sum1 + nums[i], sum2);
        ch[i] = 0;
      }
    }
  }
  DFS(0, 0, 0, 0, 0);

  return answer;
}
```

- 발상을 조금 바꿔서 한 DFS 내에서 두 개의 조합을 구하는 방법을 고려해봤다.
- 기존 조합 방식 + 체크 배열을 이용해서 중복되지 않은 두 조합을 구하면 나머지 한 팀은 총 값 - 두 조합 값 이므로 이를 통해 정답을 찾았다.

## 해석 가능한 가지 수 구하기

```javascript
function solution(s) {
  const len = s.length;
  const dy = Array(len).fill(0);

  function DFS(L) {
    if (dy[L] > 0) return dy[L];
    if (s[L] === "0") return 0;
    if (L === len - 1) return 1;
    if (L === len - 2) {
      if (s[L + 1] === "0") return 1;
      else if (+s.substring(L, L + 2) <= 26) return 2;
      else return 1;
    }
    if (+s.substring(L, L + 2) <= 26) {
      return (dy[L] = DFS(L + 1) + DFS(L + 2));
    } else {
      return (dy[L] = DFS(L + 1));
    }
  }

  return DFS(0);
}
```

- a-z까지 1-26으로 해석되는 문자열의 해석 가능한 가지 수를 구하는 문제
- 메모이제이션 기법을 이용해 값을 저장하고 반환하는 방식으로 효율성을 해결했다.
- 그 외에 마지막 길이면 1을, 현재 문자가 0이면 0을 그 외에도 분기 처리하여 적절한 값을 반환해서 문제를 해결했다.
