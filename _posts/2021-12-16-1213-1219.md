---
title: "1213 - 1219"
tag: TIL
category: TIL
excerpt: ""
---

## 1213

# 리액트 수업 8일 차

## Asset Modules

**참고**  
[webpack.kr/guides/asset-modules/](https://webpack.kr/guides/asset-modules/)

webpack 5 이전에는 아래의 로더를 사용하는 것이 일반적

- file-loader : 파일을 출력 디렉터리로 내보낼 때
- url-loader : 파일을 data URI 형식으로 번들에 인라인 추가할 때

### data URI

- 이미지 등의 외부 바이너리 파일을 웹페이지에 인라인으로 넣기 위해 사용
- 외부 데이터를 별도의 파일로 두지 않고 HTML 파일로 관리할 수 있음
- 요청 수를 줄여 빠른 전송 효과를 볼 수 있음
- base64 인코딩의 추가적인 작업으로 인해 용량이 아닌 메모리 및 처리시간 등으로 인한 성능 저하가 단점이다.

그러나 webpack 5에서는 새로운 모듈 유형이 추가됨.

```javascript
module: {
  rules: [
    // assets
    {
      test: /\.(jpe?g|gif|png|webp|bmp|svg)$/,
      type: "asset",
      parser: {
        dataUrlCondition: {
          maxSize: 4 * 1024, // 4kb
        },
      },
    },
  ];
}
```

- asset/resource는 별도의 파일을 내보내고 URL을 추출함. 과거 file-loader처럼 동작
- asset/inline은 에셋의 data URI를 내보냄. 이전에는 url-loader를 사용하여 처리함
- asset만 지정해주면 파일 크기가 8kb 이하일 때는 data URI를, 이상일 때는 별도의 파일 내보내기 중에서 자동으로 선택함.
- 빌드했을 때는 8kb 이상의 파일만 내보내진다.
- dataUrlCondition을 사용해서 8kb 기준 값을 변경할 수 있다.

### 이미지를 특정 디렉토리 안에 특정 이름으로 내보내는 설정

```javascript
// config.dev.js
output: {
  ...
  assetModuleFilename: 'assets/[name].[contenthash][ext]',
},
```

- assets 폴더 내에 파일이름.hash값.확장자명 순으로 파일을 내보낸다.
- 여기까지 설정하면 리액트 컴포넌트 단위로 에셋을 설정할 수 있다. 어차피 빌드하면 내보내지기 때문에!

## A11yHidden 컴포넌트

UI 화면에는 표시하지 않지만, 스크린 리더 사용자에게 정보를 제공할 수 있는 컴포넌트

### 스타일 코드

```css
.a11yHidden {
  overflow: hidden;
  position: absolute;
  clip: rect(1px, 1px, 1px, 1px);
  clip-path: circle(0);
  width: 1px;
  height: 1px;
  margin: -1px;
  white-space: nowrap;
}

caption.a11yHidden {
  position: static;
}

.a11yHidden.focusable:focus {
  overflow: initial;
  position: static;
  clip: auto;
  clip-path: unset;
  width: initial;
  height: initial;
  margin: initial;
  white-space: initial;
}
```

### 재사용 가능한 컴포넌트 만들기

```javascript
import "./A11yHidden.css";
import React from "react";
import { classNames } from "../../utils";

export function A11yHidden({ as, className, focusable, ...restProps }) {
  return React.createElement(as, {
    className: classNames(
      "a11yHidden",
      {
        focusable: focusable,
      },
      className
    ),
    ...restProps,
  });
}

A11yHidden.defaultProps = {
  as: "span",
  className: "",
  focusable: false,
};
```

- a11yHidden 컴포넌트는 다양한 태그에 사용될 수 있으므로 독립적으로 동작하기 위해서는 태그 이름을 넘겨줘야 한다.
- 태그를 JSX로 as로 받아서 렌더링하면 그냥 태그 이름이 as인 컴포넌트가 생성된다.
- 위와 같이 react api인 createElement를 사용하면 원하는대로 동작하게 할 수 있다.
- 클래스는 기존에 작성된 것이 덮어써지지 않도록 주의해야 한다.

### JSX로 재사용 가능한 컴포넌트 만들기

```javascript
export function A11yHidden({
  as: ComponentName,
  className,
  focusable,
  ...restProps
}) {
  return (
    <ComponentName
      className={classNames("a11yHidden", { focusable }, className)}
      {...restProps}
    />
  );
}
```

- JSX 방식으로 리턴하고 싶다면 위와 같이 as에 uppercase로 시작하는 별칭을 주어서 사용하면 원하는대로 작동한다.
- 컴포넌트 타입이름을 바꿀때 JSX는 소문자가 아니어야 한다.  
  -> 구조분해 할당해서 별칭 이름 할당하는 방식으로 하면 해결이 된다.

## postcss 설정

- postcss는 sass와 다르게 표준이다!
  `npm i -D postcss postcss-loader postcss-preset-env`

```javascript
// postcss.config.js
module.exports = {
  plugins: [
    [
      "postcss-preset-env",
      {
        stage: false, // 0 ~ 4
        browsers: "default, > 5% in KR, ie 10-11",
        autoprefixer: {
          grid: true,
        },
        features: {
          "nesting-rules": true,
          "custom-properties": true,
          "custom-selectors": true,
          "color-functional-notation": true,
        },
      },
    ],
  ],
};
```

- stage는 0~4까지 존재하는데, false로 지정하면 기존에 잘 안되던 문제를 해결할 수 있다는 답변이 있길래 false로 지정했다.

```javascript
// .browserslistrc
defaults
> 5% in KR
not dead
ie 11
```

- 브라우저 지원 범위 설정

```javascript
// config.dev.js
{
  test: /\.css$/i,
  use: [
    'style-loader',
    {
      loader: 'css-loader',
      options: {
        importLoaders: 1,
        sourceMap: true,
      },
    },
    {
      loader: 'postcss-loader',
      options: {
        sourceMap: true,
      },
    },
  ],
},
```

## Sass 설정

`npm i -D sass sass-loader`

```javascript
// config.dev.js
{
  test: /\.(css|s[ac]ss)$/i,
  use: [
    'style-loader',
    {
      loader: 'css-loader',
      options: {
        importLoaders: 2,
        sourceMap: true,
      },
    },
    {
      loader: 'postcss-loader',
      options: {
        sourceMap: true,
      },
    },
    {
      loader: 'sass-loader',
      options: {
        sourceMap: true,
      },
    },
  ],
},
```

- importLoaders는 CSS로더 이전에 적용할 로더의 허용수를 설정

### jest 설정 변경

```javascript
module.exports = {
  ...
	moduleNameMapper: {
      '\\.s?[ac]ss$': 'identity-obj-proxy',
  },
}
```

## svgr 설정

`npm i -D @svgr/webpack`

- svg 파일을 모듈로 불러와서 내보내주는 형태
- html에 svg를 삽입할 때, 컴포넌트를 계속해서 만들지 않기 위해 사용하는 플러그인

```javascript
// config.dev.js
// create-react-app 툴체인과 동일한 방식
{
  test: /\.svg$/i,
  issuer: /\.jsx?$/,
  use: [
    {
      loader: '@svgr/webpack',
      options: {
        prettier: false,
        titleProp: true,
        svgo: true,
      },
    },
    'url-loader',
  ],
},
```

- url 로더를 활용한 방법. cra 툴체인과 동일한 방식

```javascript
// config.dev.js
//      Webpack v5부터 사용 가능한 방식
{
  test: /\.svg$/i,
  oneOf: [
    {
      issuer: /\.jsx?$/,
      resourceQuery: /react/, // *.svg?react
      use: [
        {
          loader: '@svgr/webpack',
          options: {
            prettier: false,
            titleProp: true,
            svgo: true,
          },
        },
      ],
    },
    {
      type: 'asset',
      parser: {
        dataUrlCondition: {
          maxSize: 40 * 1024, // 40kb
        },
      },
    },
  ],
},
```

```javascript
// App.js
import ReactLogo from "../../assets/react.svg?react";
import reactLogoPath from "../../assets/react.svg";

export default function App({ greetingMessage }) {
  return (
    <div className="app">
      <img src={reactLogoPath} alt="리엑트" />
      <ReactLogo title="React UI Library" />
      <h1>{greetingMessage}</h1>
    </div>
  );
}
```

- 위와 같이 설정하면 ?파일이름을 뒤에 붙였을 때는 컴포넌트, 그냥 가져왔을 때는 data URI방식으로 동작한다.
