---
title: "1227 - 0102"
tag: TIL
category: TIL
excerpt: ""
---

## 1228

# 모의 코딩테스트 11회 회고

알고리즘 공부를 한동안 하지 않다가 다시 하려니 쉽지 않게 느껴졌다.  
알고리즘 문제를 풀면서 시간복잡도만 생각해왔는데, 공간복잡도 측면에서도 고민해볼 수 있는 하루였다.

## k개의 원소로 이루어진 연속된 부분수열 분리

```javascript
function solution(nums, k) {
  if (nums.length % k !== 0) return "NO";
  const map = new Map();

  nums.forEach((num) => map.set(num, (map.get(num) || 0) + 1));
  nums.sort((a, b) => a - b);

  for (let i = 0; i < nums.length; i++) {
    if (map.get(nums[i])) {
      for (let j = 0; j < k; j++) {
        if (map.get(nums[i] + j) > 0)
          map.set(nums[i] + j, map.get(nums[i] + j) - 1);
        else return "NO";
      }
    }
  }

  return "YES";
}
```

- 우선 k개로 나누어 떨어지지 않는다면 'NO'를 반환한다.
- 맵에 각 숫자의 개수를 해싱하고 정렬한다.
- 맵에 해당 숫자가 존재한다면 해당 숫자부터 k번까지 증가시켜 해싱된 숫자를 찾고, 있다면 해당 숫자의 개수를 1감소시킨뒤 계속 반복한다.
- 모두 돌았는데 정답이 도출되지 않는다면 YES를 반환한다.

## 합이 홀수인 부분수열 개수

```javascript
function solution(nums) {
  let answer = 0;
  const oddArr = Array(nums.length).fill(0);
  const evenArr = Array(nums.length).fill(0);

  nums[0] % 2 === 0 ? (evenArr[0] = 1) : (oddArr[0] = 1);
  answer += oddArr[0];

  for (let i = 1; i < nums.length; i++) {
    if (nums[i] % 2 === 0) {
      oddArr[i] = oddArr[i - 1];
      evenArr[i] = evenArr[i - 1] + 1;
    } else {
      evenArr[i] = oddArr[i - 1];
      oddArr[i] = evenArr[i - 1] + 1;
    }
    answer += oddArr[i];
  }

  return answer % 1000000007;
}
```

- i번째 까지의 부분수열 중 홀수와 짝수의 개수를 계산하며 구해나간다.
- 홀수 배열에 저장된 모든 값을 더하면 값을 도출할 수 있다.

## 사과를 모두 먹을 수 있는 최소 일수

```javascript
function solution(n) {
  const ch = new Map();
  const queue = [n];
  ch.set(n, 1);
  let L = 0;

  function BFS() {
    while (queue.length) {
      const len = queue.length;

      for (let i = 0; i < len; i++) {
        const x = queue.shift();

        if (x === 0) return L;
        if (x % 2 === 0 && !ch.has(x / 2)) {
          queue.push(x / 2);
          ch.set(x / 2, 1);
        }
        if (x % 3 === 0 && !ch.has(x / 3)) {
          queue.push(x / 3);
          ch.set(x / 3, 1);
        }
        if (!ch.has(x - 1)) {
          queue.push(x - 1);
          ch.set(x - 1, 1);
        }
      }
      L += 1;
    }
  }

  return BFS();
}
```

- 가장 큰 깨달음을 얻었던 문제
- 알고리즘 문제를 해결하다보면 시간복잡도만 주로 생각하게 됐었는데, 공간복잡도도 고려해야함을 깨닫게 되었다.
- 쓸데없이 큰 배열을 잡는 것이 아니라 필요한 만큼만 해싱하여 문제를 해결할 수 있었다.
