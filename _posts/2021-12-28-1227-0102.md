---
title: "1227 - 0102"
tag: TIL
category: TIL
excerpt: ""
---

## 1228

# 모의 코딩테스트 11회 회고

알고리즘 공부를 한동안 하지 않다가 다시 하려니 쉽지 않게 느껴졌다.  
알고리즘 문제를 풀면서 시간복잡도만 생각해왔는데, 공간복잡도 측면에서도 고민해볼 수 있는 하루였다.

## 1번

```javascript
function solution(nums, k) {
  if (nums.length % k !== 0) return "NO";
  const map = new Map();
  nums.forEach((x) => map.set(x, (map.get(x) || 0) + 1));
  nums.sort((a, b) => a - b);

  for (let i = 0; i < nums.length; i++) {
    if (map.get(nums[i]) > 0) {
      for (let j = 0; j < k; j++) {
        if (map.get(nums[i] + j) > 0)
          map.set(nums[i] + j, map.get(nums[i] + j) - 1);
        else return "NO";
      }
    }
  }
  return "YES";
}
```

## 2번

```javascript
function solution(nums) {
  let answer = 0;
  const oddArr = Array(nums.length).fill(0);
  const evenArr = Array(nums.length).fill(0);

  nums[0] % 2 === 0 ? (evenArr[0] = 1) : (oddArr[0] = 1);
  answer += oddArr[0];

  for (let i = 1; i < nums.length; i++) {
    if (nums[i] % 2 === 0) {
      oddArr[i] = oddArr[i - 1];
      evenArr[i] = evenArr[i - 1] + 1;
    } else {
      evenArr[i] = oddArr[i - 1];
      oddArr[i] = evenArr[i - 1] + 1;
    }
    answer += oddArr[i];
  }

  return answer % 1000000007;
}
```

## 3번

```javascript
function solution(n) {
  const ch = Array(n).fill(0);
  const queue = [n];
  let L = 0;

  function BFS() {
    while (queue.length) {
      const len = queue.length;

      for (let i = 0; i < len; i++) {
        const x = queue.shift();

        if (x === 0) return L;
        if (x % 2 === 0 && ch[x / 2] === 0) {
          queue.push(x / 2);
          ch[x / 2] = 1;
        }
        if (x % 3 === 0 && ch[x - (x / 3) * 2] === 0) {
          queue.push(x - (x / 3) * 2);
          ch[x - (x / 3) * 2] = 1;
        }
        if (ch[x - 1] === 0) {
          queue.push(x - 1);
          ch[x - 1] = 1;
        }
      }
      L += 1;
    }
  }

  return BFS();
}
```
