---
title: "1025-1031"
tag: TIL
category: TIL
---

## 1025

서버사이드 렌더링으로 다시 이동하는 이유  
-> 속도

고차함수가 콜백함수를 호출하면 동기 함수  
고차함수가 콜백함수를 호출하지 않으면 비동기 함수

### 서버 통신은 비동기

아래 3개의 이유때문에 서버 통신은 비동기로 동작해야한다.

1. 랜선을 타고 통신 해야한다.
2. 서버에서 로직
3. DB접근. DB는 파일로 저장되기 때문에 느리다.
   비동기의 핵심 -> 블로킹

빌트인 객체는 힙 영역에 있고, Web API는 브라우저에 객체로 존재하지 JS 엔진 내부에 있지 않다.

### 비동기 함수란?

함수 내부에 비동기 처리를 하면 비동기 함수

### 옵저버 패턴

상태가 변했을 때 -> render를 호출해야 할 타이밍  
문제는 상태가 변했을 때 render함수에 의존한다는 것  
상태가 변경했을 때 컨트롤러에서 render를 호출해주면 문제를 해결할 수 있다.

옵저버 패턴을 사용하면 store에서 직접적으로 render에 의존 하지는 않게 되지만 컨트롤러에서 render를 호출해줘야 한다는 코딩 약속을 지켜야하기에 가독성이 떨어진다.

## 프로그래머스 Level2 카카오 - 압축

```javascript
function solution(msg) {
  const answer = [];
  const dic = " ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
  let lt = 0;

  for (let rt = 1; rt <= msg.length; rt++) {
    if (dic.indexOf(msg.slice(lt, rt)) === -1) {
      dic.push(msg.slice(lt, rt));
      answer.push(dic.indexOf(msg.slice(lt, rt - 1)));
      lt = rt - 1;
    }
  }
  return [...answer, dic.indexOf(msg.slice(lt))];
}
```

- A부터 Z까지 문자열을 생성하고 앞에 빈 칸을 두어 split으로 사전 배열을 생성했다. 앞에 빈 칸을 둔 이유는 인덱스를 하나씩 늘려서 문제 조건에 맞게 조회하기 위해서이다.
- 투포인터 개념을 사용했는데, lt부터 rt까지 잘라낸 문자열이 사전에 없을 때까지 rt를 증가시켜 사전에 push하고 answer에는 rt-1까지의 값을 푸시했다.
- 그리고 lt에 rt - 1을 할당하고 계속 진행하였다.

## 프로그래머스 Level2 카카오 - 수식 최대화

```javascript
function solution(expression) {
  let answer = 0;
  const prior = [];
  const arr = expression.match(/[0-9]+|./g);
  const sh = [...new Set(expression.match(/[^0-9]/g))];
  const ch = Array.from(Array(sh.length), () => 0);
  const tmp = [];

  function DFS(L) {
    if (L === sh.length) {
      prior.push(tmp.join(""));
    } else {
      for (let i = 0; i < sh.length; i++) {
        if (ch[i] === 0) {
          ch[i] = 1;
          tmp.push(sh[i]);
          DFS(L + 1);
          tmp.pop();
          ch[i] = 0;
        }
      }
    }
  }
  DFS(0);

  for (const p of prior) {
    let express = [...arr];
    for (const op of p) {
      let tmp = [];
      for (let i = 0; i < express.length; i++) {
        if (express[i] === op) {
          tmp.push(eval(tmp.pop() + op + express[i + 1]));
          i++;
        } else {
          tmp.push(express[i]);
        }
      }
      express = tmp;
    }
    answer = Math.max(answer, Math.abs(express[0]));
  }
  return answer;
}
```

- 생각보다 어려운 문제라고 느낀 구현 문제였다.
- 푸는 것 자체는 어렵지 않았는데, 구현이 생각보다 어려웠다.
- DFS로 연산자 조합을 모두 구하고, 해당 연산자 조합으로 반복문을 돌려서 절대값이 가장 큰 수를 구했다.
