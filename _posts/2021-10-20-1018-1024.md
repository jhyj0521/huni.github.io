---
title: "1018-1024"
tag: TIL
category: TIL
---

## 1018

강남으로의 첫 등교. 새로운 시작

모듈이라는 개념은 전체가 즉시실행 함수로 감싸져 있다.

자바스크립트는 콜스택이 하나인 싱글 스레드 언어이다.  
-> 자바스크립트 엔진이 싱글 스레드  
이 말은 한 번에 하나의 일만 수행할 수 있다는 것을 의미한다.

예를 들어 10초 걸리는 일이 앞에 있고, 그 뒤에 함수가 있는 경우 뒤에 있는 함수가 블로킹 된다.  
이를 해결하기 위해 비동기 처리를 해야하는데, 10초 걸리는 일을 브라우저에게 위임한다.  
-> 브라우저는 멀티스레드  
콜스택과 이벤트 루프, 태스크 큐 세 개가 협동하여 비동기 처리를 한다.

서버 처리를 할때는 에러가 발생할 확률이 높아서 에러처리를 해줘야 한다.

## 프로그래머스 Level2 - JadenCase 문자열 만들기

```javascript
const solution = (s) =>
  s.replace(/[^ ]+/g, (s) => s[0].toUpperCase() + s.slice(1).toLowerCase());
```

- 한 줄 코드로 문제를 해결했다.
- 공백이 아닌 문자열이 계속되는 경우 해당 문자열을 맨 앞글자는 대문자로, 그 뒤 문자열은 소문자로 변환하였다.

## 1019

페어 프로그래밍을 진행하면서 상태를 저장해야 하는 경우가 있었는데, 쿠키와 로컬 스토리지 세션 스토리지 중에서 어떤 것을 사용해야 할 지 명확하게 판단을 내릴 수가 없었다. 이번 기회에 각 방식의 특징과 어떤 경우에 무엇을 사용할지 판단을 내리기 위해서 이번 글을 작성하게 되었다

<br />
<br />

## 쿠키

HTTP 쿠키는 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각이다.
브라우저는 그 데이터 조각들을 저장해 놓았다가, 동일한 서버에 재요청 시 저장된 데이터를 함께 전송한다.

과거엔 클라이언트 측에 정보를 저장할 때 쿠키를 주로 사용하곤 했다. 쿠키를 사용하는 게 데이터를 클라이언트 측에 저장할 수 있는 유일한 방법이었을 때는 이 방법이 타당했지만, 지금은 웹 스토리지를 사용해 정보를 저장하는 것을 권장한다.

<br />

### 쿠키의 단점

- http 통신을 할 때 매번 서버에 전송된다.
- 로컬 스토리지는 5mb까지의 데이터를 저장할 수 있는 반면, 쿠키는 4kb까지의 데이터만 저장할 수 있다.

<br />
<br />

## 웹 스토리지

웹 스토리지 API는 브라우저에서 키/값 쌍을 쿠키보다 훨씬 직관적으로 저장할 수 있는 방법을 제공한다. 종류로는 **로컬 스토리지**와 **세션 스토리지**가 있다. 이들은 window 전역 객체의 프로퍼티로서 존재하며, 같은 Storage 객체를 상속받기 때문에 동일한 메소드들을 가진다.

쿠키와 달리 서버에 전송되지 않으므로 서버에 부담이 가지 않고, 더 많은 데이터를 저장할 수 있다.

<br />

### 로컬 스토리지와 세션 스토리지

로컬 스토리지는 세션 스토리지와 비슷하지만, 로컬 스토리지의 데이터는 만료되지 않고 세션 스토리지의 데이터는 페이지 세션이 끝날 때 제거되는 **만료성**의 차이가 있다.

- 페이지 세션은 브라우저가 열려있는 한 새로고침과 페이지 복구를 거쳐도 남아있다.
- 페이지를 새로운 탭이나 창에서 열면, 새로운 세션을 생성한다.
- 탭/창을 닫으면 세션이 끝나고 세션 스토리지 안의 객체를 초기화시킨다.

<br />

웹 스토리지의 키와 값은 항상 각 문자에 2바이트를 할당하는 DOMString의 형태로 저장한다. 객체와 마찬가지로 정수 키는 자동으로 문자열로 변환한다. 불리언 타입으로 값을 저장해서 사용하고 싶다면, 값을 받아올 때 `JSON.parse` 메서드를 사용하면 된다. 또는 객체를 값으로 저장하고 싶다면 `JSON.stringify` 메서드를 사용하면 된다.

<br />
<br />

## 정리

로컬 스토리지와 세션 스토리지는 데이터의 세션이 종료되어도 데이터를 유지할 것이냐 하지 않을 것이냐에 따라 무엇을 사용할 지 결정한다.

웹 스토리지와 쿠키 중 무엇을 사용할지는 몇 가지 사항을 고려해야 한다.

우선 로컬 스토리지는 자바스크립트 코드를 통해 삭제하지 않으면 데이터는 자동으로 삭제되지 않기 때문에 큰 데이터를 더 오랜 시간동안 저장해야 하는 경우에 유용한다.

다만 로컬 스토리지를 잘 사용하려면 저장된 데이터의 위협 수준이 낮아야 한다. 쿠키는 HttpOnly를 사용하면 XSS를 방어할 수 있는 반면, 로컬 스토리지는 XSS에 취약할 수 있기 때문이다.

그렇기 때문에 프론트엔드 개발자 입장으로 생각해 봤을 때, 보안적인 측면에서 중요성이 높지 않은 데이터들은 만료일을 설정해줘야 하는 경우`ex) 하루동안 이 팝업창 보지 않기`에만 쿠키를 사용해 저장하고, 그 외에는 웹 스토리지 API를 사용해야겠다고 결론을 내렸다.

보안적인 측면에서 중요성이 높은 데이터의 경우에는 아직 결론을 내리지 못했지만 계속해서 고민해봐야겠다.

## 1020

## 프로그래머스 카카오 Level2 - 거리두기 확인하기

```javascript
function solution(places) {
  const answer = [];
  const dx1 = [-1, 0, 1, 0];
  const dy1 = [0, 1, 0, -1];
  const dx2 = [-1, 1, 1, -1];
  const dy2 = [1, 1, -1, -1];
  const dx3 = [-2, 0, 2, 0];
  const dy3 = [0, 2, 0, -2];

  function isRight(place) {
    for (let i = 0; i < place.length; i++) {
      for (let j = 0; j < place[i].length; j++) {
        if (place[i][j] === "P") {
          for (let k = 0; k < 4; k++) {
            const nx = i + dx1[k];
            const ny = j + dy1[k];

            if (nx >= 0 && ny >= 0 && nx < 5 && ny < 5 && place[nx][ny] === "P")
              return false;
          }

          for (let k = 0; k < 4; k++) {
            const nx = i + dx2[k];
            const ny = j + dy2[k];

            if (
              nx >= 0 &&
              ny >= 0 &&
              nx < 5 &&
              ny < 5 &&
              place[nx][ny] === "P" &&
              (place[nx][j] !== "X" || place[i][ny] !== "X")
            )
              return false;
          }

          for (let k = 0; k < 4; k++) {
            const nx = i + dx3[k];
            const ny = j + dy3[k];

            if (
              nx >= 0 &&
              ny >= 0 &&
              nx < 5 &&
              ny < 5 &&
              place[nx][ny] === "P" &&
              place[(i + nx) / 2][(j + ny) / 2] !== "X"
            )
              return false;
          }
        }
      }
    }
    return true;
  }

  for (const x of places) {
    if (isRight(x)) answer.push(1);
    else answer.push(0);
  }

  return answer;
}
```

- 좌표를 그리고 상황을 나눠서 문제를 해결하였다.
- 맨해튼 거리를 기준으로 거리두기를 준수하지 않은 경우를 생각해보니 1. 현재 요소가 P일 때 상하좌우 +1의 거리에 P가 있는 경우 2. 현재 요소가 P고 대각선 중 한 곳에 P가 있는데, 대각선 사이에 둘 다 X가 아닐 때 3. 현재 요소가 P일 때 상하좌우 +2의 거리에 P가 있고 그 사이가 X가 아닐 때
  이 세 경우가 존재했다.
- 결과로 배열을 반환해야 했기에 반복문을 돌려서 각 대기실이 거리두기를 준수했는지 아닌지를 확인했다.
- 인덱스를 잘못 계산하여 해결되지 않는 테스트케이스가 존재했는데, 이를 염두에 두고 계산을 잘 해야겠다고 생각했다.

## 프로그래머스 Level2 - 모음사전

```javascript
function solution(word) {
  let answer = 0;
  const str = "AEIOU";
  const arr = [];
  let tmp = [];
  function DFS(L, n) {
    answer++;
    if (L === n) arr.push(tmp.slice(""));
    else {
      for (let i = 0; i < 5; i++) {
        tmp.push(str[i]);
        DFS(L + 1, n);
        tmp.pop();
      }
    }
  }

  for (let i = 1; i <= 5; i++) {
    tmp = [];
    DFS(0, i);
  }
  answer = arr.sort().findIndex((v) => v.join("") === word) + 1;

  return answer;
}

console.log(solution("AAAAE"));
```

- 정말 간단한 문제라고 생각했는데 생각보다 시간이 조금 걸렸다.
- DFS를 사용하여 수학 계산 중, 부분집합 구하기, 순열 구하기, 중복 순열 구하기, 조합 구하기를 사용할 줄 아는데, 이 중 무엇을 활용할지 헷갈렸다.
- 사전 상으로 정렬하면 되므로 1개부터 5개까지 모든 중복 순열을 구한 뒤, 정렬하여 답을 찾았다.

## 1021

### 프로그래머스 카카오 Level3 - 보석 쇼핑

```javascript
function solution(gems) {
  let answer = [];
  const sh = new Map();
  let lt = 0;

  for (const gem of gems) {
    sh.set(gem, (sh.get(gem) || 0) + 1);
  }
  const len = sh.size;
  sh.clear();

  for (let rt = 0; rt < gems.length; rt++) {
    sh.set(gems[rt], (sh.get(gems[rt]) || 0) + 1);

    while (sh.size === len) {
      sh.set(gems[lt], sh.get(gems[lt]) - 1);
      if (sh.get(gems[lt]) === 0) sh.delete(gems[lt]);
      answer.push([lt + 1, rt + 1]);
      lt++;
    }
  }

  answer.sort((a, b) =>
    a[1] - a[0] > b[1] - b[0]
      ? 1
      : a[1] - a[0] < b[1] - b[0]
      ? -1
      : a[0] > b[0]
      ? 1
      : -1
  );

  return answer[0];
}
```

- 카카오 레벨 3단계 문제라 엄청 어려울 것이라고 생각했는데, 생각보다 금방 풀렸다.
- 투포인터 알고리즘을 사용해서 보석 종류의 개수를 처음에 구하고, map으로 보석을 저장하여 모든 종류의 보석을 가지고 있을 때의 경우를 모두 구해 정렬하여 답을 찾았다.

## 프로그래머스 Level2 - 짝지어 제거하기

```javascript
function solution(s) {
  let answer = 1;
  const nh = [];

  for (let x of s) {
    if (nh[nh.length - 1] === x) {
      nh.pop();
    } else {
      nh.push(x);
    }
  }

  answer = nh.length === 0 ? 1 : 0;

  return answer;
}
```

- 다르게 말하면 스택인지 아닌지 찾는 문제인대, 이를 빠르게 알아차리는 것이 핵심인 문제였다.
- 효율성이 들어가면 당연히 투포인터, 이분탐색 또는 DP까지 생각하게 되는데 이러한 고정관념을 내려놓을 필요도 있다고 느꼈다.
