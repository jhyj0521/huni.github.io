---
title: "0802-0808"
tag: TIL
category: TIL
---
## 0802
# 16일 차 재귀함수, DFS, BFS


## 재귀함수를 이용한 이진수 출력
10진수 N이 입력되면 2진수로 변환하여 출력하는 프로그램을 작성하세요. 단 재귀함수를 이용 해서 출력해야 합니다. 

```javascript
function solution(n) {
    let answer = 0;
    let tmp = [];

    function DFS(n) {
        if (n === 0) return;
        else {
            DFS(parseInt(n / 2));
            tmp.push(n % 2);
        }
    }
    DFS(n);

    for (let i = 0; i < tmp.length; i++) {
        answer = answer * 10 + tmp[i];
    }

    return answer;
}

console.log(solution(11));
```
* n이 0이 될 때까지 재귀함수로 호출하여 빈 배열 tmp에 n을 2로 나눈 나머지를 push했다.
* tmp에 있는 요소를 숫자형으로 변환했다.


## 이진트리 순회
이진트리를 전위순회와 후위순회를 연습해보세요. 

```javascript
function solution(n) {
    let answer = "";
    function DFS(v) {
        if (v > 7) return;
        else {
            answer += v;
            DFS(v * 2);
            DFS(v * 2 + 1);
        }
    }
    DFS(n)

    return answer;
}

console.log(solution(1));
```
* `answer += v` 코드를 재귀함수 앞에 두면 전위, 가운데 두면 중위, 끝에 두면 후위순회이다.


## 부분집합 구하기(DFS)
자연수 N이 주어지면 1부터 N까지의 원소를 갖는 집합의 부분집합을 모두 출력하는 프로그램을 작성하세요. 

```javascript
function solution(n) {
    let answer = [];
    let tmp = [];

    function DFS(L) {
        if (L === n + 1) {
            if(tmp.length !== 0) answer.push(tmp.slice());
        }
        else { 
            tmp.push(L);
            DFS(L + 1);
            tmp.pop(L);
            DFS(L + 1);
        }
    }
    DFS(1);

    return answer;
}
console.log(solution(3));
```
* tmp에 요소를 push하고 재귀 함수 호출, pop하고 재귀 함수를 호출하여 부분집합을 구했다.
* 주의할 점은 answer에 배열인 tmp를 push할 때 slice()메소드를 사용해야지만 깊은 복사가 되어 제대로 복사된다.
* 트리로 그려보면, 각 요소를 넣었을 때와 안넣었을 때로 구분하는 상황이 나온다.

## 합이 같은 부분집합 
N개의 원소로 구성된 자연수 집합이 주어지면, 이 집합을 두 개의 부분집합으로 나누었을 때 두 부분집합의 원소의 합이 서로 같은 경우가 존재하면 “YES"를 출력하고, 그렇지 않으면 ”NO"를 출력하는 프로그램을 작성하세요.  
둘로 나뉘는 두 부분집합은 서로소 집합(Disjoint Set)이며, 두 부분집합을 합하면 입력으로 주어진 원래의 집합이 되어야 합니다.   
예를 들어 {1, 3, 5, 6, 7, 10}이 입력되면 {1, 3, 5, 7} = {6, 10} 으로 두 부분집합의 합이 16으로 같은 경우가 존재하는 것을 알 수 있다. 

```javascript
function solution(nums) {
    let answer = "NO";
    let total = nums.reduce((acc, current) => acc + current, 0);
    let flag = false;

    function DFS(L, sum) {
        if (L === nums.length) {
            if(flag) return;
            if(total-sum === sum) {
                answer="YES"
                flag=true;
            }
        }
        else {
            DFS(L+1, sum + nums[L]);
            DFS(L+1, sum);
        }
    }
    DFS(0, 0);

    return answer;
}

console.log(solution([1, 3, 5, 6, 7, 10]));
console.log(solution([5, 2, 6, 9, 10, 12]));
console.log(solution([3, 9, 11, 13]));
```
* 매개변수를 잘 활용해야 하는 문제
* L을 인덱스 번호처럼 사용해서 해결한다.
* 모든 수의 합을 구하고, 모든 수에서 일정 수까지 더한 값을 뺐을 때 그 값이 나오면 합이 같은 두 부분집합이 있다는 뜻으로, YES를 반환한다.
* 부분집합이 문제에 나온다면, DFS를 떠올려보자


## 바둑이 승차
철수는 그의 바둑이들을 데리고 시장에 가려고 한다.   
그런데 그의 트럭은 C킬로그램 넘게 태울수가 없다. 철수는 C를 넘지 않으면서 그의 바둑이들을 가장 무겁게 태우고 싶다.  
N마리의 바둑이와 각 바둑이의 무게 W가 주어지면, 철수가 트럭에 태울 수 있는 가장 무거운 무게를 구하는 프로그램을 작성하세요. 

```javascript
function solution(nums, c) {
    let answer = 0;
    let total = nums.reduce((acc, current) => acc + current, 0); 

    function DFS(L, sum, tsum) {
        if (sum > c) return;
        if ((total - tsum + sum) < answer) return;
        if (L === nums.length) {
            answer = Math.max(answer, sum);
        }
        else {
            DFS(L+1, sum + nums[L], tsum + nums[L]);
            DFS(L+1, sum, tsum + nums[L]);
        }
    }
    DFS(0, 0, 0);
    return answer;
}
console.log(solution([81, 58, 42, 33, 61], 259));
```
* 재귀적으로 L을 1씩 증가시켜가며 바둑이를 태웠을 때와 안태웠을 때로 나누어 sum을 계산한다.
* sum이 최대 무게를 넘어서면 더 이상 진행할 필요가 없으므로 return 한다.
* tsum은 현재까지 모든 강아지를 태웠을 때로 가정하고 무게를 모두 더한다.
	* total은 모든 강아지의 무게인데, 여기서 tsum을 빼면 앞으로 남은 강아지를 모두 태웠을 때의 무게이다.
	* 그 값에 현재 sum을 더해도 answer에 담긴 값보다 작을 때는 앞으로 남은 강아지를 모두 태워도 정답이 될 수 없기 때문에 return 한다.


## 최대점수 구하기
이번 정보올림피아드대회에서 좋은 성적을 내기 위하여 현수는 선생님이 주신 N개의 문제를 풀려고 합니다.   
각 문제는 그것을 풀었을 때 얻는 점수와 푸는데 걸리는 시간이 주어지게 됩니다.   
제한시간 M안에 N개의 문제 중 최대점수를 얻을 수 있도록 해야 합니다. (해당문제는 해당시간이 걸리면 푸는 걸로 간주한다, 한 유형당 한개만 풀 수 있습니다.) 

```javascript
function solution(nums, m) {
    let answer = 0;

    function DFS(L, sum, time) {
        if (time > m) return;
        if (L === nums.length) {
            answer = Math.max(answer, sum);
        }
        else {
            DFS(L + 1, sum + nums[L][0], time + nums[L][1]);
            DFS(L + 1, sum, time);
        }
    }
    DFS(0, 0, 0);

    return answer;
}

console.log(solution([[10, 5], [25, 12], [15, 8], [6, 3], [7, 4]], 20));
console.log(solution([[15, 6], [30, 11], [23, 8], [14, 4], [10, 3], [20, 7]], 25));
```
* 바둑이 승차 문제와 비슷한 방법으로 해결하면 된다.
* 입력이 많을 때 시간을 줄이고 싶다면, total을 구해서 최적의 해답이 아니라면 return하는 코드를 삽입해도 좋다.



## 중복 순열 구하기
1부터 N까지 번호가 적힌 구슬이 있습니다.   
이 중 중복을 허락하여 M번을 뽑아 일렬로 나열하는 방법을 모두 출력합니다. 

```javascript
function solution(n, m) {
    let answer = [];
    let tmp = [];

    function DFS(L) {
        if (L === m) {
            answer.push(tmp.slice());
        }
        else {
            for(let i = 1; i <= n; i++) {
                tmp.push(i);
                DFS(L+1);
                tmp.pop();
            }
        }

    }
    DFS(0);

    return answer;
}

console.log(solution(3, 2));
```
* L을 1씩 증가시키며 재귀호출을 해서 해결하는 문제이다.
* m은 깊이를 지정하고, for문은 n의 개수만큼 재귀를 하기 위해서 사용한다.


## 순열 구하기
10이하의 N개의 자연수가 주어지면 이 중 M개를 뽑아 일렬로 나열하는 방법을 모두 출력합니다. 

```javascript
function solution(nums, m) {
    let answer = [];
    let tmp = [];
    let ch=Array.from({length: nums.length}, () => 0);


    function DFS(L) {
        if(L === m) {
            answer.push(tmp.slice());
        } 
        else {
            for (let i = 0; i <=nums.length; i++) {
                if (ch[i] === 0) {
                    ch[i] = 1;
                    tmp.push(nums[i]);
                    DFS(L+1);
                    tmp.pop();
                    ch[i] = 0;
                }
            }
        }
    }
    DFS(0);

    return answer;
}

console.log(solution([3, 6, 9], 2));
```
* 중복 순열구하기 문제에서 조금만 바꾸면 일반 순열 구하기가 된다.
* nums 길이만큼 ch 배열을 초기화 시켜두고, ch[i]가 0일 때만 코드를 동작시킨다.
* 그리고 내부에서 사용한 인덱스의 값을 1로 바꾸고, 다 사용한 뒤 0으로 바꾸면 중복해서 숫자가 조합되지 않는다.

## 조합의 경우수(메모이제이션)
아래 공식을 사용하여 재귀를 이용해 조합수를 구해주는 프로그램을 작성하세요. 
`nCr = n-1Cr-1 + n-1Cr`

```javascript
function solution(n, r) {
    let answer;
    let dy = Array.from(Array(35), () => Array(35).fill(0));

    function DFS(n, r) {
        if (dy[n][r]>0) return dy[n][r];
        if (n === r || r === 0) return 1;
        else {
            return dy[n][r] = DFS(n - 1, r - 1) + DFS(n - 1, r);
        }
    }
    answer = DFS(n, r);
    return answer;
}

console.log(solution(33, 19));
```
* 조합의 경우수를 구해야 하는 경우 메모이제이션을 사용하면 코드가 동작하는 시간을 획기적으로 줄일 수 있다.
* 메모이제이션은 같은 값을 다른 곳에서 자주 사용하는 경우 사용하는 기법으로, 재귀에서 주로 사용한다.
* `Array.from()` 메소드는 첫 번째 매개변수로는 배열로 변환하고자 하는 배열 객체나 반복 가능한 객체가 들어가고, 두 번째 매개변수로는 map 콜백함수가 들어간다.
	* 위의 코드에서 첫 번째 매개변수에 Array(35)를 넣었으므로 길이 35의 배열이 들어가고, 두 번째 매개변수에서 Array(35)를 0으로 채워서 반환하므로 35 x 35의 2차원 배열이 생성된다.
	* 첫 번째 매개변수에서 `{length: 20}`을 넣으면 배열이 생성되는 이유는 배열도 객체이기 때문이다. object에 Array 메소드들과 iterator, length 속성을 넣어준 것이 배열이기 때문에 첫 번째 인자로 `{length: 20}` 같은 것을 건내준다면 배열로 인식하여 코드가 동작한다.
* 이후 메모이제이션 기법을 사용해서 n, r에 값을 저장해놓고, DFS가 실행될 때마다 n, r로 조회하여 값이 있다면 더 이상 재귀 호출을 하지 않도록 한다.


## 수열 추측하기
가장 윗줄에 1부터 N까지의 숫자가 한 개씩 적혀 있다. 그리고 둘째 줄부터 차례대로 파스칼의 삼각형처럼 위의 두개를 더한 값이 저장되게 된다.   
예를 들어 N이 4 이고 가장 윗 줄에 3 1 2 4 가 있다고 했을 때, 다음과 같은 삼각형이 그려진다.  


3 1 2 4   
 4 3 6   
  7 9   
  16   

  
N과 가장 밑에 있는 숫자가 주어져 있을 때 가장 윗줄에 있는 숫자를 구하는 프로그램을 작성하시오.   
단, 답이 여러가지가 나오는 경우에는 사전순으로 가장 앞에 오는 것을 출력하여야 한다. 

```javascript
function solution(n, f) {
    let answer;
    let ch = Array.from({length: n + 1}, () => 0);
    let p = [];
    let b = [];
    let flag = false;

    b.push(1);
    for (let i = 1; i < n; i++) {
        b[i] = b[i - 1] * (n - i) / i;
    }

    function DFS(L, s) {
        if (flag) return;
        if (L === n) {
            if (s === f) {
                answer = p.slice();
                flag = true;
            }
        }
        else {
            for (let i = 1; i <= n; i++) {
                if (ch[i] === 0) {
                    ch[i] = 1;
                    p.push(i);
                    DFS(L + 1, s + i * b[L]);
                    p.pop();
                    ch[i] = 0;
                }
            }
        }
    };
    DFS(0, 0);

    return answer;
}

console.log(solution(4, 16));
console.log(solution(5, 50));
```
* 상당히 어려웠고, 이해하는데에도 많은 시간이 걸린 문제
* 우선 파스칼의 삼각형이 이항계수와 관련되어 있다는 규칙을 먼저 알아채야만 했다.
* n개를 받았을 때, 이항계수 배열을 만드는 반복문을 실행했다.
* DFS 재귀함수를 호출해서 L이 n이 되기 전까지는 순열을 구하고, sum에는 위치한 값에 이항계수 값을 곱해서 더해주었다.
* L이 n이 되면 해당 순열이 가장 밑에 있는 줄의 값과 같은지 비교해서 같은 경우에만 answer에 추가하고 사전순으로 가장 앞에 오는 값을 구했으므로, flag를 바꿔서 더 이상 재귀호출이 되지 않도록 했다.


## 조합 구하기
1부터 N까지 번호가 적힌 구슬이 있습니다.   
이 중 M개를 뽑는 방법의 수를 출력하는 프로그램을 작성하세요. 

```javascript
function solution(n, m) {
    let answer = [];
    let tmp = [];

    function DFS(L, s) {
        if (L === m) {
            answer.push(tmp.slice());
        }
        else {
            for (let i = s; i <= n; i++) {
                tmp.push(i);
                DFS(L+1, i+1);
                tmp.pop();
            }
        }
    }
    DFS(0, 1);

    return answer;
}
```
* 이 코드는 외울 것
* for문이 꼭 처음에 뽑은 숫자 이후의 숫자부터 돌아야 한다.
* 순열은 (1, 2)와 (2, 1)이 다른 것이라면, 조합은 같은 것이다.
* 매개변수에 i 이후부터 시작하도록 저장하는 s를 넣어서 사용하여 해결
* 반복문을 i = s부터 시작하도록 설정하고, 재귀 호출을 할 때 s에 i + 1을 넣어서 호출하면, i는 i다음 인덱스부터 반복문이 돌아가기 때문에 조합을 제대로 출력한다.


## 0803 
# 17일 차 DFS, BFS 응용, 그래프
## 수들의 조합
N개의 정수가 주어지면 그 숫자들 중 M개를 뽑는 조합의 합이 임의의 정수 K의 배수인 개수는 몇 개가 있는지 출력하는 프로그램을 작성하세요.  
예를 들면 5개의 숫자 2 4 5 8 12가 주어지고, 3개를 뽑은 조합의 합이 6의 배수인 조합을 찾으면 4+8+12 2+4+12로 2가지가 있습니다. 

```javascript
function solution(nums, m, k) {
    let answer = 0;

    function DFS(L, s, sum) {
        if (L === m) {
            if (sum % k === 0) answer++;
        }
        else {
            for (let i = s; i <nums.length; i++) {
                DFS(L+1, i + 1, sum + nums[i]);
            }
        }
    }
    DFS(0, 0, 0);

    return answer;
}

console.log(solution([2, 4, 5, 8, 12], 3, 6));
console.log(solution([3, 5, 7, 8, 9, 12, 14], 4, 8));
```
* 조합 코딩 공식을 통해서 조합마다 합계를 구해서 k로 나눈 값이 나누어 떨어지면 정답을 1 증가시킨다.


## 이진트리 레벨탐색 (넓이우선탐색: BFS)
아래 그림과 같은 이진트리를 큐(Queue) 자료구조를 이용해 레벨탐색을 해보세요. 

```javascript
function solution() {
    let answer = ""

    function BFS() {
        let queue = [];
        queue.push(1);

        while (queue.length) {
            let v = queue.shift();
            answer += v + " ";

            for(let nv of [v * 2, v * 2 + 1]) {
                if (nv > 7) continue;
                queue.push(nv);
            }
        }
    }
    BFS();
    return answer;
}

console.log(solution());
```
* BFS - 레벨 순으로 탐색
* 레벨 순으로 탐색한다는 말의 뜻은 0번 레벨에서 한 번만에 가는 요소들이 1번 레벨에 있다는 것이다.
	* 최소 횟수, 최단 거리가 문제에 나오면 떠올리자

1. queue를 생성하고 처음 값을 넣는다.
2. queue를 while문으로 돌린다.
3. queue에서 맨 앞의 요소를 꺼내어 자식 요소들을 호출하고, 자식 요소를 다시 queue안에 push한다.
	* 이 행위를 queue가 빌 때까지 반복
	* BFS의 기본 동작


## 송아지 찾기(BFS)
현수는 송아지를 잃어버렸다. 다행히 송아지에는 위치추적기가 달려 있다.   
현수의 위치와 송아지의 위치가 수직선상의 좌표 점으로 주어지면 현수는 현재 위치에서 송아지의 위치까지 다음과 같은 방법으로 이동한다. 송아지는 움직이지 않고 제자리에 있다.   
현수는 스카이 콩콩을 타고 가는데 한 번의 점프로 앞으로 1, 뒤로 1, 앞으로 5를 이동할 수 있다.   
최소 몇 번의 점프로 현수가 송아지의 위치까지 갈 수 있는지 구하는 프로그램을 작성하세요. 

```javascript
function solution(s, e) {
    let answer;
    let ch = Array.from(Array(10001), () => 0);

    function BFS() {
        let queue = [];
        queue.push(s);
        ch[s] = 1;

        let L = 0;
        while (queue.length) {
            let len = queue.length;

            for (let i = 0; i < len; i++) {
                let x = queue.shift();
                
                for (let nx of [x + 1, x - 1, x + 5]) {
                    if (nx === e) return L + 1;
                    if (nx > 0 && nx <= 10000 && ch[nx] === 0) {
                        ch[nx] = 1;
                        queue.push(nx);
                    }
                }
            }
            L++;
        }
    }
    answer = BFS();

    return answer;
}

console.log(solution(8, 3));
```
* 처음 현수의 위치는 5이므로, 가지를 4, 6, 10으로 뻗는다.
* 가지의 값 중 현재 송아지의 위치인 목표값이 없으므로, 레벨 1은 답이 아니다.
* 4, 6, 10에서 또 가지를 뻗어서 목표값을 찾은 레벨을 결과로 반환한다.
* 다만 이미 가지에서 제거된 값은 어차피 정답이 아니므로 가지를 뻗지 않는다.
* BFS함수를 시작하면 기본 세팅을 위해서 queue를 생성하고, 초깃값을 세팅하였다.
* 그리고 한 번 확인한 값은 다시 보지 않기 위해, ch를 생성하고 초깃값을 인덱스로 한 ch에는 1을 세팅하였다.
* queue.length로 while문으로 돌리고, 내부에서 queue의 길이만큼 반복문을 돌렸다.
* 반복문에서는 queue의 값을 하나 씩 꺼내어 그 값의 x-1, x+1, x+5에 방문하여 그 값이 목표값이라면, 아직 레벨을 올리지 않은 상태에서 추가적인 반복을 피하기 위해 살핀 것이니 L + 1을 리턴한다.
* 그렇지 않다면 계속해서 BFS로 탐색하기 위해 해당 값을 들른적이 없고, 값이 0보다 크면서 10000보다 작거나 같다면 ch[인덱스]를 1로 저장하고, 그 인덱스 값을 queue에 푸시한다.
* 이렇게 처음에 queue에 담겨 있던 만큼 반복을 마치고 나면, 레벨을 1 증가시키고 다시 queue.length를 조건으로 반복한다.


## 미로의 최단거리 통로(BFS)
7*7 격자판 미로를 탈출하는 최단경로의 길이를 출력하는 프로그램을 작성하세요.   
경로의 길이는 출발점에서 도착점까지 가는데 이동한 횟수를 의미한다.   
출발점은 격자의 (1, 1) 좌표이고, 탈출 도착점은 (7, 7)좌표이다. 격자판의 1은 벽이고, 0은 도로이다.  
격자판의 움직임은 상하좌우로만 움직인다.

```javascript
function solution(board) {
    let answer = 0;
    let dx = [-1,0,1,0];
    let dy = [0,1,0,-1];
    let dist = Array.from(Array(7), () => Array(7).fill(0));

    function BFS(x, y) {
        let queue = [];
        queue.push([x, y]);
        board[x][y]= 1;

        while(queue.length) {
            let curr= queue.shift();
            console.log(curr[0], curr[1]);
            for(let j = 0; j < 4; j++) {
                let nx=curr[0] + dx[j];
                let ny=curr[1] + dy[j];
                if(nx>=0 && nx < 7 && ny >=0 && ny < 7 && board[nx][ny] == 0) {
                    board[nx][ny] = 1;
                    dist[nx][ny] = dist[curr[0]][curr[1]] + 1;
                    queue.push([nx, ny]);
                }
            }
        }
    }
    BFS(0, 0);
    console.log(dist);
    if(dist[6][6] === 0)  return -1;
    else answer=dist[6][6];
    return answer;
}
```
* BFS로 돌리면 최단 거리가 5인 곳은 나중에 가도 이미 체크되어 있다.
* 간 지점은 1로 만들어 버린다.
* dx, dy는 인덱스를 상하좌우로 움직이기 위한 배열이다.
* dist에는 해당 인덱스까지의 거리를 저장한다.
* BFS로 인덱스를 변화시키며 뻗어나가면 dist[6][6]에 목표지점까지 최단거리가 들어가게 된다.


## 그래프와 인접행렬
### 인접 그래프
* 보통 코딩테스트에서는 입력 정보가 (1, 2)처럼 쌍으로 들어오는데 1과 2가 연결되어 있다는 뜻이다.
* 우선 2차원 배열을 생성한다.
	* 인덱스 번호를 정점으로 사용하기 위해서 `정점 + 1`을 length로 생성한다.
* 행에서 열로 이동한다고 생각하고 코드를 작성해야 한다.
	* 무방향 그래프의 경우 (1, 2)가 들어오면 2차원 배열의 [1][2], [2][1]을 체크해준다.
	* 방향 그래프의 경우 [1][2]만 체크하면 된다.
	* 가중치 그래프에서는 [1][2]에 가중치 값을 넣어준다.


## 경로 탐색(인접행렬) 
방향그래프가 주어지면 1번 정점에서 N번 정점으로 가는 모든 경로의 가지 수를 출력하는 프로그램을 작성하세요.   
아래 그래프에서 1번 정점에서 5번 정점으로 가는 가지 수는 총 6 가지입니다.   
매개변수 n에 정점의 수, 이차원 배열 edges에 간선의 정보가 주어진다.

```javascript
function solution(n, edges) {
    let answer = 0;
    let graph = Array.from(Array(n + 1), () => Array(n+1).fill(0));
    let ch = Array.from(Array(n + 1), () => 0);

    for (let [a, b] of edges) {
        graph[a][b] = 1;
    }

    function DFS(v) {
        if (v === n) {
            answer++;
        }
        else {
            for (let i = 1; i <= n; i++) {
                if (ch[i] === 0 && graph[v][i] === 1) {
                    ch[i] = 1;
                    DFS(i);
                    ch[i] = 0;
                }
            }
        }
    }
    ch[1] = 1;
    DFS(1);

    return answer;
}


console.log(solution(5, [[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 5], [3, 4], [4, 2], [4, 5]]));
```
* 모든 경로의 가지 수를 구해야 하는 문제이므로 DFS를 사용한다.
* graph 배열에는 인덱스 번호를 정점으로 해서 경로가 있다면 해당 인덱스에 1을 저장한다.
* ch 배열은 다시 갔던 경로로 되돌아가지 않도록 하기 위해서 생성하고, 기본 값을 0으로 초기화한다.
* DFS를 선언하기 전에 1은 출발 지점이므로 항상 ch[1]은 1로 되어있어야 한다.
* DFS에서 v가 n이 되면 경로를 찾은 것이므로 answer를 1 증가한다.
* 그렇지 않은 경우 1부터 n까지 반복문을 돌아서 방문한 적 없는 경로이고, 경로가 있다면 재귀호출하여 경로를 찾는다.


## 경로 탐색(인접리스트)
방향그래프가 주어지면 1번 정점에서 N번 정점으로 가는 모든 경로의 가지 수를 출력하는 프로그램을 작성하세요.   
아래 그래프에서 1번 정점에서 5번 정점으로 가는 가지 수는 총 6 가지입니다. 

```javascript
function solution(n, edges) {
    let answer = 0;
    let graph = Array.from(Array(n + 1), () => Array());
    let ch = Array.from(Array(n + 1), () => 0);

    for (let [a, b] of edges) {
        graph[a].push(b);
    }

    function DFS(v) {
        if (v === n) {
            answer++;
        }
        else {
            for (let nv of graph[v]) {
                if (ch[nv] === 0) {
                    ch[nv] = 1;
                    DFS(nv);
                    ch[nv] = 0;
                }
            }
        }
    }
    ch[1] = 1;
    DFS(1);

    return answer;
}

console.log(solution(5, [[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 5], [3, 4], [4, 2], [4, 5]]));
```
* 정점의 개수가 100개가 넘어가면 인접행렬을 사용했을 때 효율이 너무 떨어진다.
	* 인접리스트 사용해야 한다.
* 인접리스트 - 그래프의 행 크기 + 1만큼 배열을 생성한다.
* 1이 2를 가리키면, graph[1].push(2)를 한다. 무방향일 때는 반대로도 해줘야 한다.
* 가중치 그래프일 때는 2차원 배열로 graph[a].push([b, c]) 방식으로 한다.
	* a번 인덱스가 b번 방향을 향하는데, 가중치가 c라는 뜻
* 인접행렬은 2차원 배열을 생성해서 모든 값을 0으로 초기화하고 필요한 인덱스에 값을 넣었다면, 인접리스트는 행 크기 + 1만큼만 생성해서 행 내에서 필요한 값만 push하여 사용한다.



## 동아리 개수 
현수가 다니는 학교에는 동아리가 많이 있습니다. 현수가 다니는 학교의 동아리의 개수를 구하는 프로그램을 작성하세요.  
현수가 다니는 학교의 학생은 1번부터 N번까지 번호가 부여된 N명의 학생들로 되어 입력됩니다.   
만약 1번 학생과 2번 학생이 같은 동아리 이면 (1, 2) 순서쌍으로 입력되며, (2, 3)이 입력되면 1, 2, 3번 학생은 같은 동아리입니다.   
모든 학생은 동아리를 가지고 있습니다. 

```javascript
// 인접 행렬 사용은 피해야 한다.
function solution(n, edges) {
    let answer = 0;
    let graph = Array.from(Array(n+1), () => Array());
    let ch = Array.from({length: n + 1}, () => 0);
    for(let [a,b] of edges) {
        graph[a].push(b);
        graph[b].push(a);
    }
    
    function DFS(v) {
        for (let nv of graph[v]) {
            if(ch[nv] === 0) {
                ch[nv] = 1;
                DFS(nv);
            }
        }
    }

    for (let i = 1; i <= n; i++) {
        if (ch[i] === 0) {
            answer++;
            ch[i] = 1;
            DFS(i);
        }
    }
    return answer;
}

console.log(solution(7, [[1, 2], [2, 3], [1, 4], [1, 5]]));
```
* 문제에서 순서 쌍이 주어진 것을 보고 인접리스트와 DFS를 사용해서 문제를 해결할 수 있겠다고 생각했다.
* 무방향 그래프이므로 그에 맞게 인접리스트를 세팅했다.
* 기존에는 DFS내에서 if else문을 사용해서 해결했는데, 이번에는 바깥에서 for문을 돌려 조건을 검사해가며 필요할 때 DFS를 호출했다.


## 섬나라 아릴랜드(DFS)
N*N의 섬나라 아일랜드의 지도가 격자판의 정보로 주어집니다.   
각 섬은 1로 표시되어 상하좌 우와 대각선으로 연결되어 있으며, 0은 바다입니다.   
섬나라 아일랜드에 몇 개의 섬이 있는지 구하는 프로그램을 작성하세요. 

```javascript
function solution(board) {
    let answer = 0;
    let n = board.length;
    let dx = [-1, -1, 0, 1, 1, 1, 0, -1];
    let dy = [0, 1, 1, 1, 0, -1, -1, -1];

    function DFS(x, y) {
        for (let  k = 0; k < 8; k++) {
            let nx = x + dx[k];
            let ny = y + dy[k];
            if (nx>=0 && nx < n && ny>=0 && ny<n && board[nx][ny] === 1) {
                board[nx][ny] = 0;
                DFS(nx, ny);
            }
        }
    }

    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            if (board[i][j] === 1) {
                board[i][j] = 0;
                answer++;
                DFS(i, j);
            }
        }    
    }
    return answer;
}

console.log(solution([[1, 1, 0, 0, 0, 1, 0], [0, 1, 1, 0, 1, 1, 0], [0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 1], [1, 1, 0, 1, 1, 0, 0], [1, 0, 0, 0, 1, 0, 0], [1, 0, 1, 0, 1, 0, 0]]));
```
* 1로 연결된 덩어리들의 개수 찾기 문제
* 8방향 탐색이니까 방향 배열 초기화를 잘 해줘야 한다.
* 반복문으로 board를 돌면서 값이 1이면 섬을 발견한 것이므로 answer를 증가시킨다.
	* 발견한 곳이므로 값을 0으로 바꾸고, 해당 인덱스를 보내서 DFS를 실행시킨다.
*  해당 인덱스를 기준으로 인덱스를 상하좌우 대각선으로 바꿔가며 섬이 있는지 탐색한다.
	* 있다면 해당 인덱스를 찾았으니 0으로 바꾸고, 다시 DFS를 호출한다.


## 최대 선호 음식(DFS)
엘리트 학원에서 선생님과 학생들이 소풍을 갔습니다. 선생님들은 학생들에게 요리를 해주기로 마음먹고, 학생들에게 각자의 취향에 대해서 물었다.    
선생님들이 가지고 있는 양념재료의 종류는 D(1≤D≤15)종류입니다. 양념재료는 1부터 D까지 번호로 매겨져 있다.   
각각의 학생들은 자기가 원하는 재료가 꼭 다 들어가야만 음식을 먹겠다고 합니다.   
학생들은 총 N(1≤N≤30,000)명이 있고, 선생님이 사용할 수 있는 재료의 종류가 K(1≤K≤D)개 이하가 되도록 하려 한다.  위의 조건을 만족하면서 최대 몇 명의 학생에게 음식을 만들어 줄 수 있는지 구하는 프로그램을 작성하세요. 

```javascript
function solution(nums, d, k) {
    let answer = Number.MIN_SAFE_INTEGER;
    n = nums.length;
    pow = Array.from({length:d+1}, () => 0);
    st= Array.from({length:n}, () => 0);

    pow[1] = 1;
    for(let i = 2; i <= d; i++) {
        pow[i]= pow[i-1] * 2;
    }

    for(let i=0; i<n; i++) {
        for(let j = 0; j < nums[i].length; j++) {
            st[i] += pow[nums[i][j]];
        }
    }

    function DFS(L, s, bit) {
        if (L === k) {
            let cnt=0;
            for (let j = 0; j < n; j++) {
                if((bit  & st [j]) === st[j]) cnt++;
            }
            answer = Math.max(answer, cnt);
        }
        else {
            for (let  i = s; i <= d; i++) {
                DFS(L+1, i+1, bit+pow[i]);
            } 
        }
    }
    DFS(0, 1, 0);
    return answer;
}
```
* 비트 연산자를 활용해야 하는 문제이다.
* pow 배열에는 양념 번호와 매치 시켜 이진수로 표현해서 있으면 1, 없으면 0이라고 생각하고 가중치를 저장한다.
* st 배열은 pow 가중치를 적용한 학생들의 원하는 요리를 숫자화 시킨 것이다.
* 요리를 제한하는 개수만큼 뽑아서 조합하여, 학생들의 원하는 요리를 가장 많이 만족하는 개수를 반환한다.
	* 원하는 요리를 만족하는지는 비트 연산자를 사용해서 해결한다.


## 토마토(BFS)
현수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림 과 같이 격자 모양 상자의 칸에 하나씩 넣어서 창고에 보관한다. 
창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 
보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 
하나의 토마토의 인접한 곳은 왼쪽, 오른쪽, 앞, 뒤 네 방향에 있는 토마토를 의미한다.
 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 현수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지, 그 최소 일수를 알고 싶어 합니다. 
단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다. 

```javascript
function solution(board) {
    let answer = 0;
    let n = board.length;
    let m=board[0].length;
    let dx=[-1, 0, 1, 0];
    let dy=[0, 1, 0, -1];
    let dist=Array.from(Array(n), () => Array(m).fill(0));
    let queue=[];

    function BFS() {
        while(queue.length) {
            let cur =queue.shift();
            for(let j=0; j<4; j++) {
                let nx = cur[0] + dx[j];
                let ny = cur[1] + dy[j];
                if(nx>=0 && nx<n && ny>=0 && ny<m && board[nx][ny] === 0) {
                    board[nx][ny] = 1;
                    dist[nx][ny] = dist[cur[0]][cur[1]]+1;
                    queue.push([nx, ny]);
                    answer=dist[nx][ny];
                }
            }
        }
    }
    for(let i = 0; i < n; i++) {
        for(let j = 0; j < m; j++) {
            if(board[i][j] === 1) {
                dist
                queue.push([i, j]);
            }
        }
    }
    BFS();
   
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            if(board[i][j] === 0) return -1;
        }
    }

    return answer;
}

console.log(solution([[0, 0, -1, 0, 0, 0], [0, 0, 1, 0, -1, 0], [0, 0, -1, 0, 0, 0], [0, 0, 0, 0, -1, 1]]));
```
* 방향 배열과, 익은 날짜를 저장하는 배열, BFS를 사용해서 해결한 문제
* 마지막에 for문에서 익지 않은 토마토가 있는지 확인하여 그렇다면 -1을 반환하고, 그렇지 않다면 토마토가 모두 익는데 걸린 날짜를 반환한다.


