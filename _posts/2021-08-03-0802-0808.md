---
title: "0802-0808"
tag: TIL
category: TIL
---
## 0802
# 16일 차 재귀함수, DFS, BFS


## 재귀함수를 이용한 이진수 출력
10진수 N이 입력되면 2진수로 변환하여 출력하는 프로그램을 작성하세요. 단 재귀함수를 이용 해서 출력해야 합니다. 

```javascript
function solution(n) {
    let answer = 0;
    let tmp = [];

    function DFS(n) {
        if (n === 0) return;
        else {
            DFS(parseInt(n / 2));
            tmp.push(n % 2);
        }
    }
    DFS(n);

    for (let i = 0; i < tmp.length; i++) {
        answer = answer * 10 + tmp[i];
    }

    return answer;
}

console.log(solution(11));
```
* n이 0이 될 때까지 재귀함수로 호출하여 빈 배열 tmp에 n을 2로 나눈 나머지를 push했다.
* tmp에 있는 요소를 숫자형으로 변환했다.


## 이진트리 순회
이진트리를 전위순회와 후위순회를 연습해보세요. 

```javascript
function solution(n) {
    let answer = "";
    function DFS(v) {
        if (v > 7) return;
        else {
            answer += v;
            DFS(v * 2);
            DFS(v * 2 + 1);
        }
    }
    DFS(n)

    return answer;
}

console.log(solution(1));
```
* `answer += v` 코드를 재귀함수 앞에 두면 전위, 가운데 두면 중위, 끝에 두면 후위순회이다.


## 부분집합 구하기(DFS)
자연수 N이 주어지면 1부터 N까지의 원소를 갖는 집합의 부분집합을 모두 출력하는 프로그램을 작성하세요. 

```javascript
function solution(n) {
    let answer = [];
    let tmp = [];

    function DFS(L) {
        if (L === n + 1) {
            if(tmp.length !== 0) answer.push(tmp.slice());
        }
        else { 
            tmp.push(L);
            DFS(L + 1);
            tmp.pop(L);
            DFS(L + 1);
        }
    }
    DFS(1);

    return answer;
}
console.log(solution(3));
```
* tmp에 요소를 push하고 재귀 함수 호출, pop하고 재귀 함수를 호출하여 부분집합을 구했다.
* 주의할 점은 answer에 배열인 tmp를 push할 때 slice()메소드를 사용해야지만 깊은 복사가 되어 제대로 복사된다.
* 트리로 그려보면, 각 요소를 넣었을 때와 안넣었을 때로 구분하는 상황이 나온다.

## 합이 같은 부분집합 
N개의 원소로 구성된 자연수 집합이 주어지면, 이 집합을 두 개의 부분집합으로 나누었을 때 두 부분집합의 원소의 합이 서로 같은 경우가 존재하면 “YES"를 출력하고, 그렇지 않으면 ”NO"를 출력하는 프로그램을 작성하세요.  
둘로 나뉘는 두 부분집합은 서로소 집합(Disjoint Set)이며, 두 부분집합을 합하면 입력으로 주어진 원래의 집합이 되어야 합니다.   
예를 들어 {1, 3, 5, 6, 7, 10}이 입력되면 {1, 3, 5, 7} = {6, 10} 으로 두 부분집합의 합이 16으로 같은 경우가 존재하는 것을 알 수 있다. 

```javascript
function solution(nums) {
    let answer = "NO";
    let total = nums.reduce((acc, current) => acc + current, 0);
    let flag = false;

    function DFS(L, sum) {
        if (L === nums.length) {
            if(flag) return;
            if(total-sum === sum) {
                answer="YES"
                flag=true;
            }
        }
        else {
            DFS(L+1, sum + nums[L]);
            DFS(L+1, sum);
        }
    }
    DFS(0, 0);

    return answer;
}

console.log(solution([1, 3, 5, 6, 7, 10]));
console.log(solution([5, 2, 6, 9, 10, 12]));
console.log(solution([3, 9, 11, 13]));
```
* 매개변수를 잘 활용해야 하는 문제
* L을 인덱스 번호처럼 사용해서 해결한다.
* 모든 수의 합을 구하고, 모든 수에서 일정 수까지 더한 값을 뺐을 때 그 값이 나오면 합이 같은 두 부분집합이 있다는 뜻으로, YES를 반환한다.
* 부분집합이 문제에 나온다면, DFS를 떠올려보자


## 바둑이 승차
철수는 그의 바둑이들을 데리고 시장에 가려고 한다.   
그런데 그의 트럭은 C킬로그램 넘게 태울수가 없다. 철수는 C를 넘지 않으면서 그의 바둑이들을 가장 무겁게 태우고 싶다.  
N마리의 바둑이와 각 바둑이의 무게 W가 주어지면, 철수가 트럭에 태울 수 있는 가장 무거운 무게를 구하는 프로그램을 작성하세요. 

```javascript
function solution(nums, c) {
    let answer = 0;
    let total = nums.reduce((acc, current) => acc + current, 0); 

    function DFS(L, sum, tsum) {
        if (sum > c) return;
        if ((total - tsum + sum) < answer) return;
        if (L === nums.length) {
            answer = Math.max(answer, sum);
        }
        else {
            DFS(L+1, sum + nums[L], tsum + nums[L]);
            DFS(L+1, sum, tsum + nums[L]);
        }
    }
    DFS(0, 0, 0);
    return answer;
}
console.log(solution([81, 58, 42, 33, 61], 259));
```
* 재귀적으로 L을 1씩 증가시켜가며 바둑이를 태웠을 때와 안태웠을 때로 나누어 sum을 계산한다.
* sum이 최대 무게를 넘어서면 더 이상 진행할 필요가 없으므로 return 한다.
* tsum은 현재까지 모든 강아지를 태웠을 때로 가정하고 무게를 모두 더한다.
	* total은 모든 강아지의 무게인데, 여기서 tsum을 빼면 앞으로 남은 강아지를 모두 태웠을 때의 무게이다.
	* 그 값에 현재 sum을 더해도 answer에 담긴 값보다 작을 때는 앞으로 남은 강아지를 모두 태워도 정답이 될 수 없기 때문에 return 한다.


## 최대점수 구하기
이번 정보올림피아드대회에서 좋은 성적을 내기 위하여 현수는 선생님이 주신 N개의 문제를 풀려고 합니다.   
각 문제는 그것을 풀었을 때 얻는 점수와 푸는데 걸리는 시간이 주어지게 됩니다.   
제한시간 M안에 N개의 문제 중 최대점수를 얻을 수 있도록 해야 합니다. (해당문제는 해당시간이 걸리면 푸는 걸로 간주한다, 한 유형당 한개만 풀 수 있습니다.) 

```javascript
function solution(nums, m) {
    let answer = 0;

    function DFS(L, sum, time) {
        if (time > m) return;
        if (L === nums.length) {
            answer = Math.max(answer, sum);
        }
        else {
            DFS(L + 1, sum + nums[L][0], time + nums[L][1]);
            DFS(L + 1, sum, time);
        }
    }
    DFS(0, 0, 0);

    return answer;
}

console.log(solution([[10, 5], [25, 12], [15, 8], [6, 3], [7, 4]], 20));
console.log(solution([[15, 6], [30, 11], [23, 8], [14, 4], [10, 3], [20, 7]], 25));
```
* 바둑이 승차 문제와 비슷한 방법으로 해결하면 된다.
* 입력이 많을 때 시간을 줄이고 싶다면, total을 구해서 최적의 해답이 아니라면 return하는 코드를 삽입해도 좋다.



## 중복 순열 구하기
1부터 N까지 번호가 적힌 구슬이 있습니다.   
이 중 중복을 허락하여 M번을 뽑아 일렬로 나열하는 방법을 모두 출력합니다. 

```javascript
function solution(n, m) {
    let answer = [];
    let tmp = [];

    function DFS(L) {
        if (L === m) {
            answer.push(tmp.slice());
        }
        else {
            for(let i = 1; i <= n; i++) {
                tmp.push(i);
                DFS(L+1);
                tmp.pop();
            }
        }

    }
    DFS(0);

    return answer;
}

console.log(solution(3, 2));
```
* L을 1씩 증가시키며 재귀호출을 해서 해결하는 문제이다.
* m은 깊이를 지정하고, for문은 n의 개수만큼 재귀를 하기 위해서 사용한다.


## 순열 구하기
10이하의 N개의 자연수가 주어지면 이 중 M개를 뽑아 일렬로 나열하는 방법을 모두 출력합니다. 

```javascript
function solution(nums, m) {
    let answer = [];
    let tmp = [];
    let ch=Array.from({length: nums.length}, () => 0);


    function DFS(L) {
        if(L === m) {
            answer.push(tmp.slice());
        } 
        else {
            for (let i = 0; i <=nums.length; i++) {
                if (ch[i] === 0) {
                    ch[i] = 1;
                    tmp.push(nums[i]);
                    DFS(L+1);
                    tmp.pop();
                    ch[i] = 0;
                }
            }
        }
    }
    DFS(0);

    return answer;
}

console.log(solution([3, 6, 9], 2));
```
* 중복 순열구하기 문제에서 조금만 바꾸면 일반 순열 구하기가 된다.
* nums 길이만큼 ch 배열을 초기화 시켜두고, ch[i]가 0일 때만 코드를 동작시킨다.
* 그리고 내부에서 사용한 인덱스의 값을 1로 바꾸고, 다 사용한 뒤 0으로 바꾸면 중복해서 숫자가 조합되지 않는다.

## 조합의 경우수(메모이제이션)
아래 공식을 사용하여 재귀를 이용해 조합수를 구해주는 프로그램을 작성하세요. 
`nCr = n-1Cr-1 + n-1Cr`

```javascript
function solution(n, r) {
    let answer;
    let dy = Array.from(Array(35), () => Array(35).fill(0));

    function DFS(n, r) {
        if (dy[n][r]>0) return dy[n][r];
        if (n === r || r === 0) return 1;
        else {
            return dy[n][r] = DFS(n - 1, r - 1) + DFS(n - 1, r);
        }
    }
    answer = DFS(n, r);
    return answer;
}

console.log(solution(33, 19));
```
* 조합의 경우수를 구해야 하는 경우 메모이제이션을 사용하면 코드가 동작하는 시간을 획기적으로 줄일 수 있다.
* 메모이제이션은 같은 값을 다른 곳에서 자주 사용하는 경우 사용하는 기법으로, 재귀에서 주로 사용한다.
* `Array.from()` 메소드는 첫 번째 매개변수로는 배열로 변환하고자 하는 배열 객체나 반복 가능한 객체가 들어가고, 두 번째 매개변수로는 map 콜백함수가 들어간다.
	* 위의 코드에서 첫 번째 매개변수에 Array(35)를 넣었으므로 길이 35의 배열이 들어가고, 두 번째 매개변수에서 Array(35)를 0으로 채워서 반환하므로 35 x 35의 2차원 배열이 생성된다.
	* 첫 번째 매개변수에서 `{length: 20}`을 넣으면 배열이 생성되는 이유는 배열도 객체이기 때문이다. object에 Array 메소드들과 iterator, length 속성을 넣어준 것이 배열이기 때문에 첫 번째 인자로 `{length: 20}` 같은 것을 건내준다면 배열로 인식하여 코드가 동작한다.
* 이후 메모이제이션 기법을 사용해서 n, r에 값을 저장해놓고, DFS가 실행될 때마다 n, r로 조회하여 값이 있다면 더 이상 재귀 호출을 하지 않도록 한다.


## 수열 추측하기
가장 윗줄에 1부터 N까지의 숫자가 한 개씩 적혀 있다. 그리고 둘째 줄부터 차례대로 파스칼의 삼각형처럼 위의 두개를 더한 값이 저장되게 된다.   
예를 들어 N이 4 이고 가장 윗 줄에 3 1 2 4 가 있다고 했을 때, 다음과 같은 삼각형이 그려진다.  


3 1 2 4   
 4 3 6   
  7 9   
  16   

  
N과 가장 밑에 있는 숫자가 주어져 있을 때 가장 윗줄에 있는 숫자를 구하는 프로그램을 작성하시오.   
단, 답이 여러가지가 나오는 경우에는 사전순으로 가장 앞에 오는 것을 출력하여야 한다. 

```javascript
function solution(n, f) {
    let answer;
    let ch = Array.from({length: n + 1}, () => 0);
    let p = [];
    let b = [];
    let flag = false;

    b.push(1);
    for (let i = 1; i < n; i++) {
        b[i] = b[i - 1] * (n - i) / i;
    }

    function DFS(L, s) {
        if (flag) return;
        if (L === n) {
            if (s === f) {
                answer = p.slice();
                flag = true;
            }
        }
        else {
            for (let i = 1; i <= n; i++) {
                if (ch[i] === 0) {
                    ch[i] = 1;
                    p.push(i);
                    DFS(L + 1, s + i * b[L]);
                    p.pop();
                    ch[i] = 0;
                }
            }
        }
    };
    DFS(0, 0);

    return answer;
}

console.log(solution(4, 16));
console.log(solution(5, 50));
```
* 상당히 어려웠고, 이해하는데에도 많은 시간이 걸린 문제
* 우선 파스칼의 삼각형이 이항계수와 관련되어 있다는 규칙을 먼저 알아채야만 했다.
* n개를 받았을 때, 이항계수 배열을 만드는 반복문을 실행했다.
* DFS 재귀함수를 호출해서 L이 n이 되기 전까지는 순열을 구하고, sum에는 위치한 값에 이항계수 값을 곱해서 더해주었다.
* L이 n이 되면 해당 순열이 가장 밑에 있는 줄의 값과 같은지 비교해서 같은 경우에만 answer에 추가하고 사전순으로 가장 앞에 오는 값을 구했으므로, flag를 바꿔서 더 이상 재귀호출이 되지 않도록 했다.


## 조합 구하기
1부터 N까지 번호가 적힌 구슬이 있습니다.   
이 중 M개를 뽑는 방법의 수를 출력하는 프로그램을 작성하세요. 

```javascript
function solution(n, m) {
    let answer = [];
    let tmp = [];

    function DFS(L, s) {
        if (L === m) {
            answer.push(tmp.slice());
        }
        else {
            for (let i = s; i <= n; i++) {
                tmp.push(i);
                DFS(L+1, i+1);
                tmp.pop();
            }
        }
    }
    DFS(0, 1);

    return answer;
}
```
* 이 코드는 외울 것
* for문이 꼭 처음에 뽑은 숫자 이후의 숫자부터 돌아야 한다.
* 순열은 (1, 2)와 (2, 1)이 다른 것이라면, 조합은 같은 것이다.
* 매개변수에 i 이후부터 시작하도록 저장하는 s를 넣어서 사용하여 해결
* 반복문을 i = s부터 시작하도록 설정하고, 재귀 호출을 할 때 s에 i + 1을 넣어서 호출하면, i는 i다음 인덱스부터 반복문이 돌아가기 때문에 조합을 제대로 출력한다.



