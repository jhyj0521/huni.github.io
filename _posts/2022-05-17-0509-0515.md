---
title: "0509 - 0515"
tag: TIL
category: TIL
excerpt: ""
---

## 0512

# Vanilla JavaScript로 웹 컴포넌트 만들기

최근에는 바닐라 자바스크립트만을 사용하여 기업들의 과제 전형을 두 차례 진행했다.  
그 중 한 기업에서는 기존에 사용하던 방식대로 controller, store, render로 파일을 구분하여 기능을 구현하였는데, 이번 기회에는 새로운 도전 방식으로 구현해보고자 도전하게 되었다.  
방식은 프로그래머스 사전 과제의 고양이 사진첩 만들기와 황준일 개발자님의 블로그를 참고하였다.

## 컴포넌트와 상태 관리

브라우저와 자바스크립트가 발전하는 과정에서 아예 브라우저 단에서 렌더링을 하고, 서버에서는 REST API 혹은 GraphQL 같이 브라우저 렌더링에 필요한 데이터만 제공하는 형태로 기술이 변화했다.

이제는 직접적으로 DOM을 다루는 행위가 급격하게 감소했고, 상태를 기준으로 DOM을 렌더링하는 형태로 발전한 것이다. DOM이 변하는 경우가 상태에 종속 되어버린 것이다. 반대로 말하면, State가 변하지 않을 경우 DOM이 변하면 안 되는 것이다. 이러한 과정 속에서 CSR이라는 개념과 상태 관리라는 개념이 생기게 되었다.

SSR을 사용하는 시절에는 서버에서 HTML을 만들어서 클라이언트에 넘겨주었기에 브라우저에서는 굳이 데이터의 깊은 단계까지, 정교하게 관리할 필요가 없었다. 그러나 브라우저 단에서 렌더링을 하기 위해선, 렌더링에 필요한 상태를 정교하게 관리해야 한다. 그래서 Redux 같은 상태관리 라이브러리가 생겨났다.

## Entry Point

시작점은 index.js에서부터 시작한다.

```javascript
import App from "./components/App";

new App(document.querySelector("#app"));
```

엔트리 포인트에서는 상위 부모 컨테이너 역할을 할 App 컴포넌트를 불러와서 생성하고, 인자로 id가 app인 DOM을 넘긴다.

## 컴포넌트 추상화

새로운 패턴의 JS 개발을 보며 리액트와 코드가 상당히 닮아있다는 생각을 했다.  
이전과는 다르게 클래스 문법을 사용해서 컴포넌트를 구현하였고, 공통되는 코드 로직을 Component 클래스로 추상화하고, 이를 위임받아 사용하도록 작성했다.

```javascript
export default class Component {
  constructor($target, props) {
    this.$target = $target;
    this.props = props;

    this.setUp();
    this.setEvent();
    this.render();
  }

  setUp() {}

  template() {
    return "";
  }

  render() {
    this.$target.innerHTML = this.template();

    this.mounted();
  }

  mounted() {}

  setEvent() {}

  setState(newState) {
    this.state = { ...this.state, ...newState };

    this.render();
  }
}
```

- 모든 컴포넌트는 해당 컴포넌트를 렌더링 할 상위 컴포넌트와 상위 컴포넌트로부터 전달받을 props를 파라미터로 받는다.
- constructor에서는 전달받은 파라미터를 인스턴스의 값으로 저장하고, setUp, setEvent, render 메서드를 호출한다.
- setUp에서는 상태 초기화를 담당한다.
- render에서는 파라미터로 전달받은 target에 template에 정의한 값을 innerHTML로 할당하고, mounted 메서드를 호출한다. mounted에서는 하위의 컴포넌트를 불러와서 생성하는 코드를 작성한다.
- setEvent에서는 이벤트 위임을 활용하여 이벤트 핸들러를 구현한다.
- setState로 상태가 변경되면 다시 리렌더링이 발생하는 구조이다. 여기서 state는 setState로만 변경해야 한다.

## 사용 예시

```javascript
import Component from "./Component";

export default class Modal extends Component {
  template() {
    const { showModal } = this.props;

    return `
      ${
        showModal
          ? `
            <div class="modal-content">
              <h2>강의 추가</h2>
              <div class="title">
                <label for="course-title-input">강의 제목</label>
                <input
                  type="text"
                  id="course-title-input"
                  class="course-title-input"
                  placeholder="강의 제목을 입력해주세요"
                  autocomplete="off"
                />
              </div>
              <div class="price">
                <label for="course-price-input">강의 가격</label>
                <input
                  type="number"
                  id="course-price-input"
                  class="course-price-input"
                  placeholder="강의 가격을 입력해주세요"
                  step="1000"
                  autocomplete="off"
                />
              </div>
              <div class="btn-group">
                <button type="button" class="cancel-btn">취소</button>
                <button type="button" class="confirm-btn">확인</button>
              </div>
            </div>
            <div class="dim"></div>`
          : ""
      }
    `;
  }

  setEvent() {
    const { closeModal, addCourse } = this.props;

    this.$target.addEventListener("click", (e) => {
      if (e.target.classList.contains("cancel-btn")) closeModal();
      else if (e.target.classList.contains("confirm-btn")) {
        const title = document
          .querySelector(".course-title-input")
          .value.trim();
        const price = document.querySelector(".course-price-input").value;

        if (title === "") {
          alertErrorMessage("강의 제목을 입력해주세요.");
          return;
        }
        if (price === "" || +price < 0) {
          alertErrorMessage("강의 가격에는 0 이상의 숫자만 입력해주세요.");
          return;
        }

        addCourse(title, price);
      }
    });
  }
}
```

- 위의 컴포넌트를 사용한 예시이다. template 메서드를 확장하여 사용하면 자동으로 render 메서드가 실행되고, 불필요한 코드를 반복해서 사용해야할 필요가 사라진다.

<br />
<br />
<br />

## 0513

# GraphQL

기존 Rest API 통신은 크게 두 가지 문제점을 가지고 있다.

## over fetching

- 필요한 것보다 더 많은 데이터를 가져온 경우
- 예를 들어, 영화 API로 데이터를 불러와서 그 중 제목 데이터만 사용하는 경우 나머지 정보는 필요 없게 되는데 이를 오버 패칭이라고 함
- GraphQL은 쿼리 랭귀지이기 때문에 정확하게 필요한 정보만 요청할 수 있어서, 필요없는 데이터는 받지않고 정확히 필요한 정보만 요청할 수 있다.

## under fetching

- 필요한 것보다 적은 양의 데이터를 가져온 경우
- 영화 API에서 곧 개봉하는 영화와 현재 상영중인 영화 데이터를 받아와야 할 경우 REST를 사용한다면 2개의 각기 다른 URL로 요청을 보내야 한다. 이는 로딩 타임 증가로 이어진다. GraphQL을 사용하면 1개의 쿼리로 2개의 정보를 한 번에 요청할 수 있다.

먼저 특정 기능을 위해 여러번 api가 호출되고, 특정 요청에 적절한 응답을 돌려주기 위해서는 api를 새로 만들어야 합니다.
그리고 api를 유지보수하기 어렵다는 문제점이 있습니다.
즉, 관리해야 할 endpoint의 증가로 인하여 발생되는 문제점입니다.

기존의 rest api에서 정보를 얻기 위해 여러번 네트워크를 호출하거나 ,다양한 api를 호출해야 했습니다.  
하지만 graphql은 단 하나의 endpoint를 제공하며, 단 한 번의 요청으로 모든 정보를 가져옵니다.

## 장단점

### 장점

- 오버 패칭과 언더 패칭의 문제를 개선해준다.
- HTTP 요청 횟수와, 응답 사이즈를 줄일 수 있음

### 단점

- http 캐싱이 REST보다 복잡함
- 파일 전송 등 Text만으로 하기 힘든 작업들을 처리하기 복잡함
- 고정된 요청과 응답만 필요할 경우 Query로 인해 요청의 크기가 REST API보다 커짐

## 사용하기 좋은 경우

### GraphQL

- 서로 다른 모양의 다양한 요청들에 대해 응답할 수 있어야 할 때
- 대부분의 요청이 CRUD에 해당할 때

### REST API

- 캐싱 기능을 잘 사용하고 싶을 때
- 파일 전송 등 단순한 Text로 처리되지 않는 요청들이 있을 때
- 요청의 구조가 명확하게 정해져 있을 때

<br />
<br />
<br />

## 0514

최근에 디자인 패턴 공부에 대한 중요성을 느끼고 나서, 제대로 정리해보고자 개인 스터디를 시작하게 되었다.

스터디 내용은 [Refactoring guru](https://refactoring.guru/design-patterns/what-is-pattern)의 링크에 있는 정리 내용을 보고 학습할 계획이다.  
물론 모든 패턴 내용을 처음부터 끝까지 다 살펴보면 제일 좋겠지만, 전부터 궁금했던 패턴들 우선적으로 살펴볼 예정이다.  
이번 스터디가 아키텍처를 설계하는 데에 있어 많은 도움이 되기를 희망한다.

---

# 디자인 패턴이란?

디자인 패턴은 소프트웨어 디자인에서 일반적으로 발생하는 문제들에 대한 일반적인 해결책이다.  
이는 코드에서 반복되는 디자인 문제를 해결하기 위해 사용자 지정할 수 있는 청사진과도 같다.

패턴은 특정 코드 조각이 아니라 특정 문제를 해결하기 위한 일반적인 개념이다. 패턴 세부 사항을 따르고 자신의 프로그램의 현실에 맞는 솔루션을 구현할 수 있다.

알고리즘과 디자인 패턴은 모두 일반적인 솔루션을 설명하기 때문에 종종 혼동된다. 하지만 알고리즘은 항상 어떤 목표에 달성할 수 있는 명확한 일련의 작업을 의미하지만, 패턴은 솔루션에 대한 보다 높은 수준의 설명이다. 두 개의 다른 프로그램에 적용된 동일한 패턴의 코드는 다를 수 있다.

알고리즘을 비유하자면 요리법이라고 할 수 있다. 반면, 패턴은 청사진에 가깝다. 결과와 특징이 무엇인지 확인할 수 있지만, 정확한 구현 순서는 사용자에게 달려있다.

### 패턴의 역사

패턴은 객체 지향 설계의 일반적인 문제에 대한 일반적인 솔루션이다.  
다양한 프로젝트에서 솔루션이 계속 반복되면 누군가는 결국 이름을 지정하고 솔루션을 설명한다. 이것이 기본적으로 패턴이 발견되는 방법이다.

### 패턴을 배워야 하는 이유

- 디자인 패턴은 소프트웨어 디자인의 일반적인 문제에 대한 **시도되고 테스트된 솔루션**의 툴킷이다. 이러한 문제가 발생하지 않더라도 패턴을 아는 것은 객체 지향 설계 원칙을 사용하여 모든 종류의 문제를 해결하는 방법을 가르쳐주기 때문에 여전히 유용하다.
- 디자인 패턴은 팀원이 보다 효율적으로 의사 소통하는 데 사용할 수 있는 공통 언어를 정의한다. 예를 들어, 패턴의 이름을 안다면 싱글톤이 무엇인지 설명할 필요가 없다.

### 패턴의 분류

디자인 패턴은 복잡성, 세부 수준 및 디자인 중인 전체 시스템에 대한 적용 범위에 따라 다르다.

가장 기본적이고 낮은 수준의 패턴은 종종 **idioms**(관용구)라고 불리는데 이들은 보통 하나의 프로그래밍 언어에만 적용된다.  
가장 보편적이고 높은 수준의 패턴은 **architectural patterns**(아키텍처 패턴)이다. 개발자는 이러한 패턴을 대부분의 언어로 구현할 수 있다. 다른 패턴과 달리 전체 애플리케이션 아키텍처를 설계하는 데 사용될 수 있다.

또한 모든 패턴은 **의도 또는 목적에 따라 분류**될 수 있다. 이 책은 세 가지 패턴의 주요 그룹을 다룬다.

- **Creational patterns**(생성 패턴)은 기존 코드의 유연성과 재사용성을 증가시키는 객체 생성 메커니즘을 제공한다.
- **Structural patterns**(구조적 패턴)은 구조를 유연하고 효율적으로 유지하면서 객체와 클래스를 더 큰 구조로 조립하는 방법을 설명한다.
- **Behavioral patterns**(행동 패턴)은 효과적인 의사소통과 객체 간의 책임 할당을 처리한다.
