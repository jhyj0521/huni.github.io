---
title: "0913-0919"
tag: TIL
category: TIL
---

## 0913

# 46일 차

## 1교시

Number.isNaN은 타입이 Number이고 값이 NaN인 경우에만 true를 반환한다.  
반면 isNaN은 숫자 타입으로 암묵적 형번환을 한 뒤 비교한다.

화살표 함수는 무조건 익명 함수 표현식으로 써야 한다.

## 2교시

프로퍼티 축약표현  
메서드 축약표현  
-> 단어도 기억해둘 것

객체의 프로퍼티 값에 function 키워드로 들어가는 경우에는 메서드가 아니라 함수다.  
함수라고 하는 것은 여러가지 용도가 있다. 일반적인 용도로 쓰는 것을 일반함수, 객체를 생성할 수 있는 능력을 가지고 있는 함수를 생성자 함수라고 한다.  
`객체.메서드명();`는 메서드로서 호출했다고 한다.  
일반적으로 메서드라고 함은 프로퍼티로 값이 함수가 온 것이다. 위에서 말한 메서드는 스펙 상의 메서드  
메서드 축약 표현을 사용해서 표기하는 방법만 사용하도록 한다.

원시 타입은 기본 타입이라고 부르기도 한다. -> primitive  
원시 타입은 변경 불가능한 값이다. -> immutable  
객체는 변경 가능한 값이다. -> mutable

- 단 선두 어드레스는 바뀌지 않는다.

객체도 원시값처럼 사용하려는 움직임이 보이고 있다.  
두 객체가 값이 같은지 비교하는 함수 만들기 -> 숙제  
isEqual, deepCopy

## 3교시

매개변수와 인수의 개수가 다를 때 어떻게 처리할 것인가?  
-> Arguments 객체의 length를 확인한다.  
단, 화살표 함수의 경우 arguments 객체를 갖지 않는다.  
-> 이때는 매개변수를 `...args`로 받아와야 한다. 이렇게 하면 인수들이 배열로 들어오게 된다.

자바스크립트에서 프로퍼티 키에 해당하는 값이 없으면 undefined가 나온다.

함수명(매개변수) 의 함수 호출 연산자의 경우 앞에 함수명과 같은 식별자가 있는지 찾는다.  
또한 식별자가 함수인지까지 확인한다.

호이스팅은 선언문이 스코프의 상단에 끌어올려지는 것처럼 동작하는 특징이다. 그래서 함수 선언문은 런타임 이전에 함수 호이스팅이 발생해서 선언문 이전에 호출이 가능하다.

가장 좋은 방법은 arrow function -> 가독성  
ajax 호출에서 객체를 바로 생성해서 보내는 이유  
-> 변수에 담지 않고 한 번만 사용해서 다시 재사용하지 못하게 하기 위해서

## 4교시

중첩 함수  
가독성과 재사용성 측면에서 함수를 외부 함수 내에 만든 것이다.

콜백 함수는 고차 함수를 호출할 때 인수로 사용되는 함수를 뜻한다.  
콜백함수는 중첩함수와 연관이 있는데, 중첩함수는 고정적이므로 외부함수와 의존성이 높다. 반면 콜백함수는 외부에서 주입하는 것이므로 함수의 자유도가 높아진다.

항상 하는 일 + 계속 바뀌는 일  
여기서 항상 하는 일은 고차함수의 기본 세팅으로 놔두고, 바뀌는 일을 콜백함수로 주입하여서 구현한다.

콜백함수는 대부분 고차함수가 호출한다. but 콜백함수를 고차함수가 호출하지 않는 경우가 있는데 그것이 바로 비동기이다.

predicate는 콜백 함수인대, true나 false를 반환하는 콜백함수이다.  
자바스크립트는 싱글 스레드, 브라우저는 멀티 스레드이기 때문에 비동기 함수에서 기다렸다가 호출하는 일을 브라우저에게 위임한다.

## 0914

# 47일 차

## 2교시

다른 함수는 메인함수(진입점)이 존재하는 함수가 많다.  
그러나 자바스크립트는 진입점이 존재하지 않는다.  
자바스크립트 파일을 불러들이게 되면 로드하고 바로 실행한다.

모듈은 파일을 구분했을 때 파일들이 스코프를 갖는다. (간단하게 얘기한 것)  
export와 import 키워드 두개를 통해서 다른 스코프에 있는 데이터를 가지고 올 수 있다.

테스트와 코드를 분리해서 만들어야 한다. 왜냐하면 테스트를 배포해서는 안되기 때문이다.

jest에서 toBe는 ===, toEqual은 내용이 같아야 한다.

## 3교시

식별자는 유효한 범위가 있는데, 스코프라는 것이 사라지면 그 안에 있었던 식별자들도 같이 날라간다.  
호이스팅이란 스코프의 최상단으로 끌어올려진 것처럼 보여지는 것

스코프라는 것은 개념이 아니라 자료구조가 있다고 생각하는 것이 쉽다.  
-> 렉시컬 환경

모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다.

상속과 스코프는 유사한 개념. 둘 다 밑에서 위만 볼 수 있다.

var는 함수 레벨 스코프, let과 const는 블록 레벨 스코프

함수가 호출되면 객체가 하나 만들어진다.  
함수안의 식별자들은 사실 실체안의 프로퍼티 키와 값으로 존재한다.

어떻게 런타임 이전에 변수를 선언할까?  
AST를 만들어서 선언문만 쫙 뽑아낸다.  
함수 또한 선언문을 호이스팅하기 때문에 선언한다. 함수 객체를 텍스트로 정의한다 (껍데기만).  
함수는 호출이 발생하기 전까지는 함수 몸체 내용은 쳐다도 안본다.

식별자는 스코프 체인, 객체는 프로토타입 체인에 존재한다.  
식별자를 찾는 행위, 프로토타입을 찾는 행위를 해당 존재하는 공간에서 찾는다.

하위 스코프에서 식별자 이름이 같은 것을 먼저 찾아서 상위 스코프에 같은 이름을 가진 식별자가 무시당하는 것을 가리워졌다, 쉐도잉 등의 단어로 표현한다.  
그리고 이렇게 하위 스코프에서 식별자를 사용하기로 한 것을 식별자 결정이라고 한다.

전역 스코프는 스코프 체인의 종점

## 4교시

### 렉시컬 스코프 (정적 스코프)

상위 스코프를 어떻게 결정할 것인지의 메커니즘  
변수의 스코프는 선언문의 위치에 따라 결정된다.  
함수의 정의된 스코프가 상위 스코프이다.

반면 동적 스코프는 함수의 호출 위치가 상위 스코프를 결정한다.  
대부분의 언어는 렉시컬 스코프이다.

함수 객체(함수)는 객체와 다른점이 하나인대, 호출이 가능하다는 것이다.  
`[[call]]` 내부 슬롯을 가지고 있다.  
내부 슬롯이란 자바스크립트 엔진이 보기위한 프로퍼티이다. 그래서 사용자는 접근할 수 없다.

함수 객체는 자신이 생성될 때 내부 슬롯 environment를 가진다. environment의 값이 상위 스코프에 대한 참조이다.  
함수가 어디에 선언되는지에 상관없이 고정되는 이유.

모듈을 쓰는 환경에서는 전역변수를 선언할 수 없다.

책에 나와있는 모듈은 ESM이다.
