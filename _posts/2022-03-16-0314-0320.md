---
title: "0314 - 0320"
tag: TIL
category: TIL
excerpt: ""
---

## 0314

# 타입 주변에 null 값 배치하기

strictNullChecks 설정을 하면 null이나 undefined 값 관련된 오류들이 나타나게 된다.  
이 때, 값이 전부 null이거나 전부 null이 아닌 경우로 분명히 구분된다면, 값이 섞여 있을 때보다 다루기 쉽다.

```typescript
function extent(nums: number[]) {
  let min, max;

  for (const num of nums) {
    if (!min) {
      min = num;
      max = num;
    } else {
      min = Math.min(min, num);
      max = Math.max(max, num);
    }
  }
  return [min, max];
}
```

- 예를 들어, 이 코드에는 버그와 함께 설계적 결함이 존재한다.
- 최솟값이나 최댓값이 0인 경우, 값이 덧씌워져 버린다. 예를 들어, `extent([0, 1, 2])`의 결과는 `[1, 2]`가 된다.
- nums 배열이 비어 있다면 함수는 `[undefined, undefined]`를 반환한다.
- undefined를 포함하는 객체는 다루기 어렵고 권장하지 않는다. 코드를 살펴보면 min과 max가 동시에 undefined이거나 둘다 아니라는 것을 알 수 있지만, 이러한 정보는 타입 시스템에서 표현할 수 없다.
- strictNullChecks 설정을 하면 extent의 반환 타입이 `(number | undefined)[]`로 추론되어서 설계적 결함이 분명해진다.
- 이에 대한 적절한 해법은 min과 max를 한 객체 안에 넣고 null이거나 null이 아니게 하면 된다.

```typescript
function extent(nums: number[]) {
  let result: [number, number] | null = null;

  for (const num of nums) {
    if (!result) {
      result = [num, num];
    } else {
      result = [Math.min(result[0], num), Math.max(result[1], num)];
    }
  }
  return result;
}
```

- 이제는 반환 타입이 `[number, number] | null`이 되어 사용하기 수월해졌다.
- null 아님 단언을 사용하면 min과 max를 얻을 수 있다.
- extent 결과값으로 단일 객체를 사용함으로써 설계를 개선했고, 타입스크립트가 null 값 사이의 관계를 이해할 수 있도록 했으며 버그를 제거했다.

## 클래스 작성 시

클래스를 만들 때는 필요한 모든 값이 준비되었을 때 생성하여 null이 존재하지 않도록 하는 것이 좋다.

```typescript
class UserPosts {
  user: UserInfo;
  posts: Post[];

  constructor(user: UserInfo, posts: Post[]) {
    this.user = user;
    this.posts = posts;
  }

  static async init(userId: string): Promise<UserPosts> {
    const [user, posts] = await Promise.all([
      fetchUser(userId),
      fetchPostsForUser(userId),
    ]);

    return new UserPosts(user, posts);
  }
}
```

- 이와 같이 코드를 작성하면 클래스는 완전히 null이 아니게 되고, 메서드를 작성하기 쉬워진다.
- null인 경우가 필요한 속성은 프로미스로 바꾸면 안 된다. 코드가 매우 복잡해지며 모든 메서드가 비동기로 바뀌어야 한다.

# 유니온의 인터페이스보다는 인터페이스의 유니온 사용하기

유니온 타입의 속성을 가지는 인터페이스를 작성 중이라면, 인터페이스의 유니온 타입을 사용하는 게 더 알맞지 않을지 검토해 봐야 한다.

```typescript
interface Layer {
  layout: FillLayout | LineLayout | PointLayout;
  paint: FillPaint | LinePaint | PointPaint;
}
```

- layout 속성은 모양이 그려지는 방법과 위치를 제어하고, paint 속성은 스타일을 제어한다.
- layout이 LineLayout 타입이면서 paint 속성이 FillPaint 타입인 것은 무효한 상태이다.
- 더 나은 방법으로 모델링하려면 각각 타입의 계층을 분리된 인터페이스로 둬야 한다.

```typescript
interface FillLayer {
  layout: FillLayout;
  paint: FillPaint;
}

interface LineLayer {
  layout: LineLayout;
  paint: LinePaint;
}

interface PointLayer {
  layout: PointLayout;
  paint: PointPaint;
}

type Layer = FillLayer | LineLayer | PointLayer;
```

- 이런 형태로 Layer를 정의하면 layout과 paint 속성이 잘못된 조합으로 섞이는 경우를 방지할 수 있다.
- 이러한 패턴의 가장 일반적인 예시는 태그된 유니온이다.
- type 속성을 태그로 두어 태그를 참고하여 Layer의 타입 범위를 좁힐 수 있다.
- 어떤 데이터 타입을 태그된 유니온으로 표현할 수 있다면, 보통 그렇게 하는 것이 좋다.

## 여러 개의 선택적 필드가 동시에 값이 있거나, 없어야 하는 경우

```typescript
interface Person {
  name: string;
  // 다음은 둘 다 동시에 있거나 동시에 없다.
  placeOfBirth?: string;
  dateOfBirth?: Date;
}
```

- 타입 정보를 담고 있는 주석은 문제가 될 소지가 매우 높다.
- 두 선택적 필드는 실제로 관련되어 있지만, 타입 정보에는 어떤 관계도 표현되지 않았다.
- 두 개의 속성을 하나의 객체로 모으는 것이 더 좋은 설계이다.

```typescript
interface Person {
  name: string;
  birth?: {
    placeOfBirth: string;
    dateOfBirth: Date;
  };
}
```

- 이제 둘 중 하나만 있는 경우 오류가 발생한다.

## 타입의 구조를 손 댈 수 없는 상황 (ex - API 결과)

앞서 다룬 인터페이스의 유니온을 사용해서 속성 사이의 관계를 모델링 할 수 있다.

```typescript
interface Name {
  name: string;
}

interface PersonWithBirth extends Name {
  placeOfBirth: string;
  dateOfBirth: Date;
}

type Person = Name | PersonWithBirth;
```

- 유니온 타입의 속성을 여러 개 가지는 인터페이스에서는 속성 간의 관계가 분명하지 않기 때문에 실수가 자주 발생하므로 주의해야 한다.
- 유니온의 인터페이스보다 인터페이스의 유니온이 더 정확하고 타입스크립트가 이해하기도 좋다.
- 태그된 유니온은 타입스크립트와 매우 잘 맞기 때문에 자주 볼 수 있는 패턴이다.

# string 타입보다 더 구체적인 타입 사용하기

string 타입의 범위는 매우 넓기에 string 타입으로 변수를 선언하려 한다면, 그보다 더 좁은 타입이 적절하지는 않을지 검토해 보어야 한다.

## 값을 몇 개의 고정값으로만 받을 경우

예를 들어 Album 인터페이스에서 recordingType을 'live'와 'studio' 두 개의 값으로 유니온 타입을 정의해야 한다고 가정해보자.  
이때 enum을 사용할 수도 있지만 일반적으로 추천하지 않는다고 한다.

```typescript
type RecordingType = "studio" | "live";

interface Album {
  artist: string;
  title: string;
  releaseDate: Date;
  recordingType: RecordingType;
}
```

- 이와 같이 코드를 작성하면 타입스크립트는 오류를 더 세밀하게 체크한다.
- 이러한 방식에는 세 가지 장점이 더 있다.

1. 타입을 명시적으로 정의함으로써 다른 곳으로 값이 전달되어도 타입 정보가 유지된다.
2. 타입을 명시적으로 정의하고 해당 타입의 의미를 설명하는 주석을 붙여 넣을 수 있다.
3. keyof 연산자로 더욱 세밀하게 객체의 속성 체크가 가능해진다.

```typescript
/** 주석 내용 */
type RecordingType = "studio" | "live";
```

## 객체의 속성 이름을 함수 매개변수로 받을 때

어떤 배열에서 한 필드의 값만 추출하는 함수를 작성한다고 가정해보자.

```typescript
function pluck<T>(records: T[], key: keyof T): T[keyof T][] {
  return records.map((r) => r[key]);
}
```

- 제너릭과 keyof를 활용하여 위와 같이 코드를 작성했다.
- 그런데 key의 값으로 하나의 문자열을 넣게 되면, 그 범위가 너무 넓어서 적절한 타입이라고 보기 어렵다.
- 예를들어 releaseDate의 타입은 `(string | Date)[]`가 아니라 `Date[]`이어야 한다. 이는 string에 비해 훨씬 범위가 좁기는 하지만 그래도 여전히 넓다.
- 범위를 더 좁히기 위해 keyof T의 부분집합으로 두 번째 제너릭 매개변수를 도입해야 한다.

```typescript
function pluck<T, K extends keyof T>(records: T[], key: K): T[K][] {
  return records.map((r) => r[key]);
}
```

이제 타입 시그니처가 완벽해지고, 매개변수 타입이 정밀해진 덕에 언어 서비스는 키에 자동 완성 기능을 제공할 수 있게 해 준다.

# 부정확한 타입보다는 미완성 타입을 사용하기

일반적으로는 타입이 구체적일수록 버그를 더 많이 잡고 타입스크립트가 제공하는 도구를 활용할 수 있게 된다.  
그러나 타입 선언의 정밀도를 높이는 일에는 주의를 기울여야 한다. 실수가 발생하기 쉽고 잘못된 타입은 차라리 없는 것보다 못할 수 있다.  
타입 선언을 세밀하게 만들 때 너무 과하게 하는 경우 오히려 타입이 부정확해져서 사용자들에게 불편함을 줄 수 있다.

일반적으로 복잡한 코드는 더 많은 테스트가 필요하고 타입의 관점에서도 마찬가지이다.  
타입을 정제할 때 any 같은 매우 추상적인 타입은 정제하는 것이 좋다. 그러나 타입이 구체적으로 정제된다고 해서 정확도가 무조건 올라가지는 않는다.

- 정확하게 타입을 모델링할 수 없다면, 부정확하게 모델링하지 말아야 한다. 또한 any와 unknown을 구별해서 사용해야 한다.
  - any는 타입 검사를 느슨하게 하므로 추후에 개발 후 예기치 못한 문제가 발생할 가능성이 매우 높다.
  - unknown은 any 타입과는 다르게 프로퍼티 또는 연산을 하는 경우 컴파일러가 체크하여 문제 되는 코드를 미리 예방할 수 있다.
- 타입 정보를 구체적으로 만들수록 오류 메시지와 자동 완성 기능에 주의를 기울여야 한다. 정확도뿐만 아니라 개발 경험과도 관련된다.

# 데이터가 아닌, API와 명세를 보고 타입 만들기

- 코드의 구석 구석까지 타입 안정성을 얻기 위해 API 또는 데이터 형식에 대한 타입 생성을 고려해야 한다.
- 데이터에 드러나지 않는 예외적인 경우들이 문제가 될 수 있기 때문에 데이터보다는 명세로부터 코드를 생성하는 것이 좋다.
- 명세를 기반으로 타입을 작성한다면 현재까지 경험한 데이터뿐만 아니라 사용 가능한 모든 값에 대해서 작동한다는 확신을 가질 수 있다.
- API의 명세로부터 타입을 생성할 수 있다면 그렇게 하는 것이 좋다. 특히 GraphQL처럼 자체적으로 타입이 정의된 API에서 잘 동작한다.

<br />
<br />
<br />

## 0315

# styled-components

CSS 스타일을 추상화 한 javascript 객체 대신, CSS 스타일 문법을 그대로 사용할 수 있는 React 스타일 컴포넌트로 활용할 수 있다.  
React 컴포넌트 시스템에서 CSS 스타일링을 효율적으로 작성화기 위한 방법

## 장점

- 손쉬운 유지 보수
  - 컴포넌트에 영향을 미치는 스타일을 찾기 위해 여러 파일을 검색 할 필요가 없으므로 코드 베이스의 크기와 관계없이 유지 보수가 용이
- 고유한 CSS 클래스 생성
  - 스타일 컴포넌트를 추적해 CSS로 작성된 백틱 스타일을 고유한 CSS 클래스 이름으로 변경한다.
  - 스타일 컴포넌트에 의해 자동 생성된 고유 CSS 클래스 이름은 `sc-` 접두사로 시작된다.
- 벤더 프리픽스 자동 설정
  - CSS 표준 문법만 사용하면 자동으로 처리한다.
- 동적 스타일링
  - props 또는 theme 속성을 사용해 컴포넌트 외부에서 스타일을 관리하는 것은, 수십 개의 CSS 클래스를 손수 관리할 필요가 없다.
  - 컴포넌트 외부에서 손쉽게 동적으로 스타일을 관리할 수 있다.

## 설치

`npm i styled-components`

## 사용법

React 프로젝트에서 styled-components 모듈에서 styled를 불러온 후, HTML 표준 컴포넌트 이름을 추가한 다음 백틱 기호로 감싼 영역에 CSS 코드를 작성하면 CSS 스타일이 반영된 React 컴포넌트를 만들어 낼 수 있다.

```jsx
import styled from "styled-components";

export const SectionHeader = styled.h2`
  color: #06f;
  font-size: 1.45rem;
`;

// 위의 코드와 같음
export const SectionHeader = styled("h2")`
  color: #06f;
  font-size: 1.45rem;
`;
```

### props 설정

React 컴포넌트는 요소로 사용될 때 속성을 전달 받고, props 속성으로 전달 받은 속성에 접근이 가능하다.  
Styled 컴포넌트 또한 props 속성을 인터폴레이션 내부에 설정된 함수를 통해 처리할 수 있다.

```jsx
import styled from "styled-components";

const Button = styled.button`
  color: ${(props) => (props.reject ? "#f60" : "#06f")};
`;

export const StyleTest = () => {
  return (
    <div>
      <Button>승인</Button>
      <Button reject>거절</Button>
    </div>
  );
};
```

### 스타일 확장

styled 함수에 스타일드 컴포넌트를 사용해 정의된 컴포넌트를 전달하면 컴포넌트 스타일을 확장할 수 있다.  
Button 컴포넌트 스타일을 확장한 FillButton 컴포넌트 스타일을 만들어보자

```jsx
const Button = styled.button`
  color: ${(props) => (props.reject ? "#f60" : "#06f")};
`;

const FillButton = styled(Button)`
  border: 0;
  padding: 0.45em 0.95em 0.6em;
  background-color: ${(props) => (props.reject ? "#026" : "#06f")};
  color: ${(props) => (props.reject ? "#09f" : "#fff")};
  font-weight: 600;
`;
```

이렇게 스타일을 확장한 경우 기존 스타일이 중첩되게 되면 덮어써지게 된다.

### React 컴포넌트 스타일 확장

일반 React 컴포넌트 또한 스타일 확장이 가능하다.  
className 속성을 전달 받도록 설정해야 스타일 확장이 적용된다.

```jsx
// 이와 같이 className 속성 전달 받도록 설정
const Link = ({ className, to, mode, label, children }) => {
  return (
    <a href={to} className={className}>
      {children}
    </a>
  );
};

// props 사용 시, 디스트럭처링 문법 사용 가능
const IndicatorLink = styled(Link)`
  padding: 0.8em;
  font: 16px/1 Verdana;
  border-radius: ${(props) => props.radius ?? 0};
  border: ${({ border }) => border ?? "3px solid #06f"};
  color: ${({ primary }) => primary ?? "#06f"};
`;

// React 컴포넌트 스타일 확장한 컴포넌트 사용 예시
export const StyleTest = () => {
  return (
    <IndicatorLink
      to="https://www.naver.com"
      radius="10px"
      border="6px double hsla(220, 99%, 50%, 0.68)"
    >
      hihi
    </IndicatorLink>
  );
};
```

### 스타일 래퍼

컴포넌트, 스타일 컴포넌트를 구분하지 않고 내부에 스타일 컴포넌트를 정의하는 것이 관리하기 편하다.

```jsx
// 스타일 컴포넌트
const Container = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  font: 14px/1 Verdana;
  color: ${({ primary }) => primary ?? "hsla(220, 99%, 50%, 0.89)"};
`;

// 컴포넌트
export const Counter = ({ primary, children }) => (
  <Container primary={primary}>{children}</Container>
);
```

- 컴포넌트 내부에 포함한 스타일 컴포넌트가 많아질 경우, 별도 파일로 분리 관리하는 것이 좋다.

다만, 아래와 같이 컴포넌트 내부에 스타일 컴포넌트를 정의해 사용하면 컴포넌트를 렌더링 할 때마다 스타일 컴포넌트를 다시 정의하므로 애플리케이션 속도에 큰 영향을 미친다. 이처럼 사용하면 안 된다.

```jsx
export const Counter = ({ primary, children }) => {
  const Container = styled.div`
    display: flex;
    align-items: center;
    justify-content: center;
    font: 14px/1 Verdana;
    color: ${({ primary }) => primary ?? "hsla(220, 99%, 50%, 0.89)"};
  `;

  return <Container primary={primary}>{children}</Container>;
};
```

### 중첩 규칙

styled-components는 Sass처럼 중첩 규칙, 가상 클래스/요소를 지원한다.

```jsx
const Container = styled.div`
  border: 1px solid black;

  output {
    user-select: none;
    font-size: 40px;
  }
`;

// 컴포넌트
export const Counter = () => (
  <Container>
    <output>9</output>
  </Container>
);
```

### 가상 클래스

스타일드 컴포넌트의 CSS 코드 안에 가상 클래스를 설정하면 스타일이 적용된다.

```jsx
// 스타일 컴포넌트
const ControlButton = styled.button`
  &:hover,
  &:focus {
    color: #036;
    font-weight: 400;
  }
`;

// 컴포넌트
export const Counter = () => <ControlButton>button</ControlButton>;
```

### 가상 요소

CSS 코드 안에 가상 요소를 설정하면 스타일이 적용된다.

```jsx
const ControlButton = styled.button`
  &.increase {
    &::before {
      content: "📤";
    }
  }
`;

export const Counter = () => (
  <ControlButton className="increase">button</ControlButton>
);
```

`&.increase::before` 가상 요소는 `<Counterbutton className="increase">` 내부에 생성된다.

### 추가 props 첨부

styled-components의 attrs 생성자를 사용하면 정적, 동적 props를 정의할 수 있다.  
이 방법을 활용하면 CSS 속성 값이 javascript 식을 장황하게 나열하지 않고, 한 곳에서 깔끔하게 관리할 수 있다.

```jsx
const AppInput = styled.input.attrs(({ size, primary }) => ({
  // 정적 props
  type: "text",
  className: "appInput",

  // 동적 props 정의
  color: primary ?? "#06f",
  margin: size ?? "1em",
  padding: size ?? "1em",
}))`
  border: 2px solid ${({ color }) => color};
  border-radius: 3px;
  margin: ${({ margin }) => margin};
  padding: ${({ padding }) => padding};
  color: ${({ color }) => color};
  font-size: 1em;

  ::placeholder {
    color: ${({ color }) => color};
  }
`;

export const Counter = () => (
  <div>
    <AppInput
      type="email"
      size="0.2em"
      aria-label="이메일"
      placeholder="E-Mail"
    />
    <AppInput
      type="password"
      size="0.8em"
      primary="#3bb98f"
      aria-label="비밀번호"
      placeholder="password"
    />
  </div>
);
```

### 스타일 믹스인

믹스인 패턴은 합성 방식으로 styled-components의 css() 유틸리티 함수를 사용하면 스타일 코드를 믹스인 할 수 있다.  
스타일 중 중복되는 코드가 존재할 때 유용하게 사용할 수 있다.

```jsx
// CSS 믹스인
const boxMixin = css`
  margin: 20px 10px;
  border: 0;
  padding: 1em;
  font-size: 15px;
  font-weight: bold;
  line-height: 1.7;
  color: #fff;
`;

// Box 컴포넌트 ⬅ CSS 믹스인
const Box = styled.div`
  ${boxMixin};
  background: #07f;
`;

// ShadowBox 컴포넌트 ⬅ CSS 믹스인
const ShadowBox = styled.div`
  ${boxMixin};
  background: #41b883;
  box-shadow: 0 6px 8px 1px rgba(0, 100, 30, 0.35);
`;
```

### CSS prop

약간의 스타일 구성을 위해 Styled 컴포넌트를 만ㄷ르고 싶지 않은 경우 css prop을 사용하면 손쉽게 요소에 스타일 적용이 가능하다.  
이 기능을 사용하려면 Babel 플러그인 설치 및 활성화가 필요하다.

```jsx
import "styled-components/macro";

<Button css="padding: 0.5em 1em;" />;
```

Babel 플러그인은 위 코드를 아래 코드처럼 컴파일 한다.

```jsx
import styled from "styled-components";

const StyledButton = styled(Button)`
  padding: 0.5em 1em;
`;

<StyledButton />;
```

### CSS 애니메이션

@keyframes는 컴포넌트 범위 내에서 설정할 수 없다.  
styled-components의 keyframes 모듈을 사용해 애니메이션을 적용할 수 있다.

```jsx
import styled, { keyframes } from "styled-components";

const rotateKeyframes = keyframes`
  0%   { transform: translateY(0) }
  25%  { transform: translateY(-20px) rotate(20deg) }
  50%  { transform: translateY(10px) }
  75%  { transform: translateY(-15px) rotate(-20deg) }
  100% { transform: translateY(0) }
`;

// 마법 모자 animation 속성에 rotate 값 설정
const MagicHat = styled.div`
  font-size: 100px;
  animation: ${rotateKeyframes} 3s infinite cubic-bezier(0.35, 0.29, 0.4, 0.8);
`;
```

### 글로벌 스타일

createGlobalStyle() 함수는 글로벌 스타일을 정의하는 컴포넌트를 반환한다.  
글로벌 스타일 컴포넌트 또한 속성을 전달 받아 내부에서 코드를 처리할 수 있다.

```jsx
import { createGlobalStyle } from "styled-components";

const GlobalStyle = createGlobalStyle`
  body {
    margin: 0;
    font: 1rem/1.5 "Spoqa Han Sans", Sans-Serif;
    background: ${({ darken }) => (darken ? "#162442" : "#dee1e6")};
    color: ${({ darken }) => (darken ? "#dee1e6" : "#162442")};
  }
  a img {
    border: 0;
  }
`;
```

### 애플리케이션 테마

애플리케이션에 사용된 모든 컴포넌트의 스타일을 일괄적으로 변경하려면 '테마'를 활용한다.  
컴포넌트를 작성하고 외부에서 전달한 theme prop에 따라 테마를 변경할 수 있도록 설정한다.  
전달된 theme 속성이 없을 경우, props 기본 값을 attires 생성자로 설정하거나, defaultProps로 설정한다.

```jsx
import styled from "styled-components";

const AppButton = styled.button.attrs(({ theme }) => ({
  theme: "main" in theme ? theme : { main: "#06f" },
}))`
  margin: 0.1em;
  border-radius: 3px;
  border: 2px solid currentColor;
  padding: 0.25em 1em;
  font-size: 1em;
  color: ${({ theme }) => theme.main};
`;

<AppButton>기본 테마 버튼</AppButton>
<AppButton theme={{ main: '#25c892' }}>사용자 정의 테마 버튼</AppButton>
```

ThemeProvider 컴포넌트를 사용해 일괄적인 테마를 제공할 수 있다.  
즉, 렌더 트리 안에 존재하는 모든 스타일 컴포넌트는 테마에 접근이 가능하다.

```jsx
// theme/theme.js - 테마를 관리 할 파일
export const defaultTheme = {
  color: {
    primaryGreen: "#529715",
    primaryOrange: "#e56a18",
    badgePink: "#d51754",
    badgePurple: "#910087",
    badgeGreen: "#349a2c",
    badgeNavy: "#4b5aab",
    heartPink: "#ff9d9d",
    black: "#000000",
    white: "#ffffff",

    backgroundGray: "#fafafa",
    searchGray: "#ebebeb",
    menuBg: "#252525",

    gray100: "#d8d8d8",
    gray200: "#b0b0b0",
    gray300: "#898989",
    gray400: "#616161",
    gray500: "#3a3a3a",
    gray600: "#2e2e2e",
    gray700: "#232323",
    gray800: "#171717",
    gray900: "#0c0c0c",
  },
};

// index.js
import { ThemeProvider } from "styled-components";
import { defaultTheme } from "./theme/theme";

render(
  <StrictMode>
    <ThemeProvider theme={defaultTheme}>
      <Child />
    </ThemeProvider>
  </StrictMode>,
  document.getElementById("root")
);
```

- 테마 파일과 ThemeProvider 컴포넌트를 불러온 후, ThemeProvider 컴포넌트에 theme 속성을 추가한 다음 테마 모드를 설정한다.
- ThemeProvider 컴포넌트에 전달 된 theme은 포함된 모든 컴포넌트와 공유되어 일괄적인 스타일링이 이루어진다.
- ThemeProvider 컴포넌트는 theme 속성 전달이 꼭 필요하다.
- ThemeProvider는 렌더링 될 때 하나 이상의 자식 컴포넌트를 반환하기 때문에 단 하나의 자식 요소만 가져야 한다.

### 테마 함수

theme 속성 값으로 함수를 전달할 수도 있다. 이 함수는 부모의 theme 속성 값을 전달 받는다.  
예를 들어, 테마 반전같은 기능에서 사용할 수 있다.

```jsx
const invertTheme = ({ fgColor, bgColor }) => ({
  fgColor: bgColor,
  bgColor: fgColor,
});

<ThemeProvider theme={theme.darkTheme}>
  <AppButton theme={invertTheme}>테마 반전</AppButton>
</ThemeProvider>;
```

### 일반 컴포넌트에 테마 적용

스타일 컴포넌트가 아닌 일반 React 컴포넌트에 테마를 사용해야 하는 경우, withTheme 고차 컴포넌트를 활용할 수 있다.

```jsx
import React from "react";

// withTheme 고차 컴포넌트 불러오기
import { withTheme } from "styled-components";

class AppInput extends React.Component {
  componentDidMount() {
    // withTheme 고차 컴포넌트를 사용하면
    // 상위 영역에 설정된 테마를 전달 받습니다.
    console.log(this.props.theme);
  }
  render() {
    return <input />;
  }
}

// withTheme 고차 함수에 AppInput 컴포넌트를 전달하여 내보내기
export default withTheme(AppInput);
```

- AppInput 컴포넌트는 스타일 컴포넌트는 아니지만, withTheme()로 감싸져 있어 ThemeProvider 컴포넌트의 theme 속성을 전달 받는다.
- 전달 받은 theme을 사용하면 일반 컴포넌트에도 스타일을 적용할 수 있다.
