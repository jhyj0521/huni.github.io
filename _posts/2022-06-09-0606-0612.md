---
title: "0530 - 0605"
tag: TIL
category: TIL
excerpt: ""
---

## 0606

# 링크드 리스트

연결 리스트라고도 불리는 링크드 리스트에 대해 학습하고자 한다.  
최근에 모의 면접을 진행하면서 나온 라이브 코딩 주제가 바로 이 링크드 리스트였다. 이때 문제를 잘 해결하기는 했지만, 배운지 오래된 내용이다보니 복습 차원에서 다시 공부해보고자 한다.

- 연결리스트는 여러 노드들이 연결되어있는 구조이다.
- 여기서 노드란 데이터와 링크로 구성되어있는 구조체이다. 노드는 링크를 통해 다음 노드에 접근할 수 있으며, 노드들은 다음에 올 노드의 정보를 갖고 있다.
- 이런 연결 리스트 구조에서 맨 앞을 Head라 하며, 맨 마지막을 Tail이라 한다.

## 시간 복잡도

- 삽입 - O(1)
- 삭제 - O(1)
- 검색 - O(n)

삽입의 경우, 기존 링크를 끊은 다음 추가할 위치의 이전 요소의 링크와 삽입할 자료를 연결한다.  
그리고 추가할 요소의 링크와 다음 요소를 연결해주면 된다.  
이와 같이, 삽입과 삭제의 경우 연결시켜주는 동작만 수행되므로 시간 복잡도는 O(1)이다.

연결 리스트에서 특정 자료를 검색하고 싶다면, 맨 앞의 head에서부터 순차적으로 자료를 찾아야 한다.  
연결 리스트의 각 노드들은 다음 요소들의 정보를 갖고 있기 때문에 맨 앞의 요소에서부터 노드들을 순차적으로 검색한다. 이때의 시간 복잡도는 O(n)이다.

## 0608

# 제너레이터

제너레이터는 코드 블록의 실행을 일시 중지했다가 필요한 시점에 재개할 수 있는 특수한 함수입니다.

제너레이터 함수는 함수 호출자에게 함수 실행의 제어권을 양도할 수 있고, 함수의 호출자와 함수의 상태를 주고받을 수 있습니다.
제너레이터 함수를 호출하면 제너레이터 객체를 반환하는데, 이는 이터러블이면서 동시에 이터레이터입니다.

### 제너레이터랑 이터레이터 객체의 차이

제너레이터 객체는 next 메서드를 갖는 이터레이터이지만 이터레이터에 없는 return, throw 메서드를 갖는다.
제너레이터 객체의 세 개의 메서드를 호출하면 다음과 같이 동작한다.

- next 메서드를 호출하면 제너레이터 함수의 yield 표현식까지 코드 블록을 실행하고, yield된 값을 value 프로퍼티 값으로, false를 done 프로퍼티 값으로 갖는 이터레이터 리절트 객체를 갖는다.
- return 메서드를 호출하면 인수로 전달받은 값을 value 프로퍼티 값으로, true를 done 프로퍼티 값으로 갖는 이터레이터 리절트 객체를 반환한다.
- throw 메서드를 호출하면 인수로 전달받은 에러를 발생시키고 undefined를 value 프로퍼티 값으로, true를 done 프로퍼티 값으로 갖는 이터레이터 리절트 객체를 반환한다.

### 제너레이터 일시 중지와 재개

- 제너레이터는 yield 키워드와 next 메서드를 통해 실행을 일시 중지했다가 필요한 시점에 다시 재개할 수 있다.
- 일반 함수는 호출 이후 제어권을 함수가 독점하지만 제너레이터는 함수 호출자를 제어권에게 양도하여 필요한 시점에 함수 실행을 재개할 수 있다.
- 제너레이터 객체의 next 메서드를 호출하면 yield 표현식까지 실행되고 일시 중지된다. 이때 함수의 제어권이 호출자로 양도된다.
- 이때 제너레이터 객체의 next 메서드는 value, done 프로퍼티를 갖는 이터레이터 리절트 객체를 반환한다.

### async 함수를 어떻게 구현할 수 있는가

자바스크립트의 제너레이터를 활용하여 구현할 수 있다고 생각합니다.
제너레이터 함수를 인수로 받는 async 함수를 만든 뒤,
async 함수 내부에서 인수로 받은 제너레이터 함수를 실행하여 변수에 제너레이터 객체를 저장합니다.

그리고 제너레이터를 참조하여 next메서드를 실행하고 done 프로퍼티가 true라면 value를 false라면 제네레이터 함수가 끝까지 실행되지 않았으므로 value의 후속처리 메서드를 실행하여 다시 resolve한 결과를 인수로 재귀 호출하는 클로저를 반환합니다.
사용할 때는 yield 키워드를 마치 await처럼 사용하면 async, await처럼 동작하게 구현할 수 있습니다.
