---
title: "0117 - 0123"
tag: TIL
category: TIL
excerpt: ""
---

## 0117

# React 훅

## 등장 배경

컴포넌트에 보다 많은 로직을 작성해 래퍼 지옥 문제를 해결하려고 하면 컴포넌트가 커지고, 리팩토링 하기 어려워진다.  
반면, 컴포넌트를 더 작은 조각으로 나눠 재사용하려고 하면 컴포넌트 트리보다 훨씬 많은 중첩이 생겨 래퍼 지옥이 다시 나타난다.

### 레거시 설계

- 리팩토링, 테스트가 어려운 규모가 큰 컴포넌트
- 컴포넌트 간 중복된 상태, 라이프 사이클
- Render Props, HOC와 같은 복잡한 패턴
  - React 컴포넌트 간에 로직을 재사용하기 위해 사용된 Render Props, HOC 패턴은 코드 추적을 어렵게 한다.
  - 컨텍스트 공급/수요자, 고차 컴포넌트 등을 포함한 수많은 추상 레이어로 복잡하게 엮여진 래퍼 지옥을 보게 된다.

-> 문제의 원인을 리액트 팀은 클래스 컴포넌트에서 로직 재사용을 위해 사용되었던 복잡한 방식보다 간단한 방법을 제공하지 못했기 때문이라고 분석했다.

- 클래스 컴포넌트를 사용할 때 JS의 this가 어떻게 동작하는지 이해해야 하지만, 여타 언어와 다르게 작동함에 따라 사용자의 혼란을 부추김
- 이벤트 핸들러를 등록하기 위한 다양한 방식을 이해해야 했고, 클래스 필드 구문의 도움이 없을 경우 코드는 매우 장황해졌다.
- 클래스는 번들 과정에서 파일의 크기를 증가시켜 성능 문제를 가져온다.

## React 훅의 장점

- 클래스를 사용하지 않아도 함수 컴포넌트를 중심으로 앱 개발이 가능
- 훅을 사용해 컴포넌트에서 상태 및 로직을 추출한 후, 다른 컴포넌트에서 재사용 할 수 있다.
- 서로 관련 있는 코드들을 한군데에 모아 작성할 수 있다.

## React 훅의 특징

### 캡슐화

- 훅은 완전하게 캡슐화 처리되므로, 현재 실행 중인 컴포넌트에서 훅을 호출할 때에도 격리된 로컬 상태를 유지한다.
- 훅은 상태를 공유하는 방법이 아니라, 상태 저장 로직을 공유하는 방법이다. 결과적으로 리액트의 단방향 데이터 흐름을 깨트리지 않는다.

### 클린 트리

- 훅 간에 데이터를 전달하는 기능은 Hooks를 애니메이션, 구독, 폼 관리 등을 처리하는데 매우 적합하다.
- Hooks는 컴포넌트 트리를 어지럽게 만드는 거짓 된 레이어를 추가하지 않는다. 컴포넌트에 연결된 메모리 셀의 단순한 리스트와 유사하다.

### 상태 유지 위치

- 리액트가 Hooks에 대한 상태를 유지하는 위치는 클래스 컴포넌트 상태를 유지하는 방법과 똑같이 유지한다.
- 리액트에는 컴포넌트를 어떻게 정의하든 관계없이 모든 상태에 대한 내부 업데이트 대기열이 있다.

### 보다 작은 번들 크기

- Hooks는 클래스를 사용할 때 보다 번들된 파일의 크기를 줄여 다소 성능 향상을 기대할 수 있다.

## Hooks의 사용 규칙

Hooks는 조금 특별할 뿐인 일반 JS 함수로, 다음 2가지 규칙을 준수해야 한다.

1. React 함수 컴포넌트, 다른 커스텀 Hook 함수 안에서만 사용 가능하다. 일반 함수, 또는 클래스 컴포넌트 안에서 호출하면 안 된다.
2. Hook은 문 또는 중첩 된 함수 안에서 사용할 수 없다. 컴포넌트, 커스텀 훅 함수 최상위에만 사용
