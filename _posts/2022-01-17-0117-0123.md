---
title: "0117 - 0123"
tag: TIL
category: TIL
excerpt: ""
---

## 0117

# React 훅

## 등장 배경

컴포넌트에 보다 많은 로직을 작성해 래퍼 지옥 문제를 해결하려고 하면 컴포넌트가 커지고, 리팩토링 하기 어려워진다.  
반면, 컴포넌트를 더 작은 조각으로 나눠 재사용하려고 하면 컴포넌트 트리보다 훨씬 많은 중첩이 생겨 래퍼 지옥이 다시 나타난다.

### 레거시 설계

- 리팩토링, 테스트가 어려운 규모가 큰 컴포넌트
- 컴포넌트 간 중복된 상태, 라이프 사이클
- Render Props, HOC와 같은 복잡한 패턴
  - React 컴포넌트 간에 로직을 재사용하기 위해 사용된 Render Props, HOC 패턴은 코드 추적을 어렵게 한다.
  - 컨텍스트 공급/수요자, 고차 컴포넌트 등을 포함한 수많은 추상 레이어로 복잡하게 엮여진 래퍼 지옥을 보게 된다.

-> 문제의 원인을 리액트 팀은 클래스 컴포넌트에서 로직 재사용을 위해 사용되었던 복잡한 방식보다 간단한 방법을 제공하지 못했기 때문이라고 분석했다.

- 클래스 컴포넌트를 사용할 때 JS의 this가 어떻게 동작하는지 이해해야 하지만, 여타 언어와 다르게 작동함에 따라 사용자의 혼란을 부추김
- 이벤트 핸들러를 등록하기 위한 다양한 방식을 이해해야 했고, 클래스 필드 구문의 도움이 없을 경우 코드는 매우 장황해졌다.
- 클래스는 번들 과정에서 파일의 크기를 증가시켜 성능 문제를 가져온다.

## React 훅의 장점

- 클래스를 사용하지 않아도 함수 컴포넌트를 중심으로 앱 개발이 가능
- 훅을 사용해 컴포넌트에서 상태 및 로직을 추출한 후, 다른 컴포넌트에서 재사용 할 수 있다.
- 서로 관련 있는 코드들을 한군데에 모아 작성할 수 있다.

## React 훅의 특징

### 캡슐화

- 훅은 완전하게 캡슐화 처리되므로, 현재 실행 중인 컴포넌트에서 훅을 호출할 때에도 격리된 로컬 상태를 유지한다.
- 훅은 상태를 공유하는 방법이 아니라, 상태 저장 로직을 공유하는 방법이다. 결과적으로 리액트의 단방향 데이터 흐름을 깨트리지 않는다.

### 클린 트리

- 훅 간에 데이터를 전달하는 기능은 Hooks를 애니메이션, 구독, 폼 관리 등을 처리하는데 매우 적합하다.
- Hooks는 컴포넌트 트리를 어지럽게 만드는 거짓 된 레이어를 추가하지 않는다. 컴포넌트에 연결된 메모리 셀의 단순한 리스트와 유사하다.

### 상태 유지 위치

- 리액트가 Hooks에 대한 상태를 유지하는 위치는 클래스 컴포넌트 상태를 유지하는 방법과 똑같이 유지한다.
- 리액트에는 컴포넌트를 어떻게 정의하든 관계없이 모든 상태에 대한 내부 업데이트 대기열이 있다.

### 보다 작은 번들 크기

- Hooks는 클래스를 사용할 때 보다 번들된 파일의 크기를 줄여 다소 성능 향상을 기대할 수 있다.

## Hooks의 사용 규칙

Hooks는 조금 특별할 뿐인 일반 JS 함수로, 다음 2가지 규칙을 준수해야 한다.

1. React 함수 컴포넌트, 다른 커스텀 Hook 함수 안에서만 사용 가능하다. 일반 함수, 또는 클래스 컴포넌트 안에서 호출하면 안 된다.
2. Hook은 문 또는 중첩 된 함수 안에서 사용할 수 없다. 컴포넌트, 커스텀 훅 함수 최상위에만 사용

<br />
<br />
<br />

## 0118 TIL

# useState

함수 컴포넌트에서 상태를 관리할 때는 `React.useState()` 훅을 사용한다.

### 상태 값, 업데이트 함수

- `useState()` 훅은 상태와 상태 업데이트를 담당하는 함수를 반환한다.
- 훅에 최초 전달된 값이 컴포넌트의 초기 상태 값이 되며, 함수 컴포넌트가 다시 렌더링 될 때는 항상 이전의 업데이트 된 상태 값이 최신 상태 값이 된다.  
  `const [stateValue, stateUpdater] = useState(initialState);`

### 지연된 초기화

- initialState 인자는 함수 컴포넌트 초기 렌더링 시에만 사용되는 state 초깃값을 설정한다.
- 이후 다시 렌더링 될 때는 이 값이 무시된다.
- 만약 state 초깃값을 계산하는데 많은 시간이 필요한 경우는 초기 렌더링 시에만 실행될 함수를 설정해 지연된 초기화 처리가 가능하다.

```javascript
const [stateValue, setUpdater] = useState(() => {
  const initialState = localStorage.getItem("item");
  return JSON.parse(initialState);
});
```

### 객체 타입 상태 관리

- useState() 훅에서 클래스의 state, setState()와 동일하게 작동되도록 하려면 합성된 객체를 반환해야 한다.

```javascript
const [state, updateState] = useState({
  key1: false,
  key2: true,
});

updateState({
  ...state,
  key2: true,
});
```

- useState()는 상태를 합성하는 것이 아니라 대체한다.
- 클래스 컴포넌트의 setState 메서드와 다르게, 이전 상태를 새로운 상태가 대체한다.

# useEffect

함수 컴포넌트에서 발생 가능한 부수 효과는 `React.useEffect` 훅으로 관리한다.

### 이펙트 함수

- 사이드 이펙트(비동기 통신 요청/응답, DOM 조작, 구독/취소 등)는 클래스 컴포넌트의 render 메서드에서는 다룰 수 없다.
- 이를 다룰 수 있는 라이프 사이클 메서드 내에서만 다뤄야 한다.
- useEffect 훅은 클래스 컴포넌트의 사이드 이펙트 관리 라이프 사이클 메서드 기능을 모두 처리한다.
- 렌더링 이후에 발생한다. 즉, effect가 수행되는 시점에 이미 DOM이 업데이트 되었음을 보장한다.
- useEffect에 전달된 함수는 모든 렌더링에서 다르다.

```javascript
useEffect(() => {
  // DOM 마운트(렌더링) 이후 콜백
});
```

### 이펙트 조건 처리

- 특정 조건에 따라 이펙트 함수를 실행해야 할 경우, useEffect() 훅의 2번째 인자로 종속성 배열을 설정한다.

```javascript
useEffect(() => {
  // componentDidMount
}, []);
```

- 종속성 배열에 관리할 상태가 추가되면, 해당 상태가 변경될 때에만 이펙트 함수가 실행된다. (조건 처리)

### 클린업

- 이펙트 함수를 통해 설정된 사이드 이펙트(구독)는 컴포넌트가 UI에서 제거될 때 정리되어야 한다.
- 이를 수행하려면 이펙트 함수에서 클린업 함수를 반환하고 그 함수 내부에서 정리를 실행한다.
- effect가 함수를 반환하면 리액트는 그 함수를 정리가 필요한 때에 실행시킨다.

```javascript
useEffect(() => {
  // 구독
  return () => {
    // 정리 함수
    // 구독 취소
  };
}, []);
```

- 클린업 함수는 메모리 방지를 위해 UI에서 컴포넌트를 제거하기 직전 수행된다.
- 이는 클래스 컴포넌트의 componentWillUnmount와 유사하게 동작한다고 볼 수 있지만, 실상은 다음 이펙트 함수가 실행될 때마다 클린업 함수가 먼저 실행되어 정리한다.

### effect가 업데이트 시마다 실행되는 이유

- 컴포넌트가 화면에 표시되어 있는 동안 prop이 변한다면 무슨 일이 일어날까?
  - 버그가 발생하고, 마운트 해제가 일어날 동안에 잘못 호출되어 메모리 누수나 충돌이 발생할 수 있다.
  - 클래스 컴포넌트에서는 이를 해결하기 위해 componentDidUpdate를 사용하는데, 리액트 애플리케이션의 흔한 버그 중의 하나가 이를 제대로 다루지 않아서 발생한다.
- useEffect는 기본적으로 업데이트를 다루기 때문에 더는 업데이트를 위한 특별한 코드가 필요 없다.

### Effect를 건너뛰어 성능 최적화하기

- 모든 렌더링 이후에 effect를 정리하거나 적용하는 것이 때때로 성능 저하를 발생시키는 경우도 있다.
- 클래스 컴포넌트의 경우에는 componentDidUpdate에서 prevProps나 prevState와의 비교를 통해 문제를 해결할 수 있다.
- useEffect의 두 번째 인수로 배열을 넘기면 내부 값이 변경되지 않는다면 리액트로 하여금 effect를 건너뛰도록 할 수 있다.

```javascript
useEffect(() => {
  document.title = `You clicked ${count} times`;
}, [count]); // count가 바뀔 때만 effect를 재실행합니다.
```

- 리렌더링 이후에 count가 변하지 않았다면 effect를 건너뛰게 된다.
- 이 최적화 방법을 사용한다면 배열이 컴포넌트 범위 내에서 바뀌는 값들과 effect에 의해 사용되는 값들을 모두 포함하는 것을 기억해야 한다.
  - 그렇지 않으면 현재 값이 아닌 이전의 렌더링 때의 값을 참고하게 된다.
- effect를 실행하고 이를 정리하는 과정을 딱 한 번씩만 실행하고 싶다면, 빈 배열을 두 번째 인수로 넘기면 된다.
  - 이렇게 함으로써 리액트로 하여금 effect가 props나 state 그 어떤 값에도 의존하지 않으므로 재실행되어야 할 필요가 없음을 알게 하는 것이다.
