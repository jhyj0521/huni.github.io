---
title: "0328 - 0404"
tag: TIL
category: TIL
excerpt: ""
---

## 0328

# React 훅

## 등장 배경

컴포넌트에 보다 많은 로직을 작성해 래퍼 지옥 문제를 해결하려고 하면 컴포넌트가 커지고, 리팩토링 하기 어려워진다.  
반면, 컴포넌트를 더 작은 조각으로 나눠 재사용하려고 하면 컴포넌트 트리보다 훨씬 많은 중첩이 생겨 래퍼 지옥이 다시 나타난다.

### 레거시 설계

- 리팩토링, 테스트가 어려운 규모가 큰 컴포넌트
- 컴포넌트 간 중복된 상태, 라이프 사이클
- Render Props, HOC와 같은 복잡한 패턴
  - React 컴포넌트 간에 로직을 재사용하기 위해 사용된 Render Props, HOC 패턴은 코드 추적을 어렵게 한다.
  - 컨텍스트 공급/수요자, 고차 컴포넌트 등을 포함한 수많은 추상 레이어로 복잡하게 엮여진 래퍼 지옥을 보게 된다.

-> 문제의 원인을 리액트 팀은 클래스 컴포넌트에서 로직 재사용을 위해 사용되었던 복잡한 방식보다 간단한 방법을 제공하지 못했기 때문이라고 분석했다.

- 클래스 컴포넌트를 사용할 때 JS의 this가 어떻게 동작하는지 이해해야 하지만, 여타 언어와 다르게 작동함에 따라 사용자의 혼란을 부추김
- 이벤트 핸들러를 등록하기 위한 다양한 방식을 이해해야 했고, 클래스 필드 구문의 도움이 없을 경우 코드는 매우 장황해졌다.
- 클래스는 번들 과정에서 파일의 크기를 증가시켜 성능 문제를 가져온다.

## React 훅의 장점

- 클래스를 사용하지 않아도 함수 컴포넌트를 중심으로 앱 개발이 가능
- 훅을 사용해 컴포넌트에서 상태 및 로직을 추출한 후, 다른 컴포넌트에서 재사용 할 수 있다.
- 서로 관련 있는 코드들을 한군데에 모아 작성할 수 있다.

## React 훅의 특징

### 캡슐화

- 훅은 완전하게 캡슐화 처리되므로, 현재 실행 중인 컴포넌트에서 훅을 호출할 때에도 격리된 로컬 상태를 유지한다.
- 훅은 상태를 공유하는 방법이 아니라, 상태 저장 로직을 공유하는 방법이다. 결과적으로 리액트의 단방향 데이터 흐름을 깨트리지 않는다.

### 클린 트리

- 훅 간에 데이터를 전달하는 기능은 Hooks를 애니메이션, 구독, 폼 관리 등을 처리하는데 매우 적합하다.
- Hooks는 컴포넌트 트리를 어지럽게 만드는 거짓 된 레이어를 추가하지 않는다. 컴포넌트에 연결된 메모리 셀의 단순한 리스트와 유사하다.

### 상태 유지 위치

- 리액트가 Hooks에 대한 상태를 유지하는 위치는 클래스 컴포넌트 상태를 유지하는 방법과 똑같이 유지한다.
- 리액트에는 컴포넌트를 어떻게 정의하든 관계없이 모든 상태에 대한 내부 업데이트 대기열이 있다.

### 보다 작은 번들 크기

- Hooks는 클래스를 사용할 때 보다 번들된 파일의 크기를 줄여 다소 성능 향상을 기대할 수 있다.

## Hooks의 사용 규칙

Hooks는 조금 특별할 뿐인 일반 JS 함수로, 다음 2가지 규칙을 준수해야 한다.

1. React 함수 컴포넌트, 다른 커스텀 Hook 함수 안에서만 사용 가능하다. 일반 함수, 또는 클래스 컴포넌트 안에서 호출하면 안 된다.
2. Hook은 반복문, 조건문 또는 중첩 된 함수 안에서 사용할 수 없다. 컴포넌트, 커스텀 훅 함수 최상위에만 사용
   - 이 규칙을 따르면 컴포넌트가 렌더링 될 때마다 항상 동일한 순서로 Hook이 호출되는 것을 보장한다.
   - 이러한 점은 useState와 useEffect가 여러 번 호출되는 중에도 Hook의 상태를 올바르게 유지할 수 있도록 해준다.

# useState

함수 컴포넌트에서 상태를 관리할 때는 `React.useState()` 훅을 사용한다.

### 상태 값, 업데이트 함수

- `useState()` 훅은 상태와 상태 업데이트를 담당하는 함수를 반환한다.
- 훅에 최초 전달된 값이 컴포넌트의 초기 상태 값이 되며, 함수 컴포넌트가 다시 렌더링 될 때는 항상 이전의 업데이트 된 상태 값이 최신 상태 값이 된다.  
  `const [stateValue, stateUpdater] = useState(initialState);`

### 지연된 초기화

- initialState 인자는 함수 컴포넌트 초기 렌더링 시에만 사용되는 state 초깃값을 설정한다.
- 이후 다시 렌더링 될 때는 이 값이 무시된다.
- 만약 state 초깃값을 계산하는데 많은 시간이 필요한 경우는 초기 렌더링 시에만 실행될 함수를 설정해 지연된 초기화 처리가 가능하다.

```javascript
const [stateValue, setUpdater] = useState(() => {
  const initialState = localStorage.getItem("item");
  return JSON.parse(initialState);
});
```

### 객체 타입 상태 관리

- useState() 훅에서 클래스의 state, setState()와 동일하게 작동되도록 하려면 합성된 객체를 반환해야 한다.

```javascript
const [state, updateState] = useState({
  key1: false,
  key2: true,
});

updateState({
  ...state,
  key2: true,
});
```

- useState()는 상태를 합성하는 것이 아니라 대체한다.
- 클래스 컴포넌트의 setState 메서드와 다르게, 이전 상태를 새로운 상태가 대체한다.

# useEffect

함수 컴포넌트 본문은 class 컴포넌트의 render 메서드에 해당되므로 사이드 이펙트 코드를 포함할 수 없지만 useEffect() 훅에 전달 된 함수 내부에서는 사이드 이펙트를 작성할 수 있다.
함수 컴포넌트에서 발생 가능한 부수 효과는 `React.useEffect` 훅으로 관리한다.

### 이펙트 함수

- 사이드 이펙트(비동기 통신 요청/응답, DOM 조작, 구독/취소 등)는 클래스 컴포넌트의 render 메서드에서는 다룰 수 없다.
- 이를 다룰 수 있는 라이프 사이클 메서드 내에서만 다뤄야 한다.
- 클래스에서는 side effect를 componentDidMount와 componentDidUpdate에 두는 데, 두 개의 생명주기 메서드에 같은 코드가 중복되는 것에 주의해야 한다. 이는 컴포넌트가 같은 사이드 이펙트를 수행하기 바라기 때문에 발생한다.
- useEffect 훅은 클래스 컴포넌트의 사이드 이펙트 관리 라이프 사이클 메서드 기능을 모두 처리한다.
- useEffect를 컴포넌트 내부에 둠으로써 effect를 통해 state 변수 또는 prop에 접근 가능하다. 함수 범위 안에 두고 클로저를 이용해서 특별한 API 없이도 값을 얻을 수 있다.
- useEffect는 렌더링 이후에 발생한다. 즉, effect가 수행되는 시점에 이미 DOM이 업데이트 되었음을 보장한다.
- useEffect에 전달된 함수는 모든 렌더링에서 다르다. 각각의 effect는 특정한 렌더링에 속한다.

```javascript
useEffect(() => {
  // DOM 마운트(렌더링) 이후 콜백
});
```

### 이펙트 조건 처리

- 특정 조건에 따라 이펙트 함수를 실행해야 할 경우, useEffect() 훅의 2번째 인자로 종속성 배열을 설정한다.

```javascript
useEffect(() => {
  // componentDidMount
}, []);
```

- 종속성 배열에 관리할 상태가 추가되면, 해당 상태가 변경될 때에만 이펙트 함수가 실행된다. (조건 처리)

### 클린업

- 이펙트 함수를 통해 설정된 사이드 이펙트(구독)는 컴포넌트가 UI에서 제거될 때 정리되어야 한다.
- 이를 수행하려면 이펙트 함수에서 클린업 함수를 반환하고 그 함수 내부에서 정리를 실행한다.
- effect가 함수를 반환하면 리액트는 그 함수를 정리가 필요한 때에 실행시킨다.

```javascript
useEffect(() => {
  // 구독
  return () => {
    // 정리 함수
    // 구독 취소
  };
}, []);
```

- 클린업 함수는 메모리 누수 방지를 위해 UI에서 컴포넌트를 제거하기 직전 수행된다.
- 이는 클래스 컴포넌트의 componentWillUnmount와 유사하게 동작한다고 볼 수 있지만, 실상은 다음 이펙트 함수가 실행될 때마다 클린업 함수가 먼저 실행되어 정리한다.

## effect를 이용하는 팁

### 관심사를 구분하기 위해서는 Multiple Effect를 사용한다

- 훅이 탄생한 동기가 된 문제 중의 하나가 생명주기 클래스 메서드가 관련 없는 로직들을 모아놓고, 관련이 있는 로직들은 여러 개의 메서드에 나누어 놓는 경우가 자주 있다는 것이다.
- State Hook을 여러 번 사용할 수 있는 것처럼 effect 또한 여러 번 사용할 수 있다. Effect를 이용하여 서로 관련이 없는 로직들을 갈라놓을 수 있다.
- 훅을 이용하면 생명주기 메서드에 따라서가 아니라 코드가 무엇을 하는지에 따라 나눌 수 있다. 리액트는 컴포넌트에 사용된 모든 effect를 지정된 순서에 맞춰 적용한다.

### effect가 업데이트 시마다 실행되는 이유

- 컴포넌트가 화면에 표시되어 있는 동안 prop이 변한다면 무슨 일이 일어날까?
  - 버그가 발생하고, 마운트 해제가 일어날 동안에 잘못 호출되어 메모리 누수나 충돌이 발생할 수 있다.
  - 클래스 컴포넌트에서는 이를 해결하기 위해 componentDidUpdate를 사용하는데, 리액트 애플리케이션의 흔한 버그 중의 하나가 이를 제대로 다루지 않아서 발생한다.
- useEffect는 기본적으로 업데이트를 다루기 때문에 더는 업데이트를 위한 특별한 코드가 필요 없다. 다음의 effect를 적용하기 전에 이전의 effect를 정리하여 더욱 사용하기 간편하다.

### Effect를 건너뛰어 성능 최적화하기

- 모든 렌더링 이후에 effect를 정리하거나 적용하는 것이 때때로 성능 저하를 발생시키는 경우도 있다.
- 클래스 컴포넌트의 경우에는 componentDidUpdate에서 prevProps나 prevState와의 비교를 통해 문제를 해결할 수 있다.
- useEffect의 두 번째 인수로 배열을 넘기면 내부 값이 변경되지 않는다면 리액트로 하여금 effect를 건너뛰도록 할 수 있다.

```javascript
useEffect(() => {
  document.title = `You clicked ${count} times`;
}, [count]); // count가 바뀔 때만 effect를 재실행합니다.
```

- 리렌더링 이후에 종속성 배열 내의 모든 값이 변하지 않았다면 effect를 건너뛰게 된다.
- 이 최적화 방법을 사용한다면 배열이 컴포넌트 범위 내에서 바뀌는 값들과 effect에 의해 사용되는 값들을 모두 포함하는 것을 기억해야 한다.
  - 그렇지 않으면 현재 값이 아닌 이전의 렌더링 때의 값을 참고하게 된다.
- effect를 실행하고 이를 정리하는 과정을 딱 한 번씩만 실행하고 싶다면, 빈 배열을 두 번째 인수로 넘기면 된다.
  - 이렇게 함으로써 리액트로 하여금 effect가 props나 state 그 어떤 값에도 의존하지 않으며 따라서 재실행되어야 할 필요가 없음을 알게 하는 것이다.

<br />
<br />
<br />

## 0329

# custom hook

커스텀 훅은 기술적으로 React 만의 고유 기능이 아니라, 이름이 use로 시작하는 일반적인 JavaScript 함수이다.  
이를 통해 복잡한 로직을 컴포넌트에서 분리하여 다른 컴포넌트에서 손쉽게 재사용할 수 있다.

예를 들어, 뷰포트 정보를 여러 컴포넌트에서 표시해야 한다고 가정해보자  
이런 경우 특정 컴포넌트 내부에서만 사용되도록 로직을 구성하기 보다는, 다른 컴포넌트에서도 재사용 할 수 있도록 로직을 구성해야 한다.

```javascript
import { useState, useEffect } from "react";

export const useViewport = () => {
  const { innerWidth, innerHeight } = window;
  const [width, setWidth] = useState(innerWidth);
  const [height, setHeight] = useState(innerHeight);

  useEffect(() => {
    const handleResize = () => {
      setWidth(window.innerWidth);
      setHeight(window.innerHeight);
    };

    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, []);

  return { width, height };
};
```

- 커스텀 훅은 useStatel, useEffect와 같은 기본 Hooks를 활용한다.
- 이처럼 여러 컴포넌트에서 재사용 가능한 로직을 손쉽게 분리, 재사용할 수 있어 커스텀 훅을 사용하는 것은 React의 고유 API를 사용하는 것처럼 일반적이다.

## 데이터 패치 Hook

데이터 요청/응답과 같이 자주 사용되는 사이드 이펙트 로직 또한 커스텀 훅을 사용해 재사용할 수 있다.

```javascript
import { useState, useEffect } from "react";
import axios from "axios";

function useFetchData(apiEndpoint) {
  const [state, setState] = useState({
    loading: true,
    data: null,
    error: null,
  });

  useEffect(() => {
    async function getData() {
      try {
        const { data } = await axios.get(apiEndpoint);
        setState({ ...state, data });
      } catch (error) {
        setState({ ...state, error });
      } finally {
        setState({ ...state, loading: false });
      }
    }

    getData();
  }, [apiEndpoint]);

  return state;
}
```

- 이는 커스텀 훅을 사용하지 않은 코드와 동일한 코드로, 정확히 같은 방식으로 작동한다.
- 바뀐 것은 오로지 공통의 코드를 뽑아내 새로운 함수로 만든 것뿐이다.
- 커스텀 훅은 리액트의 특별한 기능이라기보다 기본적으로 디자인을 따르는 관습이다.
- 커스텀 훅을 작성할 때 이름은 use로 시작해야 하는데, 이를 따르지 않으면 특정한 함수가 그 안에서 Hook을 호출하는지를 알 수 없기 때문에 Hook 규칙의 위반 여부를 자동으로 체크할 수 없다.
- 같은 훅을 사용하더라도 두 개의 컴포넌트는 state를 공유하지 않는다. 커스텀 훅은 재사용하는 메커니즘이지만 사용할 때마다 그 안의 state와 effect는 완전히 독립적이다.
- 너무 이른 단계에서 로직을 뽑아내려고 하기 보다는, 커스텀 훅이 복잡한 로직을 단순한 인터페이스 속에 숨길 수 있도록 하거나 복잡하게 뒤엉킨 컴포넌트를 풀어내도록 돕는 경우를 찾아내서 사용하자.
