---
title: "1214 - 1220"
tag: TIL
category: TIL
excerpt: ""
---

## 1214

### _자신을 되돌아 봄_

지난 주에 TIL을 작성하며 느낀 점은 너무 내용만 있고 나의 의견이 부족하다는 것이다.  
문법이나 학습한 내용은 포스트로도 작성하니 내 생각을 정리하는 내용의 비중을 높이자  
내가 TIL을 시작한 목적 중 가장 큰 이유는 자신의 하루를 되돌아 봄으로써 얻는 **깨달음**이다.  
같은 시간을 투자하여 공부를 해도 얼마나 집중하였는지가 내 지식의 질을 높여준다.  
하루를 되돌아보고 깨달음을 원동력으로 반성을 발판삼아 후회 없는 시간을 보내자

---

### 패킷을 분석한 정보 획득

벌써 기업에서 인턴 생활을 한지 6개월이라는 시간이 흘렀다.  
지금까지 앵귤러를 이용하여 SPA를 개발하였고, 남은 1주일 동안은 지금까지 해 온 것과는 다른 특별한 과제가 주어졌다.  
플래시를 동작시키면서 패킷을 분석하여 정보를 얻어내고, 보기 좋게 워드 파일로 정리하여 HTML5로 변환하는 데에 사용할 수 있도록 하는 것이다.  
이전에도 와이어 샤크라는 애플리케이션을 이용하여 패킷을 분석해 본 경험은 있지만 오래 되기도 했고, 더군다나 좋은 정보라는 것이 무엇인지 감이 잡히지를 않았다.  
이번 과제를 진행하면서 http 프로토콜의 통신 방식에 대해 다시 한 번 되짚고, 패킷으로부터 정보를 얻는 과정을 수행하며 좋은 경험을 하게 될 것이라는 생각이 들었다.

## 1215

### Request & Response

- 와이어샤크에 Ip를 설정하고 프로그램을 동작시켜보면 수 많은 패킷들이 이동하는 것을 볼 수 있다.
- 내가 얻고자 한 정보들은 주로 GET과 POST 메서드로 호출한 url안에 들어있었다.
- GET메서드의 경우에는 url안에 data가 '&'기호로 연결되어 들어있었다.
- POST메서드의 경우에는 해당 패킷을 우클릭한 뒤, tcp stream을 클릭하면 하단에 보낸 data가 적혀있었다.
- 응답으로는 주로 정상적으로 주고 받았다는 200 신호가 나타났다. XML파일이 반환되는 경우에는 그 역시 중요한 정보가 되었다.

_똑같은 프로그램을 작동시켜서 패킷의 흐름을 확인하는데 정보가 나오지 않는다면?_  
-> **캐시에 정보가 저장되어 추가적으로 요청할 필요가 없어서 정보들이 나오지 않을 수 있다. 해당 브라우저의 캐시내역을 삭제해보자**

## 1216

인턴을 2일 남기고 학교에 제출해야 할 서류가 있어서 상사로부터 근무자 평가서를 받게 되었다.  
그리고 그에 대한 피드백을 받았는데 피드백과 내 생각을 요약한 내용은 다음과 같다.

- 근무태도 및 인간 관계 우수
- 업무를 진행하는 속도가 느리지만, 그만큼 정확도는 높은 편이다.
  - 다르게 말하면 일처리는 꼼꼼하지만 속도가 느리다.
- 전반적으로 좋은 평이 많았는데, 일부는 좋게 돌려서 말씀해주신 것 같았다.
- 마지막에 들은 '이 정도만 하면 어디를 가서도 너랑 같이 일 못하겠다고 말하는 사람은 없을거야'라는 말이 상당히 기분 좋게 다가왔다.
  - 첫 실무 경험이라 부족하게 느껴지지는 않았을까 걱정을 한 것에 비해 좋은 평가를 받은 것 같다.
  - 더 발전하여 모두가 함께 일하고 싶어하는 사람이 되야겠다는 생각을 들게 했다.

## 1217

### 생성자의 접근 제어자 - **Singleton**

- 생성자에 접근 제어자를 사용함으로써 인스턴스의 생성을 제한할 수 있다.
- 생성자의 접근 제어자를 private으로 지정하면, 외부에서 생성자에 접근할 수 없으므로 인스턴스를 생성할 수 없게 된다.
- 대신 인스턴스를 생성해서 반환해주는 public 메서드를 제공함으로써 외부에서 이 클래스의 인스턴스를 사용할수 있도록 할 수 있다.
- 이 메서드는 public인 동시에 static이어야 한다.

```java
class Singleton {
	private static Singleton s = new Singleton();	//getInstance()에서 사용될 수 있도록 인스턴스가
                                                    미리 생성되야 하므로 static이어야 함
	private Singleton() {

	}

	public static Singleton getInstance() { 	//인스턴스를 생성하지 않고도 호출할 수 있어야 하므로 static이어야 함
		return s;
	}
}
```

    * 이처럼 생성자를 통해 직접 인스턴스를 생성하지 못하게 하고 public메서드를 통해 인스턴스에 접근하게 함으로써 사용할 수 있는 인스턴스의 개수를 제한할 수 있다.

- 생성자가 private인 클래스는 다른 클래스의 조상이 될 수 없다.
  - 자손 클래스가 인스턴스를 생성할 때, 조상클래스의 생성자를 호출해야만 하는데, 생성자의 접근 제어자가 private이므로 자손클래스에서 호출하는 것이 불가능 하기 때문
  - 클래스 앞에 final을 더 추가하여 상속할 수 없는 클래스라는 것을 알리는 것이 좋다.

## 1218

### static import문

- static import 문을 사용하면 static멤버를 호출할 때 클래스 이름을 생략할 수 있다.
- 특정 클래스의 static멤버를 자주 사용할 때 편리하다.

```java
import static java.lang.Integer.*;	//Integer클래스의 모든 static메서드
import static java.lang.Math.random;	//Math.random()만. 괄호 안붙임.
import static java.lang.System.out;	//System.out을 out만으로 참조가능
```

    * 위와 같이 static import문을 선언하였다면,

`System.out.println(Math.random());` 을  
`out.println(random());`으로 간략히 할 수 있다.

## 1219

### 패키지(package)

**패키지란, 클래스들의 묶음**

- 클래스의 실제 이름(full name)은 패키지명을 포함한 것
  ex) String클래스의 실제 이름은 java.lang.String
- 클래스가 물리적으로 하나의 클래스파일(.class)인 것과 같이 패키지는 물리적으로 하나의 디렉토리
- 하나의 소스파일에는 첫 번째 문장으로 단 한 번의 패키지 선언만을 허용
- 모든 클래스는 반드시 하나의 패키지로 속해야 한다.
- 패키지는 점(.)을 구분자로 하여 계층구조로 구성할 수 있다.
- 패키지는 물리적으로 클래스 파일(.class)을 포함하는 하나의 디렉토리

### 패키지의 선언

`package 패키지명;`

- 해당 소스파일에 포함된 모든 클래스나 인터페이스는 선언된 패키지에 속하게 된다.
- 소스파일에 자신이 속할 패키지를 지정하지 않은 클래스는 자동적으로 '이름 없는 패키지'에 속하게 된다.

## 1220

### 다형성이란?

**객체지향**에서는 '여러 가지 형태를 가질 수 있는 능력'  
**자바**에서는 조상클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조할 수 있도록 함

ex) Tv와 CaptionTv클래스가 서로 상속 관계일 때,

`Tv t = new CationTv();`

-     실제 인스턴스가 CaptionTv 타입이라 할지라도, 참조 변수 t로는 CaptionTv 인스턴스의 모든 멤버를 사용할 수 없다.
- Tv타입의 참조변수로는 CaptionTv 인스턴스 중에서 Tv 클래스의 멤버들만 사용할 수 있다.
- **같은 타입의 인스턴스라도 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라진다.**

_반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조하는 것은 가능할까?_

`CaptionTv c = new Tv(); //컴파일 에러`

- 실제 인스턴스인 Tv의 멤버 개수보다 참조변수 c가 사용할 수 있는 멤버 개수가 더 많기 때문
- 자손타입의 참조변수로 조상타입의 인스턴스를 참조하는 것은 존재하지 않는 멤버를 사용하고자 할 가능성이 있으므로 허용하지 않음
- **참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 같거나 적어야 한다.**

> **조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다**  
> **반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없다**

### 참조변수의 형변환

- 서로 상속관계에 있는 클래스사이에서는 참조변수도 형변환이 가능하다.
- 자손타입의 참조변수를 조상타입의 참조변수로, 조상타입의 참조변수를 자손타입의 참조변수로의 형변환만 가능

**자손타입 -> 조상타입(Up-casting) : 형변환 생략가능**  
**조상타입 -> 자손타입(Down-casting) : 형변환 생략불가**

- 자손타입의 참조변수를 조상타입의 참조변수로 형변환 하는 것은 참조변수가 다룰 수 있는 멤버의 개수가 실제 인스턴스가 갖고 있는 멤버의 개수보다 적을 것이 분명하므로 문제가 되지 않는다. 그래서 형변환을 생략할 수 있다.
- 형변환은 참조변수의 타입을 변환하는 것이지 인스턴스를 변환하는 것은 아니기 때문에 참조변수의 형변환은 인스턴스에 아무런 영향을 미치지 않는다.
  단지 참조변수의 형변환을 통해서, 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위(개수)를 조절하는 것뿐이다.

```java
public class CastingTest {
    public static void main(String[] args) {
        Car car = new Car();
        Car car2 = null;
        FireEngine fe = null;

        car.drive();
        fe = (FireEngine) car;		//컴파일은 OK. 실행 시 에러가 발생
        fe.drive();
	car2 = fe;
	car2.drive();
    }
}
```

- 참조변수 car가 참조하고 있는 인스턴스가 Car타입의 인스턴스이기 때문에 조상 타입의 인스턴스를 자손타입의 참조변수로 참조하는 것은 허용되지 않는다.
- 컴파일 시에는 참조변수간의 타입만 체크하기 때문에 실행 시 생성될 인스턴스의 타입에 대해서는 전혀 알지 못한다.
- 서로 상속관계에 있는 타입간의 형변환은 양방향으로 자유롭게 수행될 수 있으나, 참조변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용되지 않는다.
- 그래서 **참조변수가 가리키는 인스턴스의 타입이 무엇인지 확인하는 것**은 중요하다.

### instance 연산자

- 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 instanceof 연산자를 사용한다.
- 왼쪽에는 참조변수를 오른쪽에는 타입(클래스명)이 피연산자로 위치한다.
- 실제 인스턴스와 같은 타입의 instanceof연산 이외에 조상타입의 instanceof연산에도 true를 결과로 얻는다.
- **어떤 타입에 대한 instanceof연산의 결과가 true라는 것은 검사한 타입으로 형변환이 가능하다는 것을 뜻한다**
