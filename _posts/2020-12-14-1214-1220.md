---
title: "1214-1220"
tag: TIL
---
## 1214
### *자신을 되돌아 봄*


지난 주에 TIL을 작성하며 느낀 점은 너무 내용만 있고 나의 의견이 부족하다는 것이다.  
문법이나 학습한 내용은 포스트로도 작성하니 내 생각을 정리하는 내용의 비중을 높이자  
내가 TIL을 시작한 목적 중 가장 큰 이유는 자신의 하루를 되돌아 봄으로써 얻는 **깨달음**이다.  
같은 시간을 투자하여 공부를 해도 얼마나 집중하였는지가 내 지식의 질을 높여준다.  
하루를 되돌아보고 깨달음을 원동력으로 반성을 발판삼아 후회 없는 시간을 보내자
- - -

### 패킷을 분석한 정보 획득
벌써 기업에서 인턴 생활을 한지 6개월이라는 시간이 흘렀다.  
지금까지 앵귤러를 이용하여 SPA를 개발하였고, 남은 1주일 동안은 지금까지 해 온 것과는 다른 특별한 과제가 주어졌다.  
플래시를 동작시키면서 패킷을 분석하여 정보를 얻어내고, 보기 좋게 워드 파일로 정리하여 HTML5로 변환하는 데에 사용할 수 있도록 하는 것이다.  
이전에도 와이어 샤크라는 애플리케이션을 이용하여 패킷을 분석해 본 경험은 있지만 오래 되기도 했고, 더군다나 좋은 정보라는 것이 무엇인지 감이 잡히지를 않았다.  
이번 과제를 진행하면서 http 프로토콜의 통신 방식에 대해 다시 한 번 되짚고, 패킷으로부터 정보를 얻는 과정을 수행하며 좋은 경험을 하게 될 것이라는 생각이 들었다.

## 1215
### Request & Response
* 와이어샤크에 Ip를 설정하고 프로그램을 동작시켜보면 수 많은 패킷들이 이동하는 것을 볼 수 있다.
* 내가 얻고자 한 정보들은 주로 GET과 POST 메서드로 호출한 url안에 들어있었다.
* GET메서드의 경우에는 url안에 data가 '&'기호로 연결되어 들어있었다.
* POST메서드의 경우에는 해당 패킷을 우클릭한 뒤, tcp stream을 클릭하면 하단에 보낸 data가 적혀있었다.
* 응답으로는 주로 정상적으로 주고 받았다는 200 신호가 나타났다. XML파일이 반환되는 경우에는 그 역시 중요한 정보가 되었다.  


*똑같은 프로그램을 작동시켜서 패킷의 흐름을 확인하는데 정보가 나오지 않는다면?*  
-> **캐시에 정보가 저장되어 추가적으로 요청할 필요가 없어서 정보들이 나오지 않을 수 있다. 해당 브라우저의 캐시내역을 삭제해보자**

## 1216
인턴을 2일 남기고 학교에 제출해야 할 서류가 있어서 상사로부터 근무자 평가서를 받게 되었다.  
그리고 그에 대한 피드백을 받았는데 피드백과 내 생각을 요약한 내용은 다음과 같다.  
* 근무태도 및 인간 관계 우수
* 업무를 진행하는 속도가 느리지만, 그만큼 정확도는 높은 편이다.  
    * 다르게 말하면 일처리는 꼼꼼하지만 속도가 느리다.  
* 전반적으로 좋은 평이 많았는데, 일부는 좋게 돌려서 말씀해주신 것 같았다.  
* 마지막에 들은 '이 정도만 하면 어디를 가서도 너랑 같이 일 못하겠다고 말하는 사람은 없을거야'라는 말이 상당히 기분 좋게 다가왔다.
    * 첫 실무 경험이라 부족하게 느껴지지는 않았을까 걱정을 한 것에 비해 좋은 평가를 받은 것 같다.
    * 더 발전하여 모두가 함께 일하고 싶어하는 사람이 되야겠다는 생각을 들게 했다.  

## 1217
### 생성자의 접근 제어자 - **Singleton**
* 생성자에 접근 제어자를 사용함으로써 인스턴스의 생성을 제한할 수 있다.
* 생성자의 접근 제어자를 private으로 지정하면, 외부에서 생성자에 접근할 수 없으므로 인스턴스를 생성할 수 없게 된다.
* 대신 인스턴스를 생성해서 반환해주는 public 메서드를 제공함으로써 외부에서 이 클래스의 인스턴스를 사용할수 있도록 할 수 있다.
* 이 메서드는 public인 동시에 static이어야 한다.
```java
class Singleton {
	private static Singleton s = new Singleton();	//getInstance()에서 사용될 수 있도록 인스턴스가
                                                    미리 생성되야 하므로 static이어야 함
	private Singleton() {
		
	}

	public static Singleton getInstance() { 	//인스턴스를 생성하지 않고도 호출할 수 있어야 하므로 static이어야 함
		return s;		
	}
}
```
	* 	이처럼 생성자를 통해 직접 인스턴스를  생성하지 못하게 하고 public메서드를 통해 인스턴스에 접근하게 함으로써 사용할 수 있는 인스턴스의 개수를 제한할 수 있다.
* 생성자가 private인 클래스는 다른 클래스의 조상이 될 수 없다.
	* 자손 클래스가 인스턴스를 생성할 때, 조상클래스의 생성자를 호출해야만 하는데, 생성자의 접근 제어자가 private이므로 자손클래스에서 호출하는 것이 불가능 하기 때문
	* 클래스 앞에 final을 더 추가하여 상속할 수 없는 클래스라는 것을 알리는 것이 좋다.
