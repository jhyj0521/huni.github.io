---
title: "0719-0725"
tag: TIL
category: TIL
---
## 0719
# 6일 차 JS 12 ~ 21회차 강의 정리




## 객체
* 어떠한 값을 선언할 때, 하나의 이름에 여러 종류의 값을 넣을 수 있게 해준다.
* 중괄호를 열고 그 안에 `키: 값` 쌍으로 쉼표로 구분해서 넣는다.
* 객체 안에 객체 삽입 가능
* 키에 공백이 있을 경우에는 `''`로 묶어줘야 동작한다.
* `객체변수.키`를 콘솔로 찍어보면 키에 해당하는 값이 나온다.

### 비구조화 할당
* ES6에 있는 문법으로, 객체 구조 분해라고 불리기도 한다.
* 객체에서 특정 값들을 추출해내는 역할

```javascript
function print(hero) {
	const { alias, name, actor } = hero;
	const text = `${alias}(${name}) 역할을 맡은 배우는 ${actor} 입니다.`;
	console.log(text);
}
```
* 파라미터에 `{ alias, name, actor }`를 써도 정상 작동한다.
* 꼭 함수 내부에 사용할 필요는 없다. 변수로 선언해서 사용할 수도 있다.
	* ex) `const { name } = ironMan;`

### 객체 안에 함수 넣기
```javascript
const dog = {
	name: '멍멍이',
	sound: '멍멍!',
	say: function say() {
		console.log(this.sound);
	}
};
```
* `say: function say()`를 `say: function()`또는 `say()`로 바꿔줘도 정상 작동한다.
* 여기서의 `this`는 속해있는 곳으로 연결한다.
* 여기서 만든 함수를 꺼내게 되면 this와의 관계는 사라진다.
* 화살표 함수로 만들게 된다면, this가 뭔지 모르기 때문에 작동하지 않는다.

### Getter와 Setter함수
* 객체 안에 Getter함수와 Setter함수를 설정할 수 있다.
* Getter함수는 특정 값을 조회할 때마다 실행된다.
* Setter함수는 특정 값을 설정할 때마다 실행된다.
* Getter함수를 만들 때는 앞에 키워드 get을 붙이고 함수를 선언하면 된다. 반드시 어떤 값을 반환해줘야 한다.
* Setter함수를 만들 때는 앞에 키워드 set을 붙이고 함수를 선언하면 된다. 단 여기서 파라미터를 필수로 넣어줘야 한다.

```javascript
const numbers = {
    a: 1,
    b: 2,
    get sum() {
        console.log('sum 함수가 실행됩니다!');
        return this.a + this.b;
    }
};

console.log(numbers.sum);
numbers.a = 5;
console.log(numbers.sum);
```
* getter 함수는 특정 값을 호출하는 것이 아니라 ex) `sum()` 조회하려 할 때 특정 코드를 실행시키고 값을 반환하는 코드
	* 오히려 함수를 호출하듯이 하면 에러가 발생한다.

```javascript
const dog = {
    _name: '멍멍이',
    get name() {
        console.log('_name을 조회합니다..');
        return this._name;
    },
    set name(value) {
        console.log('이름이 바뀝니다..' + value);
        this._name = value;
    }
};

console.log(dog.name);
dog.name = '뭉뭉이';
console.log(dog.name);
```
* 여기서 `_name`으로 키를 작명한 것은 getter, setter와 이름이 같으면 안되기 때문이다.
* 다만 getter와  setter의 이름은 같아도 된다.
* 위와 같이 작성하면, `dog.name`으로 `_name` 값을 가져올 수 있다.

## 배열
* 여러 개의 항목들이 들어있는 리스트
* 자바스크립트에서는 한 배열에서 타입이 꼭 같을 필요가 없다.
* 대괄호 `[]`로 선언한다.
* 0부터 시작한 인덱스로 배열에 접근 가능하다.

### push
* `배열변수.push(값)`을 사용해 배열의 끝에 값을 삽입할 수 있다.

### length
* `배열변수.length`는 배열의 길이를 반환한다.
	* 주의할 점은 함수가 아니라 실행하면 에러가 발생한다.

## 반복문
1. 시작
2. 조건이 true이면 구문 실행, false이면 끝
3. 구문을 실행하고, 다시 조건을 확인. 조건이 false가 될 때까지 반복

### for
```javascript
for (let i = 0; i < 10; i ++) {
	console.log(i);
}
```
* 가장 기본적인 반복문 형태인 for 문
* 0부터 9까지 1씩 증가하면서 콘솔에 찍는다.
* 1씩 작아지도록 작성하거나, 2씩 증가하도록 작성할 수도 있다.
* 배열과 조합하여 배열 내부의 값들을 인덱스로 꺼내올 수 있다.

### while
```javascript
let i = 0;

while (i < 10) {
	console.log(i);
	i++;
}
```
* for 문과 다른 점은 초깃 값을 while문 바깥에 한다는 것과, 선언부에 증감식을 준다는 것이다.
* 무한 루프를 돌지 않도록 조건을 잘 줘야 한다.

### for...of
```javascript
const array = [1,2,3,4];

for(let num of array) {
    console.log(num);
}

// 결괏값
1
2
3
4
```
* `for...of`는 배열 안에 있는 것들을 반복적으로 사용해서 작업해야 할 때 쓴다.


### for...in
```javascript
const dog = {
    name: '멍멍이',
    sound: '멍멍',
    age: 2
};

for (let key in dog) {
    console.log(`${key}: ${dog[key]}`);
}
```
* `for...in`은 객체에 대한 반복적인 작업을 처리해야 할 때 쓴다. 
* key 변수에는 dog 객체의 모든 키가 담기는데, template literal을 사용해서 dog 객체의 값을 받아올 수도 있다.


### Object 객체 내장함수
```javascript
const dog = {
    name: '멍멍이',
    sound: '멍멍',
    age: 2
};

console.log(Object.entries(dog));
console.log(Object.keys(dog));
console.log(Object.values(dog));

// 결괏값
[ [ 'name', '멍멍이' ], [ 'sound', '멍멍' ], [ 'age', 2 ] ]
[ 'name', 'sound', 'age' ]
[ '멍멍이', '멍멍', 2 ]
```
* `Object.entries()`는 객체의 키, 값 쌍 2차원 배열 형태로 반환한다.
* `Object.keys()`는 객체의 모든 키를 배열로 반환한다.
* `Object.values()`는 객체의 모든 값을 배열로 반환한다.


### break와 continue
* continue를 반복문 내에서 만나게 되면 바로 증감식으로 넘어가서 다음 루프를 돌게 된다.
* break 문을 만나게 되면 반복문이 아예 끝난다.

## 0720

# 7일 차 JS 22 ~ 29회차 강의 정리
## 배열 내장함수
### forEach
* 배열의 각 요소들에서 특정 동작을 수행한다.
* 매개변수로 콜백함수를 받는다.
* 배열의 값 뿐만 아니라 인덱스에도 접근할 수 있다.

```javascript
const heroes = ['아이언맨', '캡틴 아메리카', '토르', '닥터 스트레인지'];

heroes.forEach((hero, index) => {
    console.log(hero, index);
})


// 결괏값
아이언맨 0
캡틴 아메리카 1
토르 2
닥터 스트레인지 3
```

### map
* 배열 안의 원소를 변환할 때 사용

```javascript
const items = [
    {
        id: 1,
        text: 'hello'
    },
    {
        id: 2,
        text: 'bye'
    }
];

const texts = items.map((item) => item.text);
console.log(texts);

// 결괏값
[ 'hello', 'bye' ]
```

### indexOf
* 해당하는 값이 배열 안에서 첫 번째로 발견된 인덱스를 반환한다.
* 값을 배열에서 찾지 못하면 -1을 반환

```javascript
const superheroes = ['아이언맨', '캡틴 아메리카', '토르', '닥터 스트레인지'];
const index = superheroes.indexOf('토르');
console.log(index);

// 결괏값
2
```

### findIndex
* 배열 안에 있는 값들이 객체이거나, 특정 조건을 확인해야 하는 경우 사용

```javascript
const todos = [
    {
        id: 1,
        text: '자바스크립트 입문',
        done: true
    },
    {
        id: 2,
        text: '함수 배우기',
        done: true
    },
    {
        id: 3,
        text: '객체와 배열 배우기',
        done: true
    },
    {
        id: 4,
        text: '배열 내장함수 배우기',
        done: false
    }
];
 
const index = todos.findIndex(todo => todo.id === 3);
console.log(index);

// 결괏값
2
```
* `findIndex()`는 인덱스를 반환해준다면, `find()`는 찾은 객체 자체를 반환해준다.

### filter
* 특정 배열에서 특정 조건을 만족하는 원소들만 추출해서 새로운 배열을 만들 때 사용

```javascript
const taskNotDone = todos.filter(todo => !todo.done);

console.log(taskNotDone);

// 결괏값
[ { id: 4, text: '배열 내장함수 배우기', done: false } ]
```
* 기존의 배열은 건드리지 않고 새로운 배열을 생성한다.

### splice, slice
* splice는 매개변수로 받는 인덱스에 해당하는 값을 삭제한다.
* 첫 번째 매개변수에는 삭제하고자 하는 인덱스, 두 번째 매개변수에는 그 인덱스부터 시작하여 몇개를 지울 것인지를 받는다.
* splice의 결괏값으로 삭제한 배열을 반환한다.
* slice와 splice의 차이점은 slice는 기존 배열은 건드리지 않고, 잘라낸 배열만 반환한다는 것이다.

```javascript
const numbers = [10, 20, 30, 40];
const index = numbers.indexOf(30);
console.log(index);

const spliced = numbers.splice(index, 1);
console.log(numbers);
console.log(spliced);

// 결괏값
2
[ 10, 20, 40 ]
[ 30 ]
```

### shift, unshift, pop, push
* shift는 배열에서 가장 앞에 있는 원소를 배열에서 꺼내고 반환해준다.
* pop은 배열에서 가장 뒤에 있는 원소를 배열에서 꺼내고 반환해준다.
* unshift는 배열에서 가장 앞에 값을 삽입한다.
* push는 배열의 맨 뒤에 값을 삽입한다.

### concat
* 기존의 배열을 건드리지 않고, 두 배열을 합쳐서 새로운 배열을 반환한다.

```javascript
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

const concated = arr1.concat(arr2);
console.log(concated);

// 결괏값
[ 1, 2, 3, 4, 5, 6 ]
```

### join
* 배열을 문자열로 변환해준다.
* separate를 매개변수로 받는다. 기본 값은 ,

```javascript
const array = [1, 2, 3, 4, 5];

console.log(array.join());

// 결괏값
1,2,3,4,5
```

### reduce
* 배열 안의 모든 값들을 사용해서 연산해야 할 때 사용

```javascript
const numbers = [1, 2, 3, 4, 5];

const sum = numbers.reduce((acc, current) => acc + current, 0);
console.log(sum);
```
* 첫 번째 매개변수에는 함수를 넣게 되는데, 그 함수는 기본적으로 값을 저장할 accumulator과 현재 배열의 값을 가지는 current를 갖는다.
* 두 번째 매개변수에는 값을 저장할 accumulator의 초기값을 설정한다.
* acc를 초기화하고, 함수에서 배열의 값과 필요한 연산을 한 뒤 다시 그 값을 acc에 저장하는 것을 반복한다.
* 첫 번째 매개변수에서 acc과 current 뒤에 배열의 index 값과 자기 자신 배열을 가리키는 array를 가져올수도 있다.

```javascript
const alphabets = ['a', 'a', 'a', 'b', 'c', 'c', 'd', 'e'];
const counts = alphabets.reduce((acc, current) => {
    if (acc[current]) {
        acc[current] += 1;
    } else {
        acc[current] = 1;
    }
    return acc;
}, {})

console.log(counts);

// 결괏값
{ a: 3, b: 1, c: 2, d: 1, e: 1 }
```
* 위와 같이 알파벳의 개수를 구할수도 있다.

---

## 0721
# 8일 차 JS 1 ~ 6회차 강의 정리 및 알고리즘
오늘부터 자바스크립트 온라인 강의와 더불어 알고리즘 과제를 해결하기로 했다.
난이도는 기업 코딩테스트 기준으로 봤을 때는 상당히 쉬운 문제들이지만, 문제를 풀면서 새로 알게된 개념이나 유용한 코딩을 간단하게나마 정리해보고자 한다.

## 알고리즘
### 중복 문자 제거
![01-01](../../assets/images/algorithm/01/01.png)

```javascript
function solution(str) {
    let answer = '';
    for (let i = 0; i < str.length; i++) {
        if (answer.indexOf(str.charAt(i)) === -1) {
            answer += str.charAt(i);
        }
    }
    return answer;
}
console.log(solution('ksekkset'));
```
* 주어진 문자열을 단어별로 반복문을 돌려서 빈 문자열에 해당하는 단어가 있는지 확인하여 없으면 해당 단어를 추가하여 결과를 출력했다.

### 회문 문자열
![01-02](../../assets/images/algorithm/01/02.png)

```javascript
function solution(str) {
    let answer = '';
    const lowerStr = str.toLowerCase();
    const reversedStr = lowerStr.split('').reverse().join('');

    if (lowerStr === reversedStr) {
        answer = 'YES';
    } else {
        answer = 'NO';
    }
    return answer;
}

console.log(solution('gooG'));
console.log(solution('gattBG'));
```
1. 우선 대소문자를 구분하지 않기 위해서 문자열을 소문자로 통일하기 위해 변환하였다.
2. `split('').reverse().join('')`를 사용해 문자열을 배열로 바꾸고, 배열 함수로 순서를 거꾸로 뒤집어서 다시 문자열로 만들었다.
3. 기존 문자열과 뒤집은 문자열을 비교하여 결과를 반환하였다.

### 뒤집은 소수
![01-03](../../assets/images/algorithm/01/03.png)

```javascript
function solution(array) {
    const answer = [];

    array.forEach(num => {
        const reversed = parseInt(num.toString().split('').reverse().join(''));

        if (reversed === 1) {
            return;
        }

        for (let i = 2; i < reversed; i++) {
            if (reversed % i === 0) {
                return;
            }
        }

        answer.push(reversed);
    })

    return answer;
}

console.log(solution([32, 55, 62, 20, 250, 370, 200, 30, 100]));
```
1. 숫자 배열을 반복문을 사용해서 문자열로 바꾼 뒤, `split('').reverse().join('')`으로 뒤집고 다시 숫자형으로 변하게 해서 첫 자리부터 연속된 0을 무시하면서 수를 뒤집었다.
2. 뒤집은 수가 1이면 소수가 아니기에 return 시켰고, 2부터 자기 자신 수까지 나누어 떨어지는 수가 있으면 소수가 아니기에 return 시켰다. 그 외에는 모두 정답 배열에 push 시켜서 결과를 도출하였다.

### 괄호문자제거
![01-04](../../assets/images/algorithm/01/04.png)

```javascript
function solution(str) {
    let answer = '';
    let stack = [];

    let array = str.split('');
    array.forEach((element) => {
        if (element === ')') {
            stack.splice(stack.lastIndexOf('('));
        } else {
            stack.push(element);
        }
    })
    answer = stack.join('');
    return answer;
}

console.log(solution('(A(BC)D)EF(G(H)(IJ)K)LM(N)'));
```
1. `forEach`로 배열을 돌리기 위해 문자열을 배열로 변환하였다.
2. 반복문을 사용해서 요소가 '('나 일반 문자라면 빈 스택에 push 하였고, ')'라면 뒤에서부터 '('의 인덱스를 찾아서 해당 인덱스부터 맨 뒤까지의 모든 요소를 제거하였다.
3. 배열을 `join`함수로 문자열로 변환하여 결과를 출력하였다.

### 재귀함수를 이용한 이진수 출력
![01-05](../../assets/images/algorithm/01/05.png)

```javascript
function solution(num) {
    let answer = '';
    let devided = parseInt(num / 2);

    if (devided === 1) {
        answer += devided;
        answer += num % 2;
    } else {
        answer = solution(devided);
        answer += num % 2;
    }

    return answer;
}

console.log(solution(11));
console.log(solution(20));
```
1. 받아온 숫자를 2로 나눠서 몫을 구한 값을 변수에 담았다.
2. 몫이 1이면 더 이상 나눌 필요가 없기에 빈 문자열 answer에 몫과 나머지를 순서대로 더했다.
3. 몫이 1이 아니라면 계속 나눠야 하기 때문에 나올 때까지 재귀 호출하여 반환된 값을 answer에 저장했다.
4. 순차적으로 호출이 마친 뒤에 해당 블록의 나머지 값을 문자열에 순차적으로 더해서 재귀호출을 사용해 이진수를 구했다.

* 자바에서는 몫을 구할 때 두 수 모두 자연수이면 결과 값도 몫만 도출되었는데, 자바스크립트에서는 소수로 구해진다는 사실을 처음 알게 되었다. 이 점을 유의해서 코딩해야겠다고 생각했다.
* 재귀호출은 쉬우면서도 머리가 너무 아프다. 이 부분을 잘 정리해서 더 어려운 문제를 맞닥트렸을 때, 자유자재로 사용할 수 있게 실력을 키워야겠다.

## JS 강의 정리
### 삼항 연산자
`condition ? true : false`

* `if ~ else`문의 조금 더 편하게 쓰는 문법이라고 할 수 있다.
* condition 내의 값이 true 이면 ? 뒤의 문장이 실행되고, false이면 : 뒤의 문장이 실행된다.
* 삼항 연잔자를 연속으로 중첩해서 사용하는 것은 가독성이 떨어질 수 있으므로, 그런 상황에서는 if 문으로 대체한다.

### Truthy와 Falsy
* Truthy는 True 같은 것. Falsy는 False 같은 것.
* Falsy한 값의 대표적인 5개의 값
	* undefined
	* null
	* 0
	* ''
	* NaN
* 그 외에는 모두 Truthy한 값
* 조건문에서 잘 활용할 수 있다.

```javascript
console.log(!undefined);
console.log(!0);
console.log(!null);
console.log(!'');
console.log(!NaN);

// 결괏값
true
true
true
true
true
```
* 예를 들어 변수가 Falsy한 값일 때, 방어 코드를 작성하는 곳에 활용할 수 있다.
* 또는 변수 값이 Truthy한 값일 때만 조건문 블럭을 실행하는 방식으로도 사용할 수 있다.

### 단축 평가 논리 계산법
* 논리 연산자를 사용해서 코드를 더 짧게 쓰는 방법

```javascript
console.log(true && 'hello');
console.log(false && 'hello');
console.log('hello' && 'bye');
console.log(null && 'hello');
console.log(undefined && 'hello');
console.log('' && 'hello');
console.log(1 && 'hello');

// 결괏값
hello
false
bye
null
undefined

hello
```
* `&&` 연산자는 앞에 있는 값이 Truthy 한 값이면 뒤의 값이 나오고, 앞에 있는 값이 Falsy한 값이면 앞의 값이 나온다.
* 특정 값이 유효할 때만 특정 값을 조회해야 하는 상황
* `||` 연산자는 앞에 있는 값이 Truthy 한 값이면 앞의 값이 나오고, 앞의 값이 Falsy한 값이면 뒤의 값이 나온다.
* 어떤 값이 없을 때, 값을 지정해 줄 때 사용하면 유용하다.

### 함수의 기본 파라미터
* 함수를 호출할 때 인자를 주지 않았을 경우에 기본 파라미터 값을 설정할 수 있다.

```javascript
function calculate(r = 1) {
    return Math.PI * r * r;
}

console.log(calculate());

// 결괏값
3.141592653589793
```
* 매개변수에 `=` 기호 우측에 값을 입력하면 그것이 해당 매개변수의 값을 전달받지 못했을 때 기본값이 된다.
* 화살표 함수에서도 같은 방식으로 기본 파라미터를 지정할 수 있다.

### 조건문 더 스마트하게 쓰기
#### 특정 값이 여러 값 중 하나인지 확인해야 하는 상황
```javascript
function isAnimal(text) {
    return (
        text === '고양이' || text === '개' || text == '거북이' || text === '너구리'
    );
}

console.log(isAnimal('개'));
console.log(isAnimal('노트북'));
```

* 비교하고자 하는 값을 배열로 선언해서 내장함수 includes로 보기 좋게 작성할 수 있다.

```javascript
const isAnimal = (text) => ['고양이', '개', '거북이', '너구리'].includes(text);
```

#### 주어진 값에 따라 다른 결과물을 반환해야 하는 상황
```javascript
function getSound(animal) {
    if (animal === '개') return '멍멍!';
    if (animal === '고양이') return '야옹~';
    if (animal === '참새') return '짹짹';
    if (animal === '비둘기') return '구구 구 구';
    return '...?';
}

console.log(getSound('개'));
console.log(getSound('비둘기'));
console.log(getSound('인간'));
```

* `switch ~case`문으로 바꿀수도 있으나 그렇게 했을 경우는 위의 if문과 큰 차이가 없다.
* 객체를 활용해서 더 깔끔하게 구현할 수 있다.

```javascript
function getSound(animal) {
    const sounds = {
        개: '멍멍!',
        고양이: '야옹~',
        참새: '짹짹',
        비둘기: '구구 구 구'
    };
    return sounds[animal] || '...?';
}

console.log(getSound('개'));
console.log(getSound('비둘기'));
console.log(getSound('인간'));
```
* 객체의 키 값과 단축 평가 논리 계산법을 이용해서 깔끔하게 구현하였다.

### 주어진 값에 따라 다른 결과물을 실행해야 하는 상황
* 위의 주어진 값에 따라 다른 결과물을 반환해야 하는 상황과 비슷하다.

```javascript
function makeSound(animal) {
    const tasks = {
        개: () => console.log('멍멍!'),
        고양이() {
            console.log('야옹~');
        },
        비둘기() {
            console.log('구구 구 구');
        } 
    };
    if (!tasks[animal]) {
        console.log('...?');
        return;
    }
    tasks[animal]();
}

makeSound('개');
makeSound('비둘기');
makeSound('인간');
```

### 비구조화 할당
* 비구조화 할당에서도 함수의 기본 파라미터와 같은 방식으로 기본 값을 설정할 수 있다.

```javascript
const object = { a: 1 };

const { a, b = 2 } = object;
console.log(a);
console.log(b);

// 결괏값
1
2
```

* 비구조화 할당을 할 때 이름을 바꿀 수도 있다.

```javascript
const animal = {
    name: '멍멍이',
    type: '개'
};

const { name: nickname } = animal;

console.log(nickname);

// 결괏값
멍멍이
```
* animal이 가지고 있던 name 값이 바뀌는 것은 아니다.

* 배열에서도 비구조화 할당을 사용할 수 있다.

```javascript
const array = [1, 2];

const [one, two = 2] = array;

console.log(one);
console.log(two);
```
* 배열의 요소를 변수에 쉽게 할당할 수 있는 방법이다.
* 객체의 비구조화 할당과 동일하게 기본값을 설정할 수 있다.

* 객체 깊숙한 곳에 있는 것을 비구조화 할당할 수 있다.

```javascript
const deepObject = {
    state: {
        information: {
            name: 'junghoon',
            languages: ['korean', 'english']
        }
    },
    value: 5
}

const { name, languages } = deepObject.state.information;
const { value } = deepObject;

const extracted = {
    name,
    languages,
    value
};
console.log(extracted);

// 결괏값
{ name: 'junghoon', languages: [ 'korean', 'english' ], value: 5 }
```
* depth가 다른 값을 비구조화 할당으로 꺼내오는 방법으로는 크게 두 가지 방법이 있는데 첫 번째는 위와 같이 비구조화 할당을 두 번 사용하는 것이다.
* extracted는 값을 설정하는 것을 생략했는데, 이미 키에 값이 있기 때문에 생략해도 된다.

* 두 번째 방법은 비구조화 할당을 한 번 하면서 여러 값을 다 빼오는 것이다.

```javascript
const {
    state: {
        information: {
            name, languages
        }
    },
    value
} = deepObject;
```
* 가독성이 떨어진다는 단점이 있다.

## 0722
# 9일 차 JS 7 ~ 12회차 강의 정리 및 알고리즘
## 알고리즘
### 대문자 찾기
![02-01](../../assets/images/algorithm/02/01.png)

```javascript
function solution(str) {
    let answer = 0;

    for (let i = 0; i < str.length; i++) {
        if(str[i] === str[i].toUpperCase()) {
            answer++;
        }
    }

    return answer;
}

console.log(solution('KoreaTimeGood'));
```
* 문자열을 조회해서 대문자로 변경한 값과 기존의 값이 동일한지 체크하고, 동일한 수를 세서 반환하였다.

### 대소문자 변환
![02-02](../../assets/images/algorithm/02/02.png)

```javascript
function solution(str) {
    let answer = '';

    for(let i = 0; i < str.length; i++) {
        if (str.charAt(i) === str.charAt(i).toUpperCase()) {
            answer += str.charAt(i).toLowerCase();
        } else {
            answer += str.charAt(i).toUpperCase();
        }
    }

    return answer;
}

console.log(solution('StuDY'));
console.log(solution('gattBG'));
```
* 대문자 찾기 문제와 비슷한 방법을 사용해서, 문자가 대문자라면 소문자로 바꾸고 아니라면 소문자이므로 대문자로 변환해서 반환하였다.

### 가위 바위 보
![02-03](../../assets/images/algorithm/02/03.png)

```javascript
function solution(aNum, bNum) {
    let answer = [];

    for (let i = 0; i < aNum.length; i++) {
        let info = aNum[i] - bNum[i];

        if (info === 0) answer.push('D');
        else if (info === 1 || info === -2) answer.push('A');
        else answer.push('B');
    }

    return answer;
}

console.log(solution([2,3,3,1,3], [1,1,2,2,3]));
```
* 각 판마다 서로 낸 값을 빼면 이겼을 때의 경우를 계산할 수 있다.
* 계산한 값을 사용해서 정답 배열에 비기면 D, A가 이기면 A, B가 이기면 B를 push해서 해결하였다.

### 격자판 최대합
![02-04](../../assets/images/algorithm/02/04.png)

```javascript
function solution(arr) {
    let answer = 0;
    let sum1 = 0;
    let sum2 = 0;
    let sum3 = 0;
    let sum4 = 0;
    let sumArr = [];

    for (let i = 0; i < arr.length; i++) {
        for (let j = 0; j < arr[i].length; j++) {
           sum1 += arr[i][j]; 
           sum2 += arr[j][i];
        }
        sumArr.push(sum1);
        sumArr.push(sum2);
        sum1 = 0;
        sum2 = 0;
        sum3 += arr[i][i];
        sum4 += arr[i][arr.length - 1 - i];
    }
    sumArr.push(sum3);
    sumArr.push(sum4);

    sumArr.forEach(element => {
        if (element >= answer) {
            answer = element;
        }
    });

    return answer;
}

console.log(solution([[10, 13, 10, 12, 15], [12, 39, 30, 23, 11], [11, 25, 50, 53, 15], [19, 27, 29, 37, 27], [19, 13, 30, 13, 19]]));
```
* 꽤 어려웠다고 느꼈던 문제이다. 예전에 자바 공부를 하면서 배열을 2차원 인덱스로 적어 나타내서 규칙을 찾는 방법이 생각나서 그 방법으로 풀었다. 
* 왠지 sum1~4 까지 변수를 너무 많이 선언한 것은 아닌가 하는 아쉬움이 드는 문제였다.
* 각 가로, 세로, 대각선의 합을 한 배열에 넣고 그 배열 내에서 최대값을 반환해서 해결했다.

### 문자열 압축
![02-05](../../assets/images/algorithm/02/05.png)

```javascript
function solution(str) {
    let answer = [];
    let arr = str.split('');
    let cntArr = {};

    for (let i = 0; i < arr.length; i++) {
        if (arr[i] !== arr[i + 1]) {
            answer.push(arr[i]);
        } else {
            cntArr[arr[i]] = (cntArr[arr[i]] || 1) + 1;
        }
    }

    for (let i = 0; i < answer.length; i++) {
        if (cntArr[answer[i]]) {
            answer.splice(i+1, 0, cntArr[answer[i]]);
        }
    }
    answer = answer.join('');

    return answer;
}

console.log(solution('KKHSSSSSSSE'));
console.log(solution('KSHHEAAA'));
```
* 문자열을 배열로 바꾸고 반복문을 돌려서 현재 인덱스에 위치한 문자가 다음 인덱스에 위치한 문자랑 다르다면 정답 배열에 push하고 같다면 해당 문자가 몇 번이나 나왔는지 저장하는 객체에 담았다.
* 객체에 담을 때 `+=` 연산자를 사용하려 했는데 NaN이 나왔다.
	* 숫자로 초기화되지 않은 영역에 `+=`를 사용할 수 없다는 것을 알게 되었고, 최근에 배운 단축 평가 논리 계산법을 이용해서 해결하였다.
* 정답 배열에 해당 문자의 반복 횟수를 객체에서 꺼내서 삽입하고, 문자열로 다시 변환해서 반환하였다.

### 멘토링
![02-06](../../assets/images/algorithm/02/06.png)

```javascript
function solution(nums) {
    let answer = 0;
    const testCnt = nums.length;
    const stuCnt = nums[0].length;

    // 학생의 수가 n명이면 n * n가지의 경우의 멘토, 멘티 수가 나온다.
    for (let i = 1; i <= stuCnt; i++) {
        for (let j = 1; j <= stuCnt; j++) {
            // 멘토랑 멘티가 같은 학생일 수는 없으므로 패스
            if (i === j) continue;
            let cnt = 0;
            for (let k = 0; k < testCnt; k++) {
                if (nums[k].indexOf(i) < nums[k].indexOf(j)) {
                    cnt = 1;
                } else {
                    cnt = 0;
                    break;
                }
            }
            answer += cnt;
        }
    }

    return answer;
}

console.log(solution([[3, 4, 1, 2], [4, 3, 2, 1], [3, 1, 4, 2]])); 
```
* 가장 어려웠고, 1시간 이상 붙들고 있다가 안되겠어서 다른 곳에서 힌트를 조금 얻어서 겨우 해결했다.
* 이러한 문제 유형을 브루트 포스(brute force)라고 한다는데, 완전 탐색 알고리즘. 가능한 모든 경우의 수를 탐색하면서 요구조건에 충족하는 결과만 가져오는 유형이라고 한다.
* 총 3번의 반복문을 이용했는데, 반복문을 2중 이상으로 사용하면 안된다는 고정관념이 있어서 이 문제를 해결하는데 엄청 헤맨 것 같다.
* 멘토랑 멘티가 짝을 이룰 수 있는 경우의 수를 구하기 위해 2중 반복문을 사용했고, 각 테스트마다 한 번이라도 하위 등수를 받은 적이 있는지를 체크하기 위해 총 3중으로 구현했다. 사실 `indexOf()` 메소드를 사용했기에 4중이라고 할 수 있다.
* 멘토랑 멘티가 같은 사람일수는 없기에 그런 경우에는 continue로 바로 다음으로 넘어가게 했다.

### LRU (카카오 캐시 문제 변형)
![02-07](../../assets/images/algorithm/02/07.png)

```javascript
function solution(nums, s) {
    cache = Array(s).fill(0);

    for (let i = 0; i < nums.length; i++) {
        if (cache.indexOf(nums[i]) === -1) {
            cache.unshift(nums[i]);
            cache.pop();
        } else {
            cache.splice(cache.indexOf(nums[i]), 1);
            cache.unshift(nums[i]);
        }
    }
    return cache;
}

console.log(solution([1, 2, 3, 2, 6, 2, 3, 5, 7], 5));
```
* 카카오 기출 문제라고 해서 약간 겁부터 냈는데, 생각보다 너무 빠르고 쉽게 풀었다.
* 스택과 관련된 문제라고 생각해서 우선 캐시라는 변수를 선언하고 그 안에 개수만큼 0을 삽입하였다.
* 이후 자바스크립트 내장 함수를 사용해서 문제를 해결하였다.


## JS 강의 정리
### spread
* 이 문법을 사용해서 객체 또는 배열을 펼칠 수 있다.
* 기존의 객체를 건드리지 않고, 그 객체가 가지고 있는 속성을 그대로 사용하여 새로운 객체를 만들 수 있다.

```javascript
const slime = {
  name: '슬라임'
};

const cuteSlime = {
  ...slime,
  attribute: 'cute'
};

const purpleCuteSlime = {
  ...cuteSlime,
  color: 'purple'
};

// 결괏값
{ name: '슬라임' }
{ name: '슬라임', attribute: 'cute' }
{ name: '슬라임', attribute: 'cute', color: 'purple' }
```

* spread 연산자는 배열에서도 사용할 수 있다.

```javascript
const animals = ['개', '고양이', '참새'];
const anotherAnimals = [...animals, '비둘기'];
console.log(animals);
console.log(anotherAnimals);

// 결괏값
[ '개', '고양이', '참새' ]
[ '개', '고양이', '참새', '비둘기' ]
```
* 기존의 animals를 건드리지 않으면서, 새로운 배열에 animals가 가지고 있는 내용을 모두 집어넣고, '비둘기'라는 항목을 추가적으로 넣었다.
* 배열에서 spread 연산자를 여러번 사용할 수도 있다.

### rest
* rest는 객체, 배열, 그리고 함수의 파라미터에서 사용이 가능하다.

#### 객체에서의 rest
```javascript
const purpleCuteSlime = {
  name: '슬라임',
  attribute: 'cute',
  color: 'purple'
};

const { color, ...rest } = purpleCuteSlime;
console.log(color);
console.log(rest);

// 결괏값
purple
{ name: '슬라임', attribute: 'cute' }
```
* rest 안에는 color 값을 제외한 값이 들어있다.
* rest는 객체와 배열에서는 사용할 때 비구조화 할당 문법과 함께 사용된다.
* 주로 사용할 때는 rest라는 키워드를 사용하게 되는데, 추출한 값의 이름이 꼭 rest일 필요는 없다.

#### 배열에서의 rest
```javascript
const numbers = [0, 1, 2, 3, 4, 5, 6];

const [one, ...rest] = numbers;

console.log(one);
console.log(rest);

// 결괏값
0
[ 1, 2, 3, 4, 5, 6 ]
```
* 배열에서도 객체와 비슷하게 사용된다.
* 다만 주의할 점은 배열에서는 rest가 맨 마지막 요소에 위치해야 한다.

#### 함수 파라미터에서의 rest
* rest를 함수 파라미터에서도 사용할 수 있다.
* 함수의 파라미터가 몇 개가 될지 모르는 상황에서 rest 파라미터를 사용하면 매우 유용하다.

```javascript
function sum(...rest) {
  return rest.reduce((acc, current) => acc + current, 0);
}

const result = sum(1, 2, 3, 4, 5, 6);
console.log(result); // 21
```

#### 함수 인자와 spread
* 함수에서 값을 읽을 때, 그 값들은 파라미터라 부르고, 함수에서 값을 넣어줄 때, 그 값들은 인자라고 부른다.
* 함수 파라미터에서 rest를 사용한 것과 비슷한데, 반대의 역할을 한다.

```javascript
function sum(...rest) {
  return rest.reduce((acc, current) => acc + current, 0);
}

const numbers = [1, 2, 3, 4, 5, 6];
const result = sum(...numbers);
console.log(result);
```

### 자바스크립트 Scope
* Scope란, 변수나 함수를 선언하게 될 때 해당 변수 또는 함수가 유효한 범위를 의미한다.
* Scope는 총 3가지 종류가 있다.
	1. Global (전역) Scope: 코드의 모든 범위에서 사용이 가능
	2. Function (함수) Scope: 함수 안에서만 사용이 가능
	3. Block (블록) Scope: if, for, switch 등 특정 블록 내부에서만 사용이 가능
* `const`와 `let`로 선언한 값은 Block Scope로 선언이 되기 때문에 if문 같은 블록 내에서 새로운 변수/상수를 선언하게 된다면, 해당 블록 내부에서만 사용이 가능하고, 블록 밖의 범위에서 똑같은 이름을 가진 값이 있다고 해도 영향을 주지 않는다.
* 반면, var는 Function Scope로 선언이 되므로, if문 블록 내부에서 선언한 value 값이 블록 밖의 value에도 영향을 미치게 된다.

### Hoisting
* 자바스크립트에서 아직 선언되지 않은 함수/변수를 끌어올려서 사용할 수 있는 자바스크립트의 작동 방식을 의미한다.

```javascript
myFunction();

function myFunction() {
  console.log('hello world!');
}
```
* 위의 코드를 보면 myFunction함수를 선언하기 전에 호출했음에도 불구하고 코드는 정상적으로 작동한다.
* 잘 작동하는 이유는, 자바스크립트 엔진이 위 코드를 해석하는 과정에서 Hoisting하여 받아들이게 되기 때문이다.
* 변수 또한 Hoisting된다.

```javascript
console.log(number);
var number = 2;

// 결괏값
undefined
```
* 원래는 number이 정의되지 않았다는 에러메세지가 발생해야 하는데, 자바스크립트 엔진이 위 코드를 해석할 때 다음과 같이 받아들이게 되기 때문에 undefined가 출력된다.

```javascript
var number;
console.log(number);
number = 2;
```



* 반면, `const`와 `let`은 호이스팅은 되지만 변수 생성과정이 달라서 TDZ가 생성되어 초기화전에는 액세스할 수 없다는 에러가 발생하게 된다.
* Hoisting은 자바스크립트 엔진이 갖고 있는 성질이며, 방지하는 것이 좋다.
* Hoisting이 발생하는 코드는 이해하기 어렵고 유지보수도 힘들어지고 의도치 않는 결과물이 나타나기 쉽기 때문
	* 함수의 경우 꼭 선언 후에 호출을 하자.
	* `var` 대신 `const`, `let`을 위주로 사용하자

