---
title: "0104-0110"
tag: TIL
category: TIL
---
## 0104
# StringBuffer클래스와 StringBuilder클래스


*String클래스는 인스턴스를 생성할 때 지정된 문자열을 변경할 수 없지만 StringBuffer클래스는 변경이 가능*

### StringBuffer의 생성자
* StringBuffer클래스는 인스턴스를 생성할 때, 적절한 길이의 char형 배열이 생성되고, 이 배열은 문자열을 저장하고 편집하기 위한 공간(buffer)으로 사용된다.
* StringBuffer을 생성할 때는 문자열의 길이를 고려하여 충분히 여유있는 크기로 지정하는 것이 좋다.  
-> 편집 중인 문자열이 버퍼의 길이를 넘어서게 되면 버퍼의 길이를 늘려주는 작업이 추가로 수행되어야하기 때문에 작업효율이 떨어짐
* StringBuffer인스턴스를 생성할 때, 버퍼의 크기를 지정해주지 않으면 16개의 문자를 지정할 수 있는 크기의 버퍼를 생성
* StringBuffer인스턴스를 생성할 때, 문자열을 지정해주면 지정한 문자열의 길이보다 16이 더 크게 버퍼를 생성

### StringBuffer의 변경
```java
StringBuffer sb = new StringBuffer("abc");
StringBuffer sb2 = sb.append("123");
System.out.println(sb);		//abc123
System.out.println(sb2);	//abc123
```
* append()는 반환타입이 StringBuffer인데 자신의 주소를 반환한다. 그래서 sb에 새로운 문자열이 추가되고 sb자신의 주소를 반환하여 sb2에는 sb의 주소인 0x100이 저장된다.
* sb와 sb2가 모두 같은 인스턴스를 가리키고 있으므로 같은 내용이 출력된다. 그래서 연속적으로 append()를 호출하는 것이 가능하다.  
-> `sb.append("123").append("zz");`

### StringBuffer의 비교
* StringBuffer클래스는 equals메서드를 오버라이딩하지 않아서 등가비교연산자(==)로 비교한 것과 같은 결과를 얻는다.
* 반면에 toString()은 오버라이딩되어 있어서 toString()을 호출하면, 담고있는 문자열을 String으로 반환한다.
* 그래서 StringBuffer인스턴스에 담긴 문자열을 비교하기 위해서는 StringBuffer인스턴스에 toString()을 호출해서 String인스턴스를 얻은 다음, 여기에 equals메서드를 사용해서 비교해야한다.

### StringBuffer클래스의 생성자와 메서드
* `StringBuffer(), StringBuffer(int length), StringBuffer(String str)`  
-> 문자열을 매개변수로 지정하면 해당 문자열 값을 가진 StringBuffer인스턴스를 생성하고, 크기를 지정하거나 매개변수가 없으면 지정된 개수의 문자를 담을 수 있는 버퍼를 가진 StringBuffer인스턴스를 생성한다.
* `StringBuffer append(Anytype a)`  
-> 매개변수로 입력된 값을 문자열로 변환하여 StringBuffer인스턴스가 저장하고 있는 문자열의 뒤에 덧붙인다.
* `int capacity()`  
-> StringBuffer인스턴스의 버퍼크기를 알려준다. length()는 버퍼에 담긴 문자열의 크기를 알려준다.
* `char charAt(int index)`  
-> 지정된 위치에 있는 문자를 반환한다.
* `StringBuffer delete(int start, int end)`  
-> 시작위치부터 끝 위치 사이에 있는 문자를 제거한다. 단, 끝 위치 문자는 제외.
* `StringBuffer deleteCharAt(int index)`  
-> 지정된 위치의 문자를 제거한다.
* `StringBuffer insert(int pos, Anytype a)`  
-> 두 번째 매개변수로 받은 값을 문자열로 변환하여 지정된 위치에 추가한다.
* `StringBuffer replace(int start, int end, String str)`  
-> 지정된 범위에 있는 문자들을 주어진 문자열로 바꾼다.
* `StringBuffer reverse()`  
-> 저장되어 있는 문자열의 순서를 거꾸로 나열한다.
* `void setCharAt(int index, char ch)`  
-> 지정된 위치의 문자를 주어진 문자로 바꾼다.
* `void setLength(int newLength)`  
-> 지정된 길이로 문자열의 길이를 변경한다.
* `String toString()`  
-> StringBuffer인스턴스의 문자열을 String으로 반환
* `String subString(int start), String subString(int start, int end)`  
-> 지정된 범위 내의 문자열을 String으로 뽑아서 반환한다.

### StringBuilder란?
* StringBuffer는 멀티쓰레드에 안전하도록 동기화되어 있다.
* 멀티쓰레드로 작성된 프로그램이 아닌 경우, StringBuffer의 동기화는 불필요하게 성능만 떨어트리게 된다.
* 그래서 StringBuffer에서 쓰레드의 동기화만 뺀 StringBuilder가 새로 추가되었다.
* 동기화를 제외하고는 StringBuilder와 StringBuffer는 완전히 똑같은 기능으로 작성되어 있다.

## 0105
# java.util.Random클래스
* Math.random()외에도 Random클래스를 사용하면 난수를 얻을 수 있다.


```java
double randNum = Math.random();
double randNum = new Random().nextDouble();	// 위의 문장과 동일

int num = (int)(Math.random * 6) + 1;
int num = new Random().nextInt(6) + 1;	    // 위의 문장과 동일
```
* Math.random()과 Random의 가장 큰 차이점은 종자값(seed)을 설정할 수 있다는 것이다.
* 종자값이 같은 Random인스턴스들은 항상 같은 난수를 같은 순서대로 반환한다.

### Random클래스의 생성자와 메서드
* 생성자 Random()은 종자값을 System.currentTimeMillis()로 하기 때문에 실행할 때마다 얻는 난수가 달라진다.
* 주로 사용하는 메서드는 double nextDouble (), int nextInt (int n)이 있다.
* int nextInt (int n)는 0 ~ n의 범위에 있는 Int값을 반환한다. (n은 범위 포함 x)

**Math.random()을 이용해서 실제 프로그래밍에 유용할만한 메서드**
```java
int getRand(int from, int to) {
	return (int)(Math.random() * (Math.abs(to - from) + 1)) + Math.min(from, to);
}		// from과 to범위의 정수 값을 반환한다. from과 to 모두 범위에 포함한다.

int[] fillRand(int[] arr, int from, int to) {
	for(int i=0; i<arr.length; i++) {
		arr[i] = getRand(from, to);
	}
	return arr;
}		// 배열 arr을 from과 to범위의 값들로 채워서 반환한다.

int[] fillRand(int[] arr, int[] data) {
	for(int i=0; i<arr.length; i++) {
		arr[i] = data[getRand(0, data.length-1)];
	}
	return arr;
}		// 배열 arr을 배열 data에 있는 값들로 채워서 반환한다.
```

## 0106
# 날짜와 시간



## Calendar와 Date
### Calendar와 GregorianCalendar
*Canlendar는 추상클래스이기 때문에 직접 객체를 생성할 수 없고, 메서드를 통해서 완전히 구현된 클래스의 인스턴스를 얻어야 한다.*
```java
// getInstance() 메서드는 Calendar 클래스를 구현한 클래스의 인스턴스를 반환한다.
Calendar cal = Calendar.getInstance();
```
* getInstance()는 시스템의 국가와 지역설정을 확인해서 태국을 제외하고는 GregorianCalendar의 인스턴스를 반환한다.

### Date와 Calendar간의 변환
1. Calendar를 Date로 변환
```java
Calendar cal = Calendar.getInstance();
Date d = cal.getTime();
```
2. Date를 Calendar로 변환
```java
Date d = new Date();
Calendar cal = Calendar.getInstance();
cal.setTime(d);
```

* getInstance()를 통해서 얻은 인스턴스는 기본적으로 현재 시스템의 날짜와 시간에 대한 정보를 담고 있다.
* `int get(int field)`는 원하는 필드의 값을 얻어오는 Calendar의 메서드이다.
* `get(Calendar.MONTH)`로 얻어오는 값의 범위가 1에서 12가 아니라 0~11이라는 것을 주의해야 한다. 얻어오는 값이 0이면 1월을 의미한다.
* get메서드의 매개변수로 사용되는 Int값들은 Calendar에 정의된 static상수이다.
* 날짜와 시간을 원하는 값으로 변경하려면 set메서드를 사용하면 된다.
```java
void set(int field, int value)
void set(int field, int value, int date)
void set(int field, int value, int date, int hourOfDay, int minute)
void set(int field, int value, int date, int hourOfDay, int minute, int second)
```
* 두 날짜간의 차이를 구하기 위해서는 두 날짜를 최소단위인 초단위로 변경한 다음 그 차이를 구하면 된다.
	* 	getTimeInMillis()는 1/1000초 단위로 값을 반환하기 때문에 초단위로 얻기 위해서는 1000으로 나눠 주어야 한다.
	* 일단위로 얻기 위해서는 24*60*60*1000으로 나누어야 한다.
* `add(int field, int amount)`를 사용하면 지정한 필드의 값을 원하는 만큼 증가 또는 감소 시킬 수 있다.
	* 이를 이용해서 특정 날짜 또는 시간을 기점으로 해서 일정기간 전후의 날짜와 시간을 알아낼 수 있다.
	* 다음 달의 1일에서 하루를 빼면 이번 달의 마지막 일을 알 수 있다.
* `roll(int field, int amount)`도 지정한 필드의 값을 증가 또는 감소시킬 수 있는데, add 메서드와의 차이점은 다른 필드에 영향을 미치지 않는다는 것이다.