---
title: "0104-0110"
tag: TIL
category: TIL
---
## 0104
# StringBuffer클래스와 StringBuilder클래스


*String클래스는 인스턴스를 생성할 때 지정된 문자열을 변경할 수 없지만 StringBuffer클래스는 변경이 가능*

### StringBuffer의 생성자
* StringBuffer클래스는 인스턴스를 생성할 때, 적절한 길이의 char형 배열이 생성되고, 이 배열은 문자열을 저장하고 편집하기 위한 공간(buffer)으로 사용된다.
* StringBuffer을 생성할 때는 문자열의 길이를 고려하여 충분히 여유있는 크기로 지정하는 것이 좋다.  
-> 편집 중인 문자열이 버퍼의 길이를 넘어서게 되면 버퍼의 길이를 늘려주는 작업이 추가로 수행되어야하기 때문에 작업효율이 떨어짐
* StringBuffer인스턴스를 생성할 때, 버퍼의 크기를 지정해주지 않으면 16개의 문자를 지정할 수 있는 크기의 버퍼를 생성
* StringBuffer인스턴스를 생성할 때, 문자열을 지정해주면 지정한 문자열의 길이보다 16이 더 크게 버퍼를 생성

### StringBuffer의 변경
```java
StringBuffer sb = new StringBuffer("abc");
StringBuffer sb2 = sb.append("123");
System.out.println(sb);		//abc123
System.out.println(sb2);	//abc123
```
* append()는 반환타입이 StringBuffer인데 자신의 주소를 반환한다. 그래서 sb에 새로운 문자열이 추가되고 sb자신의 주소를 반환하여 sb2에는 sb의 주소인 0x100이 저장된다.
* sb와 sb2가 모두 같은 인스턴스를 가리키고 있으므로 같은 내용이 출력된다. 그래서 연속적으로 append()를 호출하는 것이 가능하다.  
-> `sb.append("123").append("zz");`

### StringBuffer의 비교
* StringBuffer클래스는 equals메서드를 오버라이딩하지 않아서 등가비교연산자(==)로 비교한 것과 같은 결과를 얻는다.
* 반면에 toString()은 오버라이딩되어 있어서 toString()을 호출하면, 담고있는 문자열을 String으로 반환한다.
* 그래서 StringBuffer인스턴스에 담긴 문자열을 비교하기 위해서는 StringBuffer인스턴스에 toString()을 호출해서 String인스턴스를 얻은 다음, 여기에 equals메서드를 사용해서 비교해야한다.

### StringBuffer클래스의 생성자와 메서드
* `StringBuffer(), StringBuffer(int length), StringBuffer(String str)`  
-> 문자열을 매개변수로 지정하면 해당 문자열 값을 가진 StringBuffer인스턴스를 생성하고, 크기를 지정하거나 매개변수가 없으면 지정된 개수의 문자를 담을 수 있는 버퍼를 가진 StringBuffer인스턴스를 생성한다.
* `StringBuffer append(Anytype a)`  
-> 매개변수로 입력된 값을 문자열로 변환하여 StringBuffer인스턴스가 저장하고 있는 문자열의 뒤에 덧붙인다.
* `int capacity()`  
-> StringBuffer인스턴스의 버퍼크기를 알려준다. length()는 버퍼에 담긴 문자열의 크기를 알려준다.
* `char charAt(int index)`  
-> 지정된 위치에 있는 문자를 반환한다.
* `StringBuffer delete(int start, int end)`  
-> 시작위치부터 끝 위치 사이에 있는 문자를 제거한다. 단, 끝 위치 문자는 제외.
* `StringBuffer deleteCharAt(int index)`  
-> 지정된 위치의 문자를 제거한다.
* `StringBuffer insert(int pos, Anytype a)`  
-> 두 번째 매개변수로 받은 값을 문자열로 변환하여 지정된 위치에 추가한다.
* `StringBuffer replace(int start, int end, String str)`  
-> 지정된 범위에 있는 문자들을 주어진 문자열로 바꾼다.
* `StringBuffer reverse()`  
-> 저장되어 있는 문자열의 순서를 거꾸로 나열한다.
* `void setCharAt(int index, char ch)`  
-> 지정된 위치의 문자를 주어진 문자로 바꾼다.
* `void setLength(int newLength)`  
-> 지정된 길이로 문자열의 길이를 변경한다.
* `String toString()`  
-> StringBuffer인스턴스의 문자열을 String으로 반환
* `String subString(int start), String subString(int start, int end)`  
-> 지정된 범위 내의 문자열을 String으로 뽑아서 반환한다.

### StringBuilder란?
* StringBuffer는 멀티쓰레드에 안전하도록 동기화되어 있다.
* 멀티쓰레드로 작성된 프로그램이 아닌 경우, StringBuffer의 동기화는 불필요하게 성능만 떨어트리게 된다.
* 그래서 StringBuffer에서 쓰레드의 동기화만 뺀 StringBuilder가 새로 추가되었다.
* 동기화를 제외하고는 StringBuilder와 StringBuffer는 완전히 똑같은 기능으로 작성되어 있다.

## 0105
# java.util.Random클래스
* Math.random()외에도 Random클래스를 사용하면 난수를 얻을 수 있다.


```java
double randNum = Math.random();
double randNum = new Random().nextDouble();	// 위의 문장과 동일

int num = (int)(Math.random * 6) + 1;
int num = new Random().nextInt(6) + 1;	    // 위의 문장과 동일
```
* Math.random()과 Random의 가장 큰 차이점은 종자값(seed)을 설정할 수 있다는 것이다.
* 종자값이 같은 Random인스턴스들은 항상 같은 난수를 같은 순서대로 반환한다.

### Random클래스의 생성자와 메서드
* 생성자 Random()은 종자값을 System.currentTimeMillis()로 하기 때문에 실행할 때마다 얻는 난수가 달라진다.
* 주로 사용하는 메서드는 double nextDouble (), int nextInt (int n)이 있다.
* int nextInt (int n)는 0 ~ n의 범위에 있는 Int값을 반환한다. (n은 범위 포함 x)

**Math.random()을 이용해서 실제 프로그래밍에 유용할만한 메서드**
```java
int getRand(int from, int to) {
	return (int)(Math.random() * (Math.abs(to - from) + 1)) + Math.min(from, to);
}		// from과 to범위의 정수 값을 반환한다. from과 to 모두 범위에 포함한다.

int[] fillRand(int[] arr, int from, int to) {
	for(int i=0; i<arr.length; i++) {
		arr[i] = getRand(from, to);
	}
	return arr;
}		// 배열 arr을 from과 to범위의 값들로 채워서 반환한다.

int[] fillRand(int[] arr, int[] data) {
	for(int i=0; i<arr.length; i++) {
		arr[i] = data[getRand(0, data.length-1)];
	}
	return arr;
}		// 배열 arr을 배열 data에 있는 값들로 채워서 반환한다.
```