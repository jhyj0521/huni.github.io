---
title: "0307 - 0313"
tag: TIL
category: TIL
excerpt: ""
---

## 0307

# 한꺼번에 객체 생성하기

객체를 생성할 때는 속성을 하나씩 추가하기보다는 여러 속성을 포함해서 한꺼번에 생성해야 타입 추론에 유리하다.  
변수를 선언할 때 초기값을 기준으로 변수 타입이 추론되기 때문에 존재하지 않는 속성을 추가할 수는 없다.  
이 문제는 객체를 한번에 정의하면 해결할 수 있다.  
객체를 반드시 제각각 나눠서 만들어야 한다면, 타입 단언문을 사용해 타입 체커를 통과하게 할 수 있다.

```typescript
const pt = {} as Point;
pt.x = 3;
pt.y = 4;
```

물론 이 경우도 선언할 때 한꺼번에 만드는 게 더 낫다.  
작은 객체들을 조합해서 큰 객체를 만들어야 하는 경우에도 여러 단계를 거치는 것은 좋지 않은 생각이다.

## 해결법

스프레드 연산자 `...`를 사용하면 큰 객체를 한꺼번에 만들어 낼 수 있다.  
스프레드 연산자를 사용하면 타입 걱정 없이 필드 단위로 객체를 생성할 수도 있다.  
이때 모든 업데이트마다 새 변수를 사용하여 각각 새로운 타입을 얻도록 하는 게 중요하다.

```typescript
const pt0 = {};
const pt1 = { ...pt0, x: 3 };
const pt: Point = { ...pt1, y: 4 };
```

이 방법은 간단한 객체를 만들기 위해 우회하기는 했지만, 객체에 속성을 추가하고 타입스크립트가 새로운 타입을 추론할 수 있게 해 유용하다.

타입에 안전한 방식으로 조건부 속성을 추가하려면 속성을 추가하지 않는 `null` 또는 `{}`으로 객체 전개를 사용하면 된다.

```typescript
declare let hasMiddle: boolean;
const firstLast = { first: "Harry", last: "Truman" };
const president = { ...firstLast, ...(hasMiddle ? { middle: "S" } : {}) };
```

전개 연산자로 한꺼번에 여러 속성을 추가할 수도 있다.

```typescript
declare let hasDates: boolean;
const nameTitle = { name: "Khufu", title: "Pharaoh" };
const pharaoh = {
  ...nameTitle,
  ...(hasDates ? { start: -2589, end: -2566 } : {}),
};
```

이 때 책에서는 마치 이에 대한 결과로 pharaoh의 타입이 유니온 타입으로 나오는 것처럼 설명되어 있는데, 실제로는 선택적 필드로 결과가 도출된다.  
아마도 유니온 타입으로 결과가 나올 경우 속성을 사용할 수 없다는 문제점이 발생해서 바뀐 것 같다.

책에서는 유니온 타입으로 결과가 나올 경우 선택적 필드 방식으로 표현할 수 있도록 지원하는 헬퍼 함수를 소개한다.

```typescript
function addOptional<T extends object, U extends object>(
  a: T,
  b: U | null
): T & Partial<U> {
  return { ...a, ...b };
}
```

# 일관성 있는 별칭 사용하기

```typescript
const borough = { name: "Brooklyn", location: [40.688, -73.979] };
const loc = borough.location;
```

- `borough.location` 배열에 loc이라는 별칭을 만들었다. 별칭의 값을 변경하면 원래 속성값에서도 변경된다.
- 별칭을 남발하면 제어 흐름을 분석하기 어렵다. 타입스크립트에서도 별칭을 신중하게 사용해야 코드를 잘 이해할 수 있고, 오류도 쉽게 찾을 수 있다.

```typescript
interface Coordinate {
  x: number;
  y: number;
}

interface BoundingBox {
  x: [number, number];
  y: [number, number];
}

interface Polygon {
  exterior?: Coordinate[];
  holes?: Coordinate[][];
  bbox?: BoundingBox;
}

const polygon: Polygon = {
  exterior: [],
  holes: [],
};

function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
  const box = polygon.bbox;
  if (polygon.bbox) {
    if (
      pt.x < box.x[0] ||
      pt.x > box.x[1] ||
      pt.y < box.y[0] ||
      pt.y > box.y[1]
    ) {
      return false;
    }
  }
}
```

- 이 코드는 `polygon.bbox`를 여러 부분에서 반복해서 사용하는데, 이를 변수로 뽑아내서 사용하는 것이다.
- 위 코드에서는 오류가 발생하는데, box 가 undefined일 수 있다는 것이다.
- 그 이유는 기본적으로 `polygon.bbox`는 BoundingBox 타입이거나 undefined로 추론되는데, 속성 체크는 `polygon.bbox`의 타입을 정제했지만 box는 그렇지 않았기 때문이다.
- 별칭을 일관성 있게 사용한다는 기본 원칙을 지키면 이를 방지할 수 있다.
- 객체 비구조화 할당을 이용하면 보다 간결한 문법으로 일관된 이름을 사용할 수 있다.

## 객체 비구조화 할당 사용 시 주의점

- bbox 속성이 아니라 x와 y가 선택적 속성일 경우에는 속성 체크가 더 필요하다. 따라서 타입 경계에 null 값을 추가하는 것이 좋다.
- bbox에는 객체이므로 선택적 속성이 적합했지만 holes는 배열이기에 그렇지 않다. holes가 선택적이었다면, 값이 없거나 빈 배열이었을 것인데 값을 없게 하는 것보다 빈 배열로 두는 것이 값이 없음을 나타내기에 더 좋은 방법이다.
- 함수 호출은 객체 속성의 타입 정제를 무효화할 수 있다는 점을 주의해야 한다. 속성보다 지역 변수를 사용하면 타입 정제를 믿을 수 있다.

# 비동기 코드에는 콜백 대신 async 함수 사용하기

콜백보다는 프로미스가 코드를 작성하기 쉽고, 타입을 추론하기 쉽기에 프로미스나 async/await를 사용해야 한다.  
예를 들어, 병렬로 페이지를 로드하고 싶다면 Promise.all을 사용해서 프로미스를 조합하면 된다.

```typescript
async function fetchPages() {
  const [response1, response2, response3] = await Promise.all([
    fetch(url1),
    fetch(url2),
    fetch(url3),
  ]);
}
```

- 이런 경우 await와 구조 분해 할당이 잘 어울린다.
- 타입스크립트는 response 변수 각각의 타입을 Response로 추론한다.
- 콜백 스타일로 동일한 코드를 작성하려면 더 많은 코드와 타입 구문이 필요하다.

프로미스를 직접 생성해야 할 때, 선택의 여지가 있다면 일반적으로 프로미스를 생성하기보다는 async/await를 사용해야 한다.

- 일반적으로 더 간결하고 직관적인 코드가 된다.
- async 함수는 항상 프로미스를 반환하도록 강제된다.
- 함수는 항상 동기 또는 비동기로 실행되어야 하며 절대 혼용해서는 안 된다.
  - async를 사용하면 항상 비동기 코드를 작성하는 셈이 되어 일관적인 동작을 강제하게 된다.
