---
title: "1221-1227"
tag: TIL
category: TIL
---
## 1221
### 다형성이란?


**객체지향**에서는 '여러 가지 형태를 가질 수 있는 능력'  
**자바**에서는 조상클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조할 수 있도록 함  


ex) Tv와 CaptionTv클래스가 서로 상속 관계일 때,   
 `Tv t = new CationTv();`
* 	실제 인스턴스가 CaptionTv 타입이라 할지라도, 참조 변수 t로는 CaptionTv 인스턴스의 모든 멤버를 사용할 수 없다.
* Tv타입의 참조변수로는 CaptionTv 인스턴스 중에서 Tv 클래스의 멤버들만 사용할 수 있다.
* **같은 타입의 인스턴스라도 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라진다.**

*반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조하는 것은 가능할까?*  
`CaptionTv c = new Tv();   //컴파일 에러`
* 실제 인스턴스인 Tv의 멤버 개수보다 참조변수 c가 사용할 수 있는 멤버 개수가 더 많기 때문
* 자손타입의 참조변수로 조상타입의  인스턴스를 참조하는 것은 존재하지 않는 멤버를 사용하고자 할 가능성이 있으므로 허용하지 않음
* **참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 같거나 적어야 한다.**

>**조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다**  
>**반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없다**

## 1222
# 인터넷 네트워크
http메서드를 학습하기 전에 기본적으로 짚고 넘어가야 할 인터넷 네트워크에 대한 지식들을 정리해보았다.

 
## 인터넷 통신          
*인터넷에서 컴퓨터 둘은 어떻게 통신할까?*  
* 클라이언트와 서버가 통신하기 위해 여러 노드를 타고 데이터가 이동한다.
* 그러기 위한 가장 기본적인 통신 규약이 IP이다.



## IP(인터넷 프로토콜)
* 클라이언트와 서버가 통신하기 위해서는 기본적으로 IP주소가 있어야 한다.
Ex) 100.100.100.1

### IP 역할
1. 지정한 IP 주소(IP Address)에 데이터 전달
2. 패킷(Packet)이라는 통신 단위로 데이터 전달

### IP 패킷 정보
출발지 IP,  목적지 IP, 기타...

### IP프로토콜의 한계
1. 비연결성  
-> 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송
2. 비신뢰성  
-> 중간에 패킷이 사라지거나, 순서대로 오지 않는 것을 보장하지 않음
3. 프로그램 구분    
-> 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상이면 구분하지 못함


## TCP  UDP
### 인터넷 프로토콜 스택의 4계층
* 애플리케이션 계층 - HTTP, FTP
* 전송 계층 - TCP, UDP
* 인터넷 계층 - IP
* 네트워크 인터페이스 계층

### TCP/IP 패킷 정보
* TCP - 출발지 PORT, 목적지 PORT, 전송 제어, 순서, 검증 정보...
* IP -  출발지 IP, 목적지 IP, 기타...   
    * **이러한 정보들을 가지고 IP프로토콜에서의 문제들을 해결한다**

### TCP 특징
전송 제어 프로토콜(Transmission Control Protocal)
1. 연결 지향 - TCP 3 way handshake (가상연결)
2. 데이터 전달 보증
3. 순서 보장  
-> 신뢰할 수 있는 프로토콜

### TCP 3 way handshake
1. 클라이언트 -> 서버 - SYN
2. 서버 -> 클라이언트 - SYN+ACK
3. 클라이언트 -> 서버 - ACK
4. 데이터 전송  
**물리적으로 연결이 된 것이 아니라, 논리적으로 연결이 된 것이다.**


*SYN: 접속 요청*  
*ACK: 요청 수락*   
*3.에서 ACK와 함께 데이터 전송 가능*  

### UDP 특징
사용자 데이터그램 프로토콜(User Datagram Protocol)
* 기능이 거의 없음
* 연결 지향, 데이터 전달 보증, 순서 보장 모두 X
* 데이터 전달 및 순서가 보장되지 않지만, 단순하고 빠름
* IP와 거의 같다. + PORT + 체크섬(메시지에 대해 제대로 받는지 검증) 정도만 추가
* 애플리케이션에서 추가 작업 필요


## PORT
*서버 안에서 돌아가는 애플리케이션을 찾는 것*  


**같은 IP 내에서 프로세스를 구분**  
ex) 한 컴퓨터에서 게임, 화상통화, 웹 브라우저를 동시에 사용할 때 각각 포트번호를 다르게 해서 통신이 원활하게 한다.
* 0 ~ 65535 할당 가능
* 0 ~ 1023은 잘 알려진 포트, 사용하지 않는 것이 좋음

## DNS
### IP주소의 문제점
1. IP 주소는 기억하기 어렵다.
2. IP 주소는 변경될 수 있다.

### DNS
도메인 네임 시스템(Domain Name System)
* 도메인 명을 IP 주소로 변환  
-> 전화번호부와 같은 역할

### DNS 사용
1. 도메인 명을 url에 작성한다.
2. DNS 서버에서 도메인 명을 IP 주소로 변환하여 응답해준다.
3. 받은 IP 주소로 서버에 접속한다.  


**-> 2가지 문제점을 동시에 해결**

## 1223
# URI와 웹 브라우저 요청 흐름
## URI(Uniform Resource Identifier)
> URI는 로케이터(locator), 이름(name) 또는 둘 다 추가로 분류될 수 있다.

### URI 단어 뜻
* Uniform : 리소스 식별하는 통일된 방식
* Resource : 자원, URI로 식별할 수 있는 모든 것(제한 없음)
* Identifier : 다른 항목과 구분하는데 필요한 정보

### URL, URN
* URL - Locator : 리소스가 있는 위치를 지정
* URN - Name : 리소스에 이름을 부여
* 위치는 변할 수 있지만 이름은 변하지 않는다.
* URN 이름만으로 실제 리소스를 찾을 수 있는 방법이 보편화 되지 않음

### URL 전체 문법
>schemme://[userinfo@]host[:port][/path][?query][# fragment]  
>ex) https://www.google.com:443/search?q=hello&hl=ko
* 프로토콜
* 호스트명
* 포트 번호
* 패스
* 쿼리 파라미터

#### scheme
* 주로 프로토콜 사용
* 프로토콜 : 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙
* http는 80포트, https는 443 포트를 주로 사용, 포트는 생략 가능

#### userinfo
* URL에 사용자정보를 포함해서 인증
* 거의 사용하지 않음

#### host
* 호스트명
* 도메인명 또는 IP 주소를 직접 사용 가능

#### PORT
* 접속 포트
* 일반적으로 생략, 생략시 http는 80, https는 443

#### path
* 리소스 경로, 계층적 구조

#### query
* key=value 형태
* ?로 시작, &로 추가 가능
* query parameter, query string 등으로 불림, 웹서버에 제공하는 파라미터

#### fragment
* html 내부 북마크 등에 사용
* 서버에 전송하는 정보 아님


## 웹 브라우저 요청 흐름
1. resource 요청 시, 웹 브라우저가 HTTP 메시지 생성
2. SOCKET 라이브러리를 통해 TCP/IP로 3way handshake를 실행해 서버와 연결한다.
3. 운영체제 TCP/IP 계층으로 데이터 전송을 하기 위해 데이터를 전달한다.
4. HTTP 메시지가 포함된 TCP/IP 패킷을 생성한다.
5. 패킷 정보가 인터넷으로 흘러간다.
6. 서버에 요청  패킷이 도착하여 패킷 껍데기는 버리고 HTTP 메시지를 서버가 해석한다.
7. HTTP 응답 메시지를 마찬가지 방식으로 패킷을 생성하여 응답 패킷을 전달한다.
8. 수 많은 노드들을 통해서 응답 패킷이 도착하게 되면 웹 브라우저가 HTML 렌더링하여 화면에 보여준다.

## 1224
# 참조변수의 형변환
* 서로 상속관계에 있는 클래스사이에서는 참조변수도 형변환이 가능하다.
* 자손타입의 참조변수를 조상타입의 참조변수로, 조상타입의 참조변수를 자손타입의 참조변수로의 형변환만 가능  


**자손타입 -> 조상타입(Up-casting) : 형변환 생략가능**  
**조상타입 -> 자손타입(Down-casting) : 형변환 생략불가**  
* 자손타입의 참조변수를 조상타입의 참조변수로 형변환 하는 것은 참조변수가 다룰 수 있는 멤버의 개수가 실제 인스턴스가 갖고 있는 멤버의 개수보다 적을 것이 분명하므로 문제가 되지 않는다. 그래서 형변환을 생략할 수 있다.
* 형변환은 참조변수의 타입을 변환하는 것이지 인스턴스를 변환하는 것은 아니기 때문에 참조변수의 형변환은 인스턴스에 아무런 영향을 미치지 않는다.
단지 참조변수의 형변환을 통해서, 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위(개수)를 조절하는 것 뿐이다.

```java
public class CastingTest {
    public static void main(String[] args) {
        Car car = new Car();
        Car car2 = null;
        FireEngine fe = null;

        car.drive();
        fe = (FireEngine) car;		//컴파일은 OK. 실행 시 에러가 발생
        fe.drive();
	car2 = fe;
	car2.drive();
    }
}
```
* 참조변수 car가 참조하고 있는 인스턴스가 Car타입의 인스턴스이기 때문에 조상 타입의 인스턴스를 자손타입의 참조변수로 참조하는 것은 허용되지 않는다.
* 컴파일 시에는 참조변수간의 타입만 체크하기 때문에 실행 시 생성될 인스턴스의 타입에 대해서는 전혀 알지 못한다.
* 서로 상속관계에 있는 타입간의 형변환은 양방향으로 자유롭게 수행될 수 있으나, 참조변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용되지 않는다.
* 그래서 **참조변수가 가리키는 인스턴스의 타입이 무엇인지 확인하는 것**은 중요하다.

### instance 연산자
* 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 instanceof 연산자를 사용한다.
* 왼쪽에는 참조변수를 오른쪽에는 타입(클래스명)이 피연산자로 위치한다.
* 실제 인스턴스와 같은 타입의 instanceof연산 이외에 조상타입의 instanceof연산에도 true를 결과로 얻는다.
* **어떤 타입에 대한 instanceof연산의 결과가 true라는 것은 검사한 타입으로 형변환이 가능하다는 것을 뜻한다**