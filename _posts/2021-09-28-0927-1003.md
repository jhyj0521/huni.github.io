---
title: "0927-1003"
tag: TIL
category: TIL
---

## 0927

# 56일 차

## 1교시

### deep copy를 언제 사용해야할까?

매개변수로 참조를 받아서 부수효과를 발생시키고 싶지 않을 때 새로운 값을 생성해서 반환

### JSON

http 통신에서 모든 데이터는 아스키 코드로 보내고 받아야한다.
객체처럼 생긴 JSON이라는 문자열 포맷을 http 아스키코드로 보낸다.
-> 서버 통신할 때 사용

### 자바스크립트에서의 객체 지향형

자바스크립트에서 객체지향은 문제가 있다.  
ex) 메서드내에서 this는 동적으로 바인딩되어 의도치 않게 동작 가능하다.

함수형에서는 메서드를 최대한 작성하지 않고, 함수로 프로퍼티를 참조한다.  
-> 이렇게 되면 응집도가 떨어지게 되는데, 이를 극복하기 위해 모듈을 클래스처럼 사용한다.

## 2교시

클로저를 만들 때는 외부함수를 즉시실행함수로 만들어야 한다.  
-> 하나의 렉시컬 환경을 여러 개의 클로저가 공유하기 위해서

정보 은닉과 결합도는 연관을 가지고 있다.
정보 은닉은 꼭 필요한 애들만 알려주겠다 라는 뜻

모듈 패턴을 사용하는 이유?  
-> 응집도를 높이기 위해서

## 3교시

클래스는 기본적으로 선언문으로 작성하는 것이 일반적

접근자 프로퍼티는 객체 리터럴과 클래스에서 사용 가능. 생성자 함수에서는 사용이 불가능하다.

생성자 함수를 쓰느니 클래스를 쓰는 것이 낫다.  
-> 자료구조를 만들 때만 사용

## 4교시

자바스크립트 배열은 배열이 아니다.  
자료구조에서 말하는 배열은 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료 구조이다.  
배열을 만들 때 배열처럼 만들어야 최적화가 잘 된다.  
-> 빈틈없이 동일한 데이터 타입으로

## 5교시

원본 배열을 직접 변경하는 메서드를 mutator 메서드, 원본 배열을 직접 변경하지 않고 새로운 배열을 생성하는 메서드를 accessor 메서드라고 한다.  
-> accessor 메서드 위주로 사용하자

## 0928

# 57일 차

## 깃 수업

### 프론트엔드-2기 전반적인 피드백

1. 제목만 존재하는 커밋
   -> 짧더라도 커밋단위에 대한 설명을
2. 제목이 불친절한 커밋
   -> 클릭을 안해도 어떤 내용인지 알 수 있는 충분한 요약설명
3. 큰 커밋단위
   -> 수업내용의 경우 수업 진행단위 별로 잘라 커밋
4. 브랜치에 대한 적극적 활용에 대한 아쉬움
   -> 수업 모듈별로 브랜치 나누어 작성한 뒤, 해당 브랜치 push까지

- resolved, closed, fixed
  -> 커밋할 때 적어주면 이 커밋이 이슈를 해결했다고 알려준다.
- 릴리즈 시, 태그 커밋이 릴리즈 노트가 되는 부분이므로 잘 작성해야 한다.

## 이분탐색

이분탐색 알고리즘 학습을 하면서 주어졌던 문제를 다시 풀어보고, 잊어버렸던 개념들을 다시 머리속에 넣었다.  
우선 이분탐색 알고리즘은 lt와 rt의 인덱스를 설정하고, while문 내부에서 lt 가 rt보다 작거나 같을 때까지 반복하여 lt와 rt의 중간값을 구한다.  
그리고 필요에 따라 lt와 rt의 값을 조절해가며 원하는 값을 얻는 알고리즘이다. 알고리즘 자체는 쉽지만, 원하는 값을 얻는 로직을 짜기 위해서 아이디어가 필요하다는 생각이 들었다.

## 프로그래머스 Level3 - 입국심사

```javascript
function solution(n, times) {
  let answer = 0;
  lt = 0;
  rt = n * times[times.length - 1];

  function count(t) {
    let cnt = 0;
    for (let x of times) {
      cnt += Math.floor(t / x);
    }
    return cnt;
  }

  while (lt <= rt) {
    let mid = parseInt((lt + rt) / 2);
    if (count(mid) >= n) {
      rt = mid - 1;
      answer = mid;
    } else {
      lt = mid + 1;
    }
  }

  return answer;
}
```

- mid로 값을 구하는 함수를 작성하는데 좀 더 문제를 잘 이해하고 시도해야겠다는 생각이 들었다. 문제를 잘못 파악하여 삽질하는 시간이 꽤나 길어져버렸다.
- 이 문제에서 실수했던 요인중 하나가 rt 값을 충분하게 잡았다고 생각하고 문제를 풀었는데, 생각보다 더 큰 rt의 값이 필요했다. 이 문제 때문에 테스트케이스 절반밖에 맞지 못했고, rt의 값을 좀 더 고민해서 잡아야겠다고 생각했다.

## 프로그래머스 Level2 - 큰 수 만들기

```javascript
function solution(number, k) {
  let answer = "";
  let arr = [];
  let cnt = 0;

  for (let i = 0; i < number.length; i++) {
    while (arr.length && arr[arr.length - 1] < number[i] && cnt < k) {
      arr.pop();
      cnt++;
    }
    if (arr.length < number.length - k) arr.push(number[i]);
  }
  answer = arr.join("");
  return answer;
}
```

- 아이디어를 생각해내기가 쉽지 않은 문제였다.
- 순서를 고정한 채로 가장 큰 수를 만들어내야 하므로, 새로 들어오는 값보다 기존 값이 작으면서 배열이 비어있지 않고 뺀 개수가 k보다 작다면 값을 뺐다. 그 외에는 push
- 그리고나서도 tc 하나에 걸렸는데, 이는 그외의 경우에 모두 push 해주므로 발생한 문제이다. 배열의 길이가 목표 값만큼 찼다면 더이상 push 하지 말아야 한다.
