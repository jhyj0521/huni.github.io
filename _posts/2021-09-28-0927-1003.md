---
title: "0927-1003"
tag: TIL
category: TIL
---

## 0927

# 56일 차

## 1교시

### deep copy를 언제 사용해야할까?

매개변수로 참조를 받아서 부수효과를 발생시키고 싶지 않을 때 새로운 값을 생성해서 반환

### JSON

http 통신에서 모든 데이터는 아스키 코드로 보내고 받아야한다.
객체처럼 생긴 JSON이라는 문자열 포맷을 http 아스키코드로 보낸다.
-> 서버 통신할 때 사용

### 자바스크립트에서의 객체 지향형

자바스크립트에서 객체지향은 문제가 있다.  
ex) 메서드내에서 this는 동적으로 바인딩되어 의도치 않게 동작 가능하다.

함수형에서는 메서드를 최대한 작성하지 않고, 함수로 프로퍼티를 참조한다.  
-> 이렇게 되면 응집도가 떨어지게 되는데, 이를 극복하기 위해 모듈을 클래스처럼 사용한다.

## 2교시

클로저를 만들 때는 외부함수를 즉시실행함수로 만들어야 한다.  
-> 하나의 렉시컬 환경을 여러 개의 클로저가 공유하기 위해서

정보 은닉과 결합도는 연관을 가지고 있다.
정보 은닉은 꼭 필요한 애들만 알려주겠다 라는 뜻

모듈 패턴을 사용하는 이유?  
-> 응집도를 높이기 위해서

## 3교시

클래스는 기본적으로 선언문으로 작성하는 것이 일반적

접근자 프로퍼티는 객체 리터럴과 클래스에서 사용 가능. 생성자 함수에서는 사용이 불가능하다.

생성자 함수를 쓰느니 클래스를 쓰는 것이 낫다.  
-> 자료구조를 만들 때만 사용

## 4교시

자바스크립트 배열은 배열이 아니다.  
자료구조에서 말하는 배열은 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료 구조이다.  
배열을 만들 때 배열처럼 만들어야 최적화가 잘 된다.  
-> 빈틈없이 동일한 데이터 타입으로

## 5교시

원본 배열을 직접 변경하는 메서드를 mutator 메서드, 원본 배열을 직접 변경하지 않고 새로운 배열을 생성하는 메서드를 accessor 메서드라고 한다.  
-> accessor 메서드 위주로 사용하자

## 0928

# 57일 차

## 깃 수업

### 프론트엔드-2기 전반적인 피드백

1. 제목만 존재하는 커밋
   -> 짧더라도 커밋단위에 대한 설명을
2. 제목이 불친절한 커밋
   -> 클릭을 안해도 어떤 내용인지 알 수 있는 충분한 요약설명
3. 큰 커밋단위
   -> 수업내용의 경우 수업 진행단위 별로 잘라 커밋
4. 브랜치에 대한 적극적 활용에 대한 아쉬움
   -> 수업 모듈별로 브랜치 나누어 작성한 뒤, 해당 브랜치 push까지

- resolved, closed, fixed
  -> 커밋할 때 적어주면 이 커밋이 이슈를 해결했다고 알려준다.
- 릴리즈 시, 태그 커밋이 릴리즈 노트가 되는 부분이므로 잘 작성해야 한다.

## 이분탐색

이분탐색 알고리즘 학습을 하면서 주어졌던 문제를 다시 풀어보고, 잊어버렸던 개념들을 다시 머리속에 넣었다.  
우선 이분탐색 알고리즘은 lt와 rt의 인덱스를 설정하고, while문 내부에서 lt 가 rt보다 작거나 같을 때까지 반복하여 lt와 rt의 중간값을 구한다.  
그리고 필요에 따라 lt와 rt의 값을 조절해가며 원하는 값을 얻는 알고리즘이다. 알고리즘 자체는 쉽지만, 원하는 값을 얻는 로직을 짜기 위해서 아이디어가 필요하다는 생각이 들었다.

## 프로그래머스 Level3 - 입국심사

```javascript
function solution(n, times) {
  let answer = 0;
  lt = 0;
  rt = n * times[times.length - 1];

  function count(t) {
    let cnt = 0;
    for (let x of times) {
      cnt += Math.floor(t / x);
    }
    return cnt;
  }

  while (lt <= rt) {
    let mid = parseInt((lt + rt) / 2);
    if (count(mid) >= n) {
      rt = mid - 1;
      answer = mid;
    } else {
      lt = mid + 1;
    }
  }

  return answer;
}
```

- mid로 값을 구하는 함수를 작성하는데 좀 더 문제를 잘 이해하고 시도해야겠다는 생각이 들었다. 문제를 잘못 파악하여 삽질하는 시간이 꽤나 길어져버렸다.
- 이 문제에서 실수했던 요인중 하나가 rt 값을 충분하게 잡았다고 생각하고 문제를 풀었는데, 생각보다 더 큰 rt의 값이 필요했다. 이 문제 때문에 테스트케이스 절반밖에 맞지 못했고, rt의 값을 좀 더 고민해서 잡아야겠다고 생각했다.

## 프로그래머스 Level2 - 큰 수 만들기

```javascript
function solution(number, k) {
  let answer = "";
  let arr = [];
  let cnt = 0;

  for (let i = 0; i < number.length; i++) {
    while (arr.length && arr[arr.length - 1] < number[i] && cnt < k) {
      arr.pop();
      cnt++;
    }
    if (arr.length < number.length - k) arr.push(number[i]);
  }
  answer = arr.join("");
  return answer;
}
```

- 아이디어를 생각해내기가 쉽지 않은 문제였다.
- 순서를 고정한 채로 가장 큰 수를 만들어내야 하므로, 새로 들어오는 값보다 기존 값이 작으면서 배열이 비어있지 않고 뺀 개수가 k보다 작다면 값을 뺐다. 그 외에는 push
- 그리고나서도 tc 하나에 걸렸는데, 이는 그외의 경우에 모두 push 해주므로 발생한 문제이다. 배열의 길이가 목표 값만큼 찼다면 더이상 push 하지 말아야 한다.

## 0929

# 58일 차

## 투포인터

조금 까다롭고 쉽지 않다고 생각되는 유형의 투포인터 문제가 있어서 정리하고자 한다.

## 연속 부분수열 3

N개의 수로 이루어진 수열이 주어집니다.
이 수열에서 연속부분수열의 합이 특정숫자 M이하가 되는 경우가 몇 번 있는지 구하는 프로그램을 작성하세요.
만약 N=5, M=5이고 수열이 다음과 같다면
13123
합이 5이하가 되는 연속부분수열은 {1}, {3}, {1}, {2}, {3}, {1, 3}, {3, 1}, {1, 2}, {2, 3}, {1, 3, 1}로 총 10가지입니다.

```javascript
function solution(nums, m) {
  let answer = 0;
  let lt = 0;
  let sum = 0;

  for (let rt = 0; rt < nums.length; rt++) {
    sum += nums[rt];

    while (sum > m) {
      sum -= nums[lt++];
    }

    answer += rt - lt + 1;
  }

  return answer;
}
```

- 예전에 풀었던 문제지만, 오랜만에 다시 풀어보니 전혀 감이 잡히지 않아서 다음에 풀었을 때는 막히지 않기 위해 한 번 더 정리한다.
- 이 문제의 핵심 개념은 일단 rt에서는 무조건 어떤 일을 수행하고, 조건에 어긋났을 때 while 문으로 문제가 해결될 때까지 lt를 조정하는 것이다.
- 그 상태로 answer에 필요한 작업을 진행한다. (조건이 완성된 채)

이 문제와 비슷한 식의 방법을 적용하는 문제를 마주쳤다.

## 최대 길이 연속부분수열

0과 1로 구성된 길이가 N인 수열이 주어집니다. 여러분은 이 수열에서 최대 k번을 0을 1로 변경할 수 있습니다. 여러분이 최대 k번의 변경을 통해 이 수열에서 1로만 구성된 최대 길이의 연속부분수열을 찾는 프로그램을 작성하세요.
만약 길이가 14인 다음과 같은 수열이 주어지고 k=2라면
11001101101101
여러분이 만들 수 있는 1이 연속된 최대 길이의 연속부분수열은 1 1 0 0 1 1 1 1 1 1 1 1 0 1 이며 그 길이는 8입니다.

```javascript
function solution(nums, k) {
  let answer = 0;
  let lt = 0;
  let cnt = 0;

  for (let rt = 0; rt < nums.length; rt++) {
    if (nums[rt] === 0) cnt++;

    while (cnt > k) {
      if (nums[lt] === 0) cnt--;
      lt++;
    }

    answer = Math.max(answer, rt - lt + 1);
  }

  return answer;
}
```

- 위의 문제와 비슷한 방법으로 우선 rt에서는 0일 때 바꾼 횟수를 증가시키고, lt에서는 cnt가 필요 이상 증가하면 줄여준다.
- 그리고 rt와 lt를 이용해 정답을 도출한다.
- **연속부분수열** 관련 문제에서는 투포인터 알고리즘을 가장 먼저 떠올려야겠다.

## 0930

# 59일 차

## 위클리 문제 1번

```javascript
function solution(nums, k) {
  let answer = 0;
  let sum = 0;
  let nH = new Map();

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] % 2 === 1) sum++;
    if (sum === k) answer++;

    if (nH.has(sum - k)) answer += nH.get(sum - k);

    nH.set(sum, nH.get(sum) + 1 || 1);
  }

  return answer;
}

console.log(solution([1, 2, 1, 1, 2], 2));
console.log(solution([2, 2, 2, 1, 2, 2, 1, 2, 2, 2], 2));
console.log(solution([2, 4, 6], 1));
```

- 연속 부분수열 문제
- 투포인터 알고리즘을 떠올리고 문제를 해결해보려고 했으나 생각처럼 잘 되지 않는 부분이 있었다.
- 어디까지의 연속 부분 수열 내에서 특정 값이 되는 경우에는 이런 방식을 적용해서 문제를 해결해야겠다.

## 위클리 문제 2번

```javascript
function solution(s, e) {
  let answer = 0;

  function BFS() {
    const queue = new Set();
    queue.add(s);

    let L = 0;
    while (queue.size) {
      e += L + 1;
      L++;
      if (queue.has(e)) return L;

      for (let v of [...queue]) {
        for (let nx of [v + 1, v - 1, v * 2]) {
          if (nx === e) {
            return nx > 500000 ? -1 : L;
          }

          if (nx <= 500000 && nx > 0) {
            queue.add(nx);
          }
        }
      }
    }
    return -1;
  }
  answer = BFS();

  return answer;
}
console.log(solution(5, 6));
console.log(solution(10, 3));
console.log(solution(1, 11));
```

- 시험을 볼 때 테스트케이스를 모두 통과했지만 풀이가 완벽하지는 않았다는 사실을 깨달았다.
- bfs에서 체크 배열을 사용하지 않으면서 중복을 피하고 싶은 경우 set을 활용해 문제를 해결할 수 있다.
