---
title: "1206-1212"
tag: TIL
category: TIL
---

## 1206

# 리액트 수업 5일 차

## Web App 개발에 적합하지 않은 웹 환경

- 클라이언트 요청에 의해 서버로부터 응답 받은 HTML 파일을 해석하는 과정에서 React 앱을 구성하는 수많은 모듈 파일들을 다시 서버에 호출, 응답, 런타임 중 해석하는 프로세스는 효율적이지 않다.

### 적합하지 않은 이유

1. 브라우저 호환성 문제. 브라우저 환경에서 정식으로 모듈을 사용할 수 있게 되었지만, 모든 브라우저에서 사용할 수 있는 것은 아니다.
2. 앱을 빌드하는 환경이 기본적으로 제공되지 않는다.

### 모듈 번들링

- 앱에 많은 기능이 필요해질수록 모듈 종속성의 올바른 순서를 추적하고 로드하는 번거로움이 더 커지게 된다.
  - 복잡성이 증가함에 따라 코드베이스의 기능이 혼란스럽게 뒤섞이고 흩어지는 결과가 발생해 개발이 어려워지는 문제가 발생한다.
  - 문제 해결을 위해 코드베이스를 모듈로 분할 관리하고, 묶어줘야 한다.

### 트리 쉐이킹

- 사용되지 않은 코드 조각은 번들 크기를 불필요하게 키우므로 번들 과정에서 제거해야 한다.
- 트리 쉐이킹은 최종 번들에서 사용하지 않을 코드를 제거하여 JS 번들 크기를 줄이고 앱의 실행 속도를 향상시킨다.

### 코드 스플리팅

- 앱이 커지면 덩달아 번들 또한 커진다. 특히 크기가 큰 3rd-party 라이브러리를 추가할 때 실수로 앱이 커져서 로드 시간이 길어질 수 있다. 번들이 거대해지는 것을 방지하기 위한 좋은 해결 방법 중 하나는 번들을 나누는 것이다.
- 코드 분할은 런타임 중 나뉘어진 번들을 동적으로 불러오는 것을 말한다.

### 코드 최적화, 소스맵

- 수 많은 모듈을 번들하는 동안 수행해야 하는 코드 최적화도 필요하다. 코드 최적화를 위해 주석, 공백 또는 긴 변수, 함수 일므 등을 모두 축소 또는 제거하여 파일의 크기를 크게 줄일 수 있다.
- 이 코드는 압축되었기에 사람이 읽기 매우 어렵고, 디버깅도 쉽지 않아 코드를 추적 가능한 소스맵이 필요하다.
- 소스맵은 디코더처럼 작동하며 축소된 코드를 구문 분석한다. 소스맵에는 원본 파일의 행에 대한 참조도 포함되어 있어 버그를 추적하기 용이하게 한다.

## React 프로젝트 구성 - 자동편

```bash
npx create-react-app 프로젝트이름 --template 템플릿이름
```

- create-react-app을 설치하지 않고 패키지를 실행해서 프로젝트를 생성하고 (소문자로 -이나 \_로 공백없이 프로젝트명 작성) 템플릿은 일종의 프리셋이라고 보면 된다.
- 템플릿을 기반으로 프로젝트를 구성한다. 예를 들어 typescript를 사용한다면 cra-template-typescript를 사용할 수 있다.
- 기본으로 진행한다면 템플릿 없이 진행해도 된다. cra-template이 기본 템플릿

가장 큰 번들 파일을 메인 번들, 작은 조각의 덩어리들을 청크라고 한다.

## React 프로젝트 구성 - 개발 환경 메뉴얼 구성

### Initialization Git & NPM

```json
{
  "private": true,
  "name": "config-manual-react-dev-env",
  "version": "1.0.0",
  "description": "React 앱 개발 환경 메뉴얼 구성",
  "main": "index.js",
  "scripts": {
    "start": "",
    "serve": "",
    "bundle": "",
    "watch": "",
    "build": "",
    "clear": ""
  },
  "keywords": ["react", "webpack", "babel", "sass", "postcss"],
  "author": "",
  "license": "ISC"
}
```

### Basic Setup

`npm i -D webpack webpack-cli webpack-dev-server `

- 웹팩 설정에 기본적으로 필요한 두 패키지와 dev-server를 설치한다.
- 웹팩 하는 일 자체는 번들밖에 못하기에, 필요한 것들을 더 구성해줘야 한다.

### .gitignore 생성

```txt
node_modules
coverage
build
dist

.env
.vscode
# Mac
.DS_Store
```

src는 엔트리 파일, dist는 출력 파일로 생성. dist에 index.html 파일 생성.

### webpack 번들 설정

```json
"scripts": {
  "start": "",
  "serve": "",
  "bundle": "webpack --target web --mode development",
  "watch": "npm run bundle -- --watch",
  "build": "webpack build --target web --mode production",
  "clear": ""
},
```

- webpack 설정을 따로 하지 않으면 기본 값이 src 폴더를 엔드리로 해서 dist를 아웃풋으로 내보낸다.
- mode를 development로 하면 개발용, production으로 하면 배포용. 자동으로 압축된다. 기본값을 production
- target 옵션을 설정해 줄 수 있다. 기본값은 web인데, 오류가 날 수도 있으니 알아두자.

### dev server 설정

```json
"scripts": {
  "serve": "webpack serve --port 3000 --static dist --entry src/index.js --target web --mode development",
}
```

- --entry src/index.js는 기본 값이라 작성하지 않아도 된다.
- port번호를 3000으로 하고 dist 폴더를 정적파일로 실행하겠다는 의미이다.

### webpack configuration

- 웹팩은 노드 환경에서 실행되므로 common.js 방식으로 모듈을 불러오고 내보내야 한다.

- 기존의 webpack.config.js 가 아닌 webpack 폴더에 config.\*.js 방식으로 생성해봤다.

```json
"scripts": {
  "serve": "webpack serve --config webpack/config.server.js",
  "bundle": "webpack --config webpack/config.dev.js",
  "build": "webpack build --config webpack/config.build.js",
}
```

- 기존의 옵션들을 config 파일로 빼서 구성하였다. 이제 명령어를 실행하면 해당 경로를 찾아서 옵션을 확인하고 webpack 번들링을 실행한다.

```javascript
// webpack/config.server.js
const serverConfig = {
  target: "web",
  mode: "development",
  devtool: "source-map",
  devServer: {
    port: 3000,
    static: ["dist"],
  },
};

module.exports = serverConfig;
```

- 예를들어 config.server.js의 경우에는 위와 같이 구성한다.
- devtool은 디버깅 과정 향상을 위해 source mapping 스타일을 선택한다. 이 값은 빌드 및 리빌드 속도에 큰 영향을 미칠 수 있다.

### webpack-merge

- 중복되는 설정은 합치고, 그 외의 설정만 추가로 정의하여 함께 재사용할 수 있도록 도와주는 패키지

```javascript
const { merge } = require("webpack-merge");
const devConfig = require("./config.dev");

const serverConfig = merge(devConfig, {
  devServer: {
    port: 3000,
    static: ["dist"],
  },
});

module.exports = serverConfig;
```

- 중복되는 설정은 config.dev에서 가져와서 사용하고, serverConfig에서 추가적으로 필요한 옵션만 따로 빼와서 사용한다.

## React 설치

`npm i react react-dom `

- react 웹 앱을 개발하기 위해 기본 패키지인 react와 react-dom을 설치한다.
- 이후 정상적으로 컴포넌트 생성 및 react 메서드 사용 가능

### prettier 설정

`npm i -D prettier`

- prettier 생성 후 .prettierrc.js 파일 생성 및 설정
- .prettierignore 파일 생성해서 dist, build, coverage 삽입
- 번거로운 설정이 귀찮을 경우 맥에서는 홈 디렉토리에 미리 설정파일을 보이지 않게 집어넣어 두고, cp 명령어로 복사해서 사용 가능하다.

### eslint 설정

`npx eslint --init`  
`npm i -D eslint-plugin-prettier eslint-plugin-jsx-a11y eslint-config-prettier`

- eslint-plugin-prettier는 prettier를 eslint 규칙으로 실행하고 차이점을 개별 eslint 문제로 보고한다.
- eslint-config-prettier는 필요하지 않거나 prettier와 충돌할 수 있는 모든 규칙을 끈다.
- 마찬가지로 .eslintignore 파일 생성해서 dist, build, coverage 삽입
- .eslintrc 파일에 플러그인이나 extends를 설정해 줌

```javascript
// .eslintrc.js
module.exports = {
  env: {
    browser: true,
    es2021: true,
    node: true,
  },
  extends: [
    "eslint:recommended",
    "plugin:react/recommended",
    "plugin:jsx-a11y/recommended",
    "prettier",
  ],
  parserOptions: {
    ecmaFeatures: {
      jsx: true,
    },
    ecmaVersion: "latest",
    sourceType: "module",
  },
  plugins: ["react", "jsx-a11y", "prettier"],
  rules: {
    "react/prop-types": "warn",
    "prettier/prettier": "error",
    "arrow-body-style": "off",
    "prefer-arrow-callback": "off",
  },
};
```

## Webpack babel 설정

`npm i -D babel-loader @babel/{core,preset-env,preset-react}`

- babel-loader는 웹팩에 바벨을 붙이기 위해 필요
- @babel/core는 필수, @babel/preset-env는 ES6를 컴파일, @babel/preset-react는 리액트 개발에 필요
- 여기서 JSX 문법으로 컴포넌트를 수정하면 에러가 발생한다. loader 설정을 안했기 때문!

```javascript
// .babelrc.js
module.exports = {
  presets: ["@babel/preset-env", "@babel/preset-react"],
};
```

```javascript
// config.dev.js
const devConfig = {
  target: ["web"],
  mode: "development",
  devtool: "source-map",
  // 모듈 > 규칙(들) > (개별) 로더 구성 (어떤 파일? 제외 항목? 어떤 로더 사용? 옵션은?)
  module: {
    rules: [
      // babel-loader 구성
      {
        test: /\.jsx?$/i,
        exclude: /(node_modules|dist)/,
        use: "babel-loader",
      },
    ],
  },
};

module.exports = devConfig;
```

- babel-loader를 사용해서 확장자명이 .js나 .jsx인 파일들을 모두 컴파일하고 번들링하겠다는 뜻. 단 node_modules나 dist파일은 제외하고

### css 팁

```css
button svg {
  pointer-events: none;
}
```

- 버튼 안에 svg가 있는 경우 이벤트 전파가 안되게 막아준다.

### window.requestAnimationFrame()

- 브라우저에게 수행하기를 원하는 애니메이션을 알리고 다음 리페인트가 진행되기 전에 해당 애니메이션을 업데이트하는 함수를 호출하게 한다.
- 특이한 비동기 함수인데, 모니터의 주사율에 맞게 함수를 실행하게 되어있다.
- 스스로를 반복 호출하지 않기 때문에, 반복하려면 재귀적으로 다시 호출해주어야 한다.

### JSX inline style

```javascript
export const RandomCountUpApp = ({ count, isComplete }) => {
  const completeStyle = !isComplete ? null : { animationName: "none" };
  return (
    <div className="randomCountUp">
      <output style={completeStyle}>{count}</output>
    </div>
  );
};
```

- 보간법을 사용해 객체로 inline style을 삽입하였다.
