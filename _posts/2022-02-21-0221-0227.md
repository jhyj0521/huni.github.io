---
title: "0221 - 0227"
tag: TIL
category: TIL
excerpt: ""
---

## 0221

카카오에 최종 면접을 보고 최종 불합격 통보를 받고나서 이런저런 생각들을 정리하느라 조금 방황했던 것 같다.  
하지만 이제 제대로 시작한 지 얼마 지나지 않았고, 짧은 기간만에 좋은 기회가 주어졌었던 것이라고 생각하며 다음으로 나아갈 때이다.  
내가 생각하기에 부족한 점들을 점차 메꿔나가며 준비하다보면 또 다른 좋은 기회가 기다리고 있을 것이다.

## 메꿔야 할 영역

### 리액트

핑계일수도 있겠지만 카카오 면접을 준비하다보니 리액트를 제대로 공부하지 못했다는 생각이 든다.  
물론 이 사실이 합격 여부에 영향을 주지는 않았겠지만, 정말 많은 기업이 리액트를 메인 프레임워크로 사용하고 자격 요건에도 필요로 한다.  
그렇기에 성능, 재사용 관점에서 사용하기 용이한 컴포넌트를 만들 수 있도록 리액트의 기본동작부터 학습해야겠다고 느꼈다.

### 타입스크립트

타입스크립트는 메꿔야한다기보다는 내가 요즘 많이 관심이 가는 기술이기도 하고, 그만큼 공부하고 싶어서 넣어보았다.  
타입스크립트의 기본기를 익히기는 쉽지만 잘 활용하기는 쉽지 않다고 생각한다.  
조만간 리액트와 타입스크립트를 사용하여 프로젝트를 진행해보아야겠다.

### CS

대학시절 초반에 과 공부에 흥미를 느끼지 못한 것과 배웠던 내용을 그저 시험 대비용으로만 공부했던 것이 이번에 가장 큰 화근이 되지 않았나 싶다.  
사실 대학 관련된 질문들을 받았을 때 내가 이 전공을 함으로써 남들보다 얻을 수 있는 이점을 어필하기가 쉽지 않았다.  
그렇기에 부족하다고 느끼거나 중요하다고 느낀 CS 지식들은 추가적으로 학습해야함을 느끼게 되었다.  
HTTP 완벽 가이드부터 시작하자.

### introduce

나를 소개할만한 포트폴리오를 하나 만들어야 할 것 같다.  
짧은 시간동안 인성면접을 준비하다보니 나를 어필할 단어나 문장을 많이 생각해두지 못했다고 느끼게 되었다.  
내 생각을 더 꾸준히 정리하고, 또한 트렌드에 더 관심을 기울일 필요가 있을 것 같다.

# 타입스크립트와 자바스크립트의 관계

타입스크립트는 자바스크립트의 상위집합(superset)이다.  
그렇기에 자바스크립트로 작성한 main.js 파일명을 main.ts로 바꾼다고 해도 달라지는 것은 없다.

이러한 특성은 기존에 존재하는 자바스크립트 코드를 타입스크립트로 마이그레이션하는 데 엄청난 이점이 된다.  
기존 코드를 그대로 유지하면서 일부분에만 타입스크립트 적용이 가능하기 때문이다.

모든 자바스크립트 프로그램은 타입스크립트이지만, 타입스크립트 프로그램이지만 자바스크립트가 아닌 프로그램이 존재한다.  
이는 타입스크립트가 타입을 명시하는 추가적인 문법을 가지기 때문이다.

타입스크립트 컴파일러는 타입스크립트뿐만 아니라 일반 자바스크립트 프로그램에도 유용하다.

```javascript
let city = "new york city";
console.log(city.toUppercase());
// 'toUppercase' 속성이 'string' 형식에 없습니다.
// 'toUpperCase'를 사용하시겠습니까?
```

- city 변수가 문자열이라는 것을 알려 주지 않아도 타입스크립트는 초깃값으로부터 타입을 추론한다.
- 타입 시스템의 목표 중 하나는 런타임에 오류를 발생시킬 코드를 미리 찾아내는 것이다.
- 타입스크립트가 정적 타입 시스템이라는 것은 바로 이런 특징을 말하는 것이다.

타입스크립트는 자바스크립트 런타임 동작을 모델링하는 타입 시스템을 가지고 있기 때문에 런타임 오류를 발생시키는 코드를 찾아내려고 한다.  
그러나 타입 체커를 통과하면서도 런타임 오류를 발생시키는 코드는 충분히 존재할 수 있기에 모든 오류를 찾아내리라 기대해서는 안 된다.  
잘못된 매개변수 개수로 함수를 호출하는 경우처럼, 자바스크립트에서는 허용되지만 타입스크립트에서는 문제가 되는 경우도 존재한다. 이러한 문법의 엄격함은 온전히 취향의 차이이며 우열을 가릴 수 없는 문제이다.

# 타입스크립트 설정 이해하기

다음 코드가 오류 없이 타입 체커를 통과할 수 있을까?

```typescript
function add(a, b) {
  return a + b;
}
add(10, null);
```

정답은 '타입스크립트 컴파일러 설정에 따라 다르다'이다.  
타입스크립트는 어떻게 설정하느냐에 따라 완전히 다른 언어처럼 느껴질 수 있다.

설정을 제대로 사용하기 위해서는 noImplicitAny와 strictNullChecks를 이해해야 한다.

### noImplicitAny

변수들이 미리 정의된 타입을 가져야 하는지 여부를 제어한다.  
매개변수에 타입을 미리 정의하지 않으면 타입스크립트는 암묵적으로 any 타입으로 추론한다.  
any 타입을 매개변수에 사용하면 타입 체커는 무력해진다. any는 유용하지만 주의해서 사용해야 한다.

타입스크립트는 타입 정보를 가질 때 가장 효과적이기 때문에, 되도록이면 noImplicitAny를 설정해야 한다.  
그러면 타입스크립트가 문제를 발견하기 수월해지고, 코드의 가독성이 좋아지며, 개발자의 생산성이 향상된다.  
noImplicitAny 설정 해제는, 자바스크립트로 되어 있는 기존 프로젝트를 타입스크립트로 전환하는 상황에만 필요하다.

### strictNullChecks

null과 undefined가 모든 타입에서 허용되는지 확인하는 설정이다.  
이 설정을 추가하면 null과 undefined를 사용하는 경우 오류를 발생시킨다.

null을 허용하려고 한다면 의도를 명시적으로 드러냄으로써 오류를 고칠 수 있다.

```typescript
const x: number | null = null;
```

만약 null을 허용하지 않으려면 이 값이 어디서부터 왔는지 찾아야 하고, null을 체크하는 코드나 단언문을 추가해야 한다.

```typescript
const el = document.getElementById("status");

if (el) {
  el.textContent = "Ready";
}
el!.textContent = "Ready";
```

이 옵션을 설정한다면 "undefined는 객체가 아닙니다"와 같은 런타임 오류를 방지할 수 있다.

# 코드 생성과 타입은 관계없음

타입스크립트 컴파일러는 두 가지 역할을 수행한다.

1. 최신 자바스크립트/타입스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일한다.
2. 코드의 타입 오류를 체크한다.

이 두 가지는 서로 독립적으로 실행한다. 즉, 타입스크립트가 자바스크립트로 변환될 때 코드 내의 타입에는 영향을 주지 않는다. 또한 그 자바스크립트의 실행 시점에도 타입은 영향을 미치지 않는다.

## 타입 오류가 있는 코드도 컴파일이 가능하다

컴파일은 타입 체크와 독립적으로 동작하기 때문에, 타입 오류가 있는 코드도 컴파일이 가능하다.  
타입스크립트 오류는 언어들의 경고와 비슷하다. 문제가 될 만한 부분을 알려 주지만, 그렇다고 빌드를 멈추지는 않는다.  
-> 엄밀히 말하면 코드 생성만이 컴파일이라고 할 수 있기 때문에 코드에 오류가 있을 때 '타입 체크에 문제가 있다'라고 말하는 것이 더 정확한 표현이다.

## 런타임에는 타입 체크가 불가능하다

```typescript
interface Square {
  width: number;
}

interface Rectangle extends Square {
  height: number;
}

type Shape = Square | Rectangle;

function caculateArea(shape: Shape) {
  if (shape instanceof Rectangle) {
    return shape.width * shape.height;
  } else {
    return shape.width * shape.width;
  }
}
```

- instance 체크는 런타임에 일어나지만, Rectangle은 타입이기 때문에 런타임 시점에 아무런 역할을 할 수 없다.
- 실제로 자바스크립트로 컴파일되는 과정에서 모든 인터페이스, 타입, 타입 구문은 그냥 제거되어 버린다.
- 위 코드를 의도한대로 동작시키기 위해서는 런타임에 타입 정보를 유지하는 방법이 필요하다.

### 속성 체크 방법

```typescript
function caculateArea(shape: Shape) {
  if ("height" in shape) {
    return shape.width * shape.height;
  } else {
    return shape.width * shape.width;
  }
}
```

- 속성 체크는 런타임에 접근 가능한 값에만 관련되지만, 타입 체커 역시 shape 타입을 Rectangle로 보정해 주기 때문에 오류가 사라진다.

### 태그 기법

```typescript
interface Square {
  kind: "square";
  width: number;
}

interface Rectangle {
  kind: "rectangle";
  width: number;
  height: number;
}

type Shape = Square | Rectangle;

function caculateArea(shape: Shape) {
  if (shape.kind === "rectangle") {
    return shape.width * shape.height;
  } else {
    return shape.width * shape.width;
  }
}
```

- Shape 타입은 태그된 유니온의 한 예이다. 이 기법은 런타임에 타입 정보를 손쉽게 유지할 수 있기 때문에, 타입스크립트에서 흔하게 볼 수 있다.

### 클래스 사용

```typescript
class Square {
  constructor(public width: number) {}
}

class Rectangle extends Square {
  constructor(public width: number, public height: number) {
    super(width);
  }
}

type Shape = Square | Rectangle;

function caculateArea(shape: Shape) {
  if (shape instanceof Rectangle) {
    return shape.width * shape.height;
  } else {
    return shape.width * shape.width;
  }
}
```

- 인터페이스는 타입으로만 사용 가능하지만, 타입을 클래스로 선언하면 타입과 값으로 모두 사용할 수 있으므로 오류가 없다.

## 타입 연산은 런타임에 영향을 주지 않는다

```typescript
function asNumber(val: number | string): number {
  return val as number;
}
```

- 이 코드는 타입 체커를 통과하지만 잘못된 방법이다.
- as number는 타입 연산이고 런타임 동작에는 아무런 영향을 미치지 않는다.
- 값을 정제하기 위해서는 런타임의 타입을 체크해야 하고 자바스크립트 연산을 통해 변환을 수행해야 한다.

```typescript
function asNumber(val: number | string): number {
  return typeof val === "string" ? Number(val) : val;
}
```

## 런타임 타입은 선언된 타입과 다를 수 있다

- 예를 들어, 네트워크 호출로부터 받아온 값으로 함수를 실행하는 경우 값의 타입을 보장할 수 없다.
- 타입스크립트에서 런타임 타입과 선언된 타입은 맞지 않을 수 있기에 타입이 달라지는 혼란스러운 상황은 가능한 한 피해야 한다.
- 선언된 타입은 언제든지 달라질 수 있다!

## 타입스크립트 타입으로는 함수를 오버로드할 수 없다

- 동일한 이름에 매개변수만 다른 여러 버전의 함수를 함수 오버로딩이라고 한다.
- 타입스크립트에서는 타입과 런타임의 동작이 무관하기 때문에 함수 오버로딩은 불가능하다.
- 타입스크립트가 함수 오버로딩 기능을 지원하기는 하지만, 온전히 타입 수준에서만 동작한다. 즉, 하나의 함수에 대해 여러 개의 선언문을 작성할 수 있지만, 구현체는 오직 하나뿐이다.

## 타입스크립트 타입은 런타임 성능에 영향을 주지 않는다

- 타입과 타입 연산자는 자바스크립트 변환 시점에 제거되기 때문에 런타임의 성능에 아무런 영향을 주지 않는다.

# 구조적 타이핑에 익숙해지기

자바스크립트는 본질적으로 덕 타이핑 기반이다.

**덕 타이핑**  
객체가 어떤 타입에 부합하는 변수와 메서드를 가질 경우 객체를 해당 타입에 속하는 것으로 간주하는 방식

타입스크립트는 이런 동작, 즉 매개변수 값이 요구사항을 만족한다면 타입이 무엇인지 신경 쓰지 않는 동작을 그대로 모델링한다.

```typescript
interface Vector2D {
  x: number;
  y: number;
}

interface NamedVector {
  name: string;
  x: number;
  y: number;
}

const v: NamedVector = { name: "HI", x: 3, y: 4 };

function calculateLength(v: Vector2D) {
  return Math.sqrt(v.x * v.x + v.y * v.y);
}

calculateLength(v); // 정상 출력
```

- NamedVector의 구조가 Vector2D와 호환되기 때문에 함수 호출이 가능한데, 여기서 구조적 타이핑이라는 용어가 사용된다.
- 반대로 구조적 타이핑으로 인해 예상치 못한 오류가 발생할 수도 있다.
- 함수를 작성할 때, 호출에 사용되는 매개변수의 속성들이 매개변수의 타입에 선언된 속성만을 가질 거라 생각하기 쉽다. 이러한 타입은 봉인된 또는 정확한 타입이라고 불리며, 타입스크립트 시스템에서는 표현할 수 없다. 즉, 타입은 열려있다.

```typescript
class C {
  foo: string;
  constructor(foo: string) {
    this.foo = foo;
  }
}

const c = new C("instance of C");
const d: C = { foo: "object literal" }; // 정상
```

- 클래스에서도 구조적 타이핑이 사용되는데, d는 string 타입의 foo 속성을 가지고 생성자(Object.prototype으로 비롯된)를 가지기에 타입이 호환된다.
- 만약 C의 생성자에 단순 할당이 아닌 연산 로직이 존재한다면, d의 경우는 생성자를 실행하지 않으므로 문제가 발생하게 된다.
- 구조적 타이핑을 사용하면 유닛 테스트를 손쉽게 할 수 있다.
