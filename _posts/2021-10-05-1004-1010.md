---
title: "1004-1010"
tag: TIL
category: TIL
---

## 1004

# 61일 차

## 실습 TIL

### Code Structure

```javascript
const todos = [
  { id: 3, content: "HTML", completed: false },
  { id: 2, content: "CSS", completed: true },
  { id: 1, content: "Javascript", completed: false },
];

const render = (todos) =>
  todos
    .map(
      ({ id, content, completed }) => `
        <li id="${id}">
          <label><input type="checkbox" ${
            completed ? "checked" : ""
          }>${content}</label>
        </li>`
    )
    .join("");

console.log(render(todos));
```

위 코드의 문제점 - 응집도가 떨어진다.

개선 코드

```javascript
const Todos = {
  state: [
    { id: 3, content: "Javascript", completed: false },
    { id: 2, content: "CSS", completed: true },
    { id: 1, content: "HTML", completed: false },
  ],
  render() {
    return this.state
      .map(
        ({ id, content, completed }) => `
        <li id="${id}">
          <label><input type="checkbox" ${
            completed ? "checked" : ""
          }>${content}</label>
        </li>`
      )
      .join("");
  },
};
```

객체로 묶어서 응집도를 높였다. 하지만 상태를 은닉할 수 없다는 단점이 존재한다.

개선 코드

```javascript
const Todos = (() => {
  const todos = [
    { id: 3, content: "Javascript", completed: false },
    { id: 2, content: "CSS", completed: true },
    { id: 1, content: "HTML", completed: false },
  ];

  return {
    render() {
      return todos
        .map(
          ({ id, content, completed }) => `
        <li id="${id}">
          <label><input type="checkbox" ${
            completed ? "checked" : ""
          }>${content}</label>
        </li>`
        )
        .join("");
    },
  };
})();
```

즉시 실행 함수와 클로저를 사용하여 정보를 은닉하였고, this 사용을 억제하였다. 하지만 이 코드는 장황하다는 단점이 있다.

최종 코드

```javascript
const todos = [
  { id: 3, content: 'Javascript', completed: false },
  { id: 2, content: 'CSS', completed: true },
  { id: 1, content: 'HTML', completed: false },
];

const render = () => {
  return todos
    .map(
      ({ id, content, completed }) => `
    <li id="${id}">
      <label><input type="checkbox" ${completed ? 'checked' : ''}>${content}</label>
    </li>`
    )
    .join('');
},

const Todos = { render }

export default Todos;
```

- EMS 모듈 사용. 실무에서는 웹팩을 사용해서 모듈을 사용한다.
- 모듈도 함수만 export 하는 클로저를 이용한 방법이다.

### 정규 표현식 확인 사이트

[정규 표현식 확인 사이트](https://regexr.com/)

<br>

## 1005

# 62일 차

## 프로그래머스 카카오 Level1 - 비밀지도

```javascript
const solution = (n, arr1, arr2) => {
  return arr1.map((v, i) => {
    let tmp1 = arr1[i].toString(2).padStart(n, "0");
    let tmp2 = arr2[i].toString(2).padStart(n, "0");

    return [...tmp1]
      .map((_, i) => ((tmp1[i] | tmp2[i]) === 1 ? "#" : " "))
      .join("");
  });
};
```

- 처음에 코드를 조금 더럽게 썼는데 좀 더 좋은 방법이 있어서 정리해보았다.
- 우선 arr1과 arr2의 요소들을 2진수로 바꾸는데 `toString(2)`를 사용하면 간단하게 2진수로 변경할 수 있었다.
- String.prototype 메서드 중 `padStart()` 메서드를 사용하면 현재 문자열의 시작을 다른 문자열로 채워, 주어진 길이를 만족하는 새로운 문자열을 반환할 수 있다. 첫 번째 인수로 만족할 length 값을, 두 번째 인수로 채울 값을 넘겨준다.
- 비트 연산자 `|` 를 사용하였다. or를 가리킨다.

## 2교시

브라우저 상에서 스크립트 파일을 실행시킬 수 있는 유일한 방법은 script 태그이다.

html은 정보와 구조를 나타낸다.
정보는 텍스트와 태그, 구조는 중첩 관계를 말한다.
html이 기본적으로 가지고 있는 스타일은 브라우저가 제공하는 유저 에이전트 스타일이다.

결국 html, css, js는 뷰를 만들기 위한 언어이다.
html은 브라우저에서만 동작하기에 결국 렌더링 과정을 아는 것이 중요하다.
여기서의 렌더링이란 뷰를 만들어 내는 것
리플로우가 웬만하면 발생하지 않도록 하는 것이 중요하다.

클라이언트가 response를 하면 서버가 리소스를 response를 주는데, 이때 리소스를 정적 리소스라고 한다. (이미 가지고 있기 때문에)

### 3교시

API는 애플리케이션 프로그램 인터페이스
즉 프로그램과 개발자의 인터페이스다.
DOM API는 프로퍼티로 제공되는 것이 있고 메서드로 제공되는 것이 있는데, 프로퍼티는 대부분 접근자 프로퍼티이다.

리플로우를 발생시키지 않는 코드를 작성해야 한다.
작은 프로그램에서는 버벅임을 느끼기 힘들지만 큰 애플리케이션에서는 크게 느껴진다.

### 4교시

DOM 생성이 완료된 직후 DOMContentLoaded 이벤트 발생

실무에서 DOM API를 사용하지 않는 이유  
-> 디자인을 바꿨는데 JS 코드를 수정하고 다시 테스트해야 한다는 문제점이 있다.

그렇다면 html이 자바스크립트에 의존하게 하는 방법?  
-> html을 자바스크립트가 문자열로 가지고 있는 방법

<br />

## 프로그래머스 카카오 Level2 - 뉴스 클러스터링

```javascript
const solution = (str1, str2) => {
  const arr1 = [];
  const arr2 = [];
  const reg = /^[a-z]+$/i;
  const sh = new Map();

  for (let i = 1; i < str1.length; i++) {
    if (reg.test(str1.substring(i - 1, i + 1))) {
      arr1.push(str1.substring(i - 1, i + 1).toLowerCase());
    }
  }

  for (let i = 1; i < str2.length; i++) {
    if (reg.test(str2.substring(i - 1, i + 1))) {
      arr2.push(str2.substring(i - 1, i + 1).toLowerCase());
    }
  }

  let interCnt = 0;

  for (let x of arr1) {
    sh.set(x, (sh.get(x) || 0) + 1);
  }
  for (let x of arr2) {
    if (sh.get(x)) {
      sh.set(x, sh.get(x) - 1);
      interCnt++;
    }
  }

  const unionCnt = arr1.length + arr2.length - interCnt;

  return unionCnt ? Math.floor((interCnt / unionCnt) * 65536) : 65536;
};
```

- test 메서드를 이용하고 싶을 때, 예를 들어 소문자로만 이루어진 문자를 구하고 싶다면 `/^[a-z]+$/` a부터 z까지 하나 이상 존재하는데 이로 시작하고 끝난다는 뜻으로 쓰이는 정규 표현식을 사용한다.
- 합집합을 구하기 위해서는 두 집합 총합 - 교집합의 연산으로도 구할 수 있다.

## 1006

# 63일 차

forEach를 사용하는 상황은 상태를 변경시켜야 할 때, map은 상태를 변경 시켜지 않고 새로운 배열을 반환

### 식별자 네이밍

id를 안쓰는 이유?  
-> id는 에러를 발생시키지 않아서 혼란을 유발할 수 있다. 클래스 이름을 잘 짓자

getElements 계열은 사용하지 말자. ( 부작용을 가지고 있다. )  
getElementById()와 querySelector만 사용하자

html 어트리뷰트는 value는 초기값, value 프로퍼티는 최신 상태를 반영

### InnerHtml의 장단점

- 간편하고, 가독성이 좋다.
- untrusted 데이터, 즉 사용자의 정보가 자바스크립트 코드로 흘러들어오기 때문에 XSS 공격에 취약하다
- 기존의 데이터를 지우고, 모두 다시 그린다.

키보드 이벤트에서 keyCode 대신 key를 사용할 것을 공식 문서에서 권장한다.

동적으로 생성되는 요소에 접근하여 요소 노드 객체를 얻어오려면 코드가 더러워진다.  
-> 이벤트를 위임하여 문제를 해결한다.

자바스크립트와 css 둘 중 어느 것을 사용해도 구현이 가능하면 css를 사용한다.

상태가 변경이 되면 render 함수를 호출하여 뷰를 리렌더링 해야 한다.  
-> 상태가 변하면 뷰가 변한다.

이벤트 핸들러 안에서 모든 작업을 다 하려고 하면 코드가 더러워질 수 밖에 없다.  
-> 함수로 만든다.
