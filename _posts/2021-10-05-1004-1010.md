---
title: "1004-1010"
tag: TIL
category: TIL
---

## 1004

# 61일 차

## 실습 TIL

### Code Structure

```javascript
const todos = [
  { id: 3, content: "HTML", completed: false },
  { id: 2, content: "CSS", completed: true },
  { id: 1, content: "Javascript", completed: false },
];

const render = (todos) =>
  todos
    .map(
      ({ id, content, completed }) => `
        <li id="${id}">
          <label><input type="checkbox" ${
            completed ? "checked" : ""
          }>${content}</label>
        </li>`
    )
    .join("");

console.log(render(todos));
```

위 코드의 문제점 - 응집도가 떨어진다.

개선 코드

```javascript
const Todos = {
  state: [
    { id: 3, content: "Javascript", completed: false },
    { id: 2, content: "CSS", completed: true },
    { id: 1, content: "HTML", completed: false },
  ],
  render() {
    return this.state
      .map(
        ({ id, content, completed }) => `
        <li id="${id}">
          <label><input type="checkbox" ${
            completed ? "checked" : ""
          }>${content}</label>
        </li>`
      )
      .join("");
  },
};
```

객체로 묶어서 응집도를 높였다. 하지만 상태를 은닉할 수 없다는 단점이 존재한다.

개선 코드

```javascript
const Todos = (() => {
  const todos = [
    { id: 3, content: "Javascript", completed: false },
    { id: 2, content: "CSS", completed: true },
    { id: 1, content: "HTML", completed: false },
  ];

  return {
    render() {
      return todos
        .map(
          ({ id, content, completed }) => `
        <li id="${id}">
          <label><input type="checkbox" ${
            completed ? "checked" : ""
          }>${content}</label>
        </li>`
        )
        .join("");
    },
  };
})();
```

즉시 실행 함수와 클로저를 사용하여 정보를 은닉하였고, this 사용을 억제하였다. 하지만 이 코드는 장황하다는 단점이 있다.

최종 코드

```javascript
const todos = [
  { id: 3, content: 'Javascript', completed: false },
  { id: 2, content: 'CSS', completed: true },
  { id: 1, content: 'HTML', completed: false },
];

const render = () => {
  return todos
    .map(
      ({ id, content, completed }) => `
    <li id="${id}">
      <label><input type="checkbox" ${completed ? 'checked' : ''}>${content}</label>
    </li>`
    )
    .join('');
},

const Todos = { render }

export default Todos;
```

- EMS 모듈 사용. 실무에서는 웹팩을 사용해서 모듈을 사용한다.
- 모듈도 함수만 export 하는 클로저를 이용한 방법이다.

### 정규 표현식 확인 사이트

[정규 표현식 확인 사이트](https://regexr.com/)

<br>

## 1005

# 62일 차

## 프로그래머스 카카오 Level1 - 비밀지도

```javascript
const solution = (n, arr1, arr2) => {
  return arr1.map((v, i) => {
    let tmp1 = arr1[i].toString(2).padStart(n, "0");
    let tmp2 = arr2[i].toString(2).padStart(n, "0");

    return [...tmp1]
      .map((_, i) => ((tmp1[i] | tmp2[i]) === 1 ? "#" : " "))
      .join("");
  });
};
```

- 처음에 코드를 조금 더럽게 썼는데 좀 더 좋은 방법이 있어서 정리해보았다.
- 우선 arr1과 arr2의 요소들을 2진수로 바꾸는데 `toString(2)`를 사용하면 간단하게 2진수로 변경할 수 있었다.
- String.prototype 메서드 중 `padStart()` 메서드를 사용하면 현재 문자열의 시작을 다른 문자열로 채워, 주어진 길이를 만족하는 새로운 문자열을 반환할 수 있다. 첫 번째 인수로 만족할 length 값을, 두 번째 인수로 채울 값을 넘겨준다.
- 비트 연산자 `|` 를 사용하였다. or를 가리킨다.

## 2교시

브라우저 상에서 스크립트 파일을 실행시킬 수 있는 유일한 방법은 script 태그이다.

html은 정보와 구조를 나타낸다.
정보는 텍스트와 태그, 구조는 중첩 관계를 말한다.
html이 기본적으로 가지고 있는 스타일은 브라우저가 제공하는 유저 에이전트 스타일이다.

결국 html, css, js는 뷰를 만들기 위한 언어이다.
html은 브라우저에서만 동작하기에 결국 렌더링 과정을 아는 것이 중요하다.
여기서의 렌더링이란 뷰를 만들어 내는 것
리플로우가 웬만하면 발생하지 않도록 하는 것이 중요하다.

클라이언트가 response를 하면 서버가 리소스를 response를 주는데, 이때 리소스를 정적 리소스라고 한다. (이미 가지고 있기 때문에)

### 3교시

API는 애플리케이션 프로그램 인터페이스
즉 프로그램과 개발자의 인터페이스다.
DOM API는 프로퍼티로 제공되는 것이 있고 메서드로 제공되는 것이 있는데, 프로퍼티는 대부분 접근자 프로퍼티이다.

리플로우를 발생시키지 않는 코드를 작성해야 한다.
작은 프로그램에서는 버벅임을 느끼기 힘들지만 큰 애플리케이션에서는 크게 느껴진다.

### 4교시

DOM 생성이 완료된 직후 DOMContentLoaded 이벤트 발생

실무에서 DOM API를 사용하지 않는 이유  
-> 디자인을 바꿨는데 JS 코드를 수정하고 다시 테스트해야 한다는 문제점이 있다.

그렇다면 html이 자바스크립트에 의존하게 하는 방법?  
-> html을 자바스크립트가 문자열로 가지고 있는 방법

<br />

## 프로그래머스 카카오 Level2 - 뉴스 클러스터링

```javascript
const solution = (str1, str2) => {
  const arr1 = [];
  const arr2 = [];
  const reg = /^[a-z]+$/i;
  const sh = new Map();

  for (let i = 1; i < str1.length; i++) {
    if (reg.test(str1.substring(i - 1, i + 1))) {
      arr1.push(str1.substring(i - 1, i + 1).toLowerCase());
    }
  }

  for (let i = 1; i < str2.length; i++) {
    if (reg.test(str2.substring(i - 1, i + 1))) {
      arr2.push(str2.substring(i - 1, i + 1).toLowerCase());
    }
  }

  let interCnt = 0;

  for (let x of arr1) {
    sh.set(x, (sh.get(x) || 0) + 1);
  }
  for (let x of arr2) {
    if (sh.get(x)) {
      sh.set(x, sh.get(x) - 1);
      interCnt++;
    }
  }

  const unionCnt = arr1.length + arr2.length - interCnt;

  return unionCnt ? Math.floor((interCnt / unionCnt) * 65536) : 65536;
};
```

- test 메서드를 이용하고 싶을 때, 예를 들어 소문자로만 이루어진 문자를 구하고 싶다면 `/^[a-z]+$/` a부터 z까지 하나 이상 존재하는데 이로 시작하고 끝난다는 뜻으로 쓰이는 정규 표현식을 사용한다.
- 합집합을 구하기 위해서는 두 집합 총합 - 교집합의 연산으로도 구할 수 있다.

## 1006

# 63일 차

forEach를 사용하는 상황은 상태를 변경시켜야 할 때, map은 상태를 변경 시켜지 않고 새로운 배열을 반환

### 식별자 네이밍

id를 안쓰는 이유?  
-> id는 에러를 발생시키지 않아서 혼란을 유발할 수 있다. 클래스 이름을 잘 짓자

getElements 계열은 사용하지 말자. ( 부작용을 가지고 있다. )  
getElementById()와 querySelector만 사용하자

html 어트리뷰트는 value는 초기값, value 프로퍼티는 최신 상태를 반영

### InnerHtml의 장단점

- 간편하고, 가독성이 좋다.
- untrusted 데이터, 즉 사용자의 정보가 자바스크립트 코드로 흘러들어오기 때문에 XSS 공격에 취약하다
- 기존의 데이터를 지우고, 모두 다시 그린다.

키보드 이벤트에서 keyCode 대신 key를 사용할 것을 공식 문서에서 권장한다.

동적으로 생성되는 요소에 접근하여 요소 노드 객체를 얻어오려면 코드가 더러워진다.  
-> 이벤트를 위임하여 문제를 해결한다.

자바스크립트와 css 둘 중 어느 것을 사용해도 구현이 가능하면 css를 사용한다.

상태가 변경이 되면 render 함수를 호출하여 뷰를 리렌더링 해야 한다.  
-> 상태가 변하면 뷰가 변한다.

이벤트 핸들러 안에서 모든 작업을 다 하려고 하면 코드가 더러워질 수 밖에 없다.  
-> 함수로 만든다.

## 1007

## todolist 만들기

과제로 받게 된 todolist를 학습하면서 새로 알게 된 내용들을 정리해보고자 한다.

### state

기존에 active, completed로 필터링을 하지 않고 모든 todos 리스트를 화면에 보여줄 때는 state에 todos만 관리하였다.  
하지만 이번에 새로운 기능이 추가되면서 active 필터 클릭 시에는 완료되지 않은 목록들만, 그리고 completed 필터 클릭 시에는 완료된 목록들만 보여줘야 했다.  
여기에서 핀트를 잘못 잡고 고민하는 바람에 너무 많은 시간을 쏟아서 고생했던 것 같다.  
결국 filter라는 state를 추가하여 문제를 해결하였다.

기존에는 state가 정보를 관리하는 용도 정도로만 알고, 어떠한 정보들을 여기에 저장해야 하는지 명확하게 설명할 수 없었다.  
하지만 이번 실습을 통해 state가 변경되면 리렌더링이 발생한다는 사실을 알게되었고, 반대로 말하면 변경 시 리렌더링을 발생시키는 정보들을 state에 저장해야 한다는 것을 배웠다.

### 각 함수 상단에 주석달기

코드가 고작 200줄도 안되는 작은 프로젝트였지만, 문서 내에서 이동을 하다보니 불편함을 겪었다.  
그래서 조금이나마 스크롤링을 덜 하기 위해 함수 단위로 내용을 접어두었더니, 함수가 어떤 역할을 하는 로직을 가지고 있는지 알기가 쉽지 않았다. 특히 이벤트 핸들러 부분은 이벤트 타깃과 이벤트 타입밖에 나와있지 않다보니 판별이 불가능한 지경에 이르렀다.  
프로젝트를 진행할 때 함수에 대한 간단한 주석을 함수 위에 작성해야겠다.

### 코딩스킬

- 일단 구현해놓고 나중에 수정하기로 한 부분은 주석을 꼭 달아두자
- if, else if, else 문을 삼항 조건 연산자로 해결할 수 있다.
- `classList.toggle` 메서드를 사용하면 조건문에 따라 클래스를 추가, 삭제할 수 있다.
- 서버에서 무언가를 가지고 올 때는 fetch가 컨벤션이다.
- 상위 요소에서 위임받는 경우가 아니라면 e.target이 아닌 요소로 바로 접근하자.
- 특정 노드에서 상위 요소로 접근하여야 하는 경우 바로 한 단계 위에 있다면 parentNode로 접근하면 되지만, 그 이상 있는 경우 코드를 깔끔하게 작성하기 위해 `closest('css 선택자 규칙')` 메서드를 사용한다. 이는 가장 가까운 부모 요소 노드를 찾는다.
- 이벤트 타입 click은 클릭 시, change는 input, select, textarea 요소의 값이 변경되었을 때 발생한다.
- 이벤트 위임 시, 목표했던 타깃에서 이벤트가 발생했는지 확인하기 위해 검사를 해 주는데 특정 클래스가 있는 경우는 `classList.contains('클래스명')`, 없는 경우는 `matches('css 선택자 규칙')`으로 검사한다.
- 특정 요소의 하위 요소들 중 배열을 얻어 배열 메서드를 사용하고 싶은 경우에는 `querySelectorAll` 메서드를 활용할 수 있다.

<br />
<br />

## 1008

## MVC

백엔드에서의 MVC 패턴과는 조금 다르다.

이벤트를 감지해서 동작하는 이벤트 핸들러가 컨트롤러 역할을 한다.  
컨트롤러에서는 여러 작업들을 수행하고, 데이터가 필요하다면 모델의 데이터를 조회하거나 업데이트하는 역할을 한다.

서버에서 가져온 데이터를 변경하는 로직을 모델에 묶는다.  
-> 순수함수로 구성해서 테스트하기 용이하게 만들 수 있다.  
모델이 수정되면, 뷰에서 정보를 가지고 화면에 렌더링한다. 수정된 뷰가 다시 다른 모델을 수정한다면 또 다른 뷰가 수정 될 수 있다.  
복잡한 어플리케이션에서는 이러한 데이터의 양방향 흐름 문제 때문에 에러가 발생했을 때, 어떤 뷰나 모델에서 문제가 발생했는지 알기 어렵고 그로 인해 디버깅이 어려워진다. 그리고 예측 불가능한 코드를 만들게 된다는 문제점이 존재할 수 있다.

## Flux

이런 양방향 데이터 흐름의 문제점을 해결하기 위해 도입된 Flux의 큰 특징은 단방향 데이터 흐름이다.  
액션이 발생하면 디스패처에서 스토어로, 스토어에서 뷰로, 뷰에서 다시 액션을 통해 디스패처로 데이터가 흐르게 된다. 이런 단방향 흐름은 데이터 변화를 훨씬 예측하기 쉽게 만든다.  
추후에 리액트를 공부할 때 이에 대해 조금 더 자세하게 알아봐야겠다.

## 프로그래머스 Level2 - 가장 큰 정사각형 찾기

레벨 2단계임에도 불구하고 어려운 문제였다고 생각한다.  
첫 번째로 정사각형을 찾기 위한 로직을 생각해내야 했고, 두 번째로 효율성을 포함하고 있어서 이를 해결해야했다.

정사각형을 찾기 위한 로직은 생각해내서 BFS로 정확성 테스트를 통과하였으나, 효율성 테스트에서 막히고 말았다.  
결국 이 문제는 BFS가 아닌 다이나믹으로 해결해야했다. 이 문제를 풀며 배운 것들을 정리해보고자 한다.

```javascript
function solution(board) {
  let answer = board[0][0];
  const dist = Array.from(Array(board.length), () =>
    Array(board[0].length).fill(0)
  );

  for (let i = 0; i < board.length; i++) dist[i][0] = board[i][0];
  for (let i = 0; i < board[0].length; i++) dist[0][i] = board[0][i];

  for (let i = 1; i < board.length; i++) {
    for (let j = 1; j < board[i].length; j++) {
      if (board[i][j] === 0) {
        dist[i][j] = 0;
      } else {
        dist[i][j] =
          Math.min(dist[i][j - 1], dist[i - 1][j], dist[i - 1][j - 1]) + 1;
        answer = Math.max(answer, dist[i][j]);
      }
    }
  }

  return answer * answer;
}
```

- 다이나믹을 풀 때 느끼는 점이 있다면 코드는 간결하고 쉬운데, 아이디어를 떠올리기가 어렵다는 것이다.
- dist[x][y]는 x, y일 때 만들 수 있는 정사각형의 한 변의 길이이다.
- 각 0행과 0열은 board와 같게 초기화한다. 이는 앞으로 할 2중 포문을 인덱스 1부터 시작하여 좌, 좌상, 상 위치에 있는 요소들을 검사하기 위함이다.
- board의 값이 0인 경우에는 어차피 정사각형이 끊기기 때문에 dist에도 0을 할당한다.
- 핵심 아이디어는 dist 배열에서 좌, 좌상, 상 위치에 있는 요소들을 확인하여 최소값 + 1로 dist 배열을 완성시켜 나가는 것이다.
- 해당 위치에는 그곳까지의 정사각형 한 변 길이가 저장되어 있기 때문에, 그 중 최소값 + 1을 dist에 할당해준다면 dist에는 위치가 x, y일 때 정사각형 한 변의 길이가 담기게 된다.
